import { AbstractControl, ControlValueAccessor, ValidationErrors, Validator } from '@angular/forms';
import { EventEmitter } from '@angular/core';
import { ThfDatepickerRange } from './interfaces/thf-datepicker-range.interface';
import { ThfDatepickerRangeLiterals } from './interfaces/thf-datepicker-range-literals.interface';
import { ThfDateService } from './../../../services/thf-date/thf-date.service';
export declare const thfDatepickerRangeLiteralsDefault: {
    en: ThfDatepickerRangeLiterals;
    es: ThfDatepickerRangeLiterals;
    pt: ThfDatepickerRangeLiterals;
};
/**
 * @description
 *
 * O `thf-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `thf-datepicker-range` trabalha com um objeto que implementa a interface
 * `ThfDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `t-start-date` e `t-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 */
export declare abstract class ThfDatepickerRangeBaseComponent implements ControlValueAccessor, Validator {
    protected thfDateService: ThfDateService;
    errorMessage: string;
    private _clean?;
    private _disabled?;
    private _endDate?;
    private _literals?;
    private _readonly;
    private _required?;
    private _startDate?;
    private onChangeModel;
    private validatorChange;
    protected dateRange: ThfDatepickerRange;
    protected format: any;
    protected isDateRangeInputFormatValid: boolean;
    protected isStartDateRangeInputValid: boolean;
    protected onTouchedModel: any;
    readonly isDateRangeInputValid: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Habilita ação para limpar o campo.
     *
     * @default `false`
     */
    clean: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Desabilita o campo.
     *
     * @default `false`
     */
    disabled: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Data final.
     */
    endDate: string | Date;
    /**
     * @optional
     *
     * @description
     *
     * Texto de apoio do campo.
     */
    help?: string;
    /**
     * @optional
     *
     * @description
     *
     * Rótulo do campo.
     */
    label?: string;
    /**
     * @optional
     *
     * @description
     *
     * Objeto com as literais usadas no `thf-datepicker-range`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format',
     *    startDateGreaterThanEndDate: 'End date less than start date'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-datepicker-range
     *   [t-literals]="customLiterals">
     * </thf-datepicker-range>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     */
    literals: ThfDatepickerRangeLiterals;
    /**
     * @optional
     *
     * @description
     *
     * Define se a indicação de campo opcional será exibida.
     *
     * > Não será exibida a indicação se:
     * - O campo conter `t-required`;
     * - Não possuir `t-help` e/ou `t-label`.
     *
     * @default `false`
     */
    optional: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será somente leitura.
     *
     * @default `false`
     */
    readonly: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será obrigatório.
     *
     * @default `false`
     */
    required: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Data inicial.
     */
    startDate: string | Date;
    /**
     * @optional
     *
     * @description
     *
     * Evento disparado ao alterar valor do campo.
     */
    onChange?: EventEmitter<any>;
    constructor(thfDateService: ThfDateService);
    protected abstract resetDateRangeInputValidation(): void;
    protected abstract updateScreenByModel(dateRange: ThfDatepickerRange): any;
    registerOnChange(func: any): void;
    registerOnTouched(func: any): void;
    registerOnValidatorChange?(fn: () => void): void;
    validate(control: AbstractControl): ValidationErrors;
    writeValue(dateRange: ThfDatepickerRange): void;
    protected dateFormatFailed(value: string): boolean;
    protected updateModel(value: any): void;
    protected validateModel(value: any): void;
    private convertPatternDateFormat;
    private dateRangeFailed;
    private dateRangeFormatFailed;
    private dateRangeObjectFailed;
    private isDateRangeObject;
    private requiredDateRangeFailed;
}
