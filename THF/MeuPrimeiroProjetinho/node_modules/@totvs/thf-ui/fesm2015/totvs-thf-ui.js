import { Input, Component, NgModule, IterableDiffers, ElementRef, Renderer2, ViewChild, Injectable, EventEmitter, Output, Directive, HostListener, ViewContainerRef, forwardRef, NgZone, ChangeDetectorRef, ComponentFactoryResolver, ɵɵdefineInjectable, Pipe, TemplateRef, ContentChild, ViewChildren, ApplicationRef, Injector, ɵɵinject, INJECTOR, ChangeDetectionStrategy, ContentChildren, InjectionToken, Inject, APP_INITIALIZER } from '@angular/core';
import { CommonModule, DecimalPipe, TitleCasePipe, CurrencyPipe, DatePipe, Location } from '@angular/common';
import { RouterModule, Router, NavigationEnd, NavigationCancel } from '@angular/router';
import { HttpClient, HttpParams, HttpEventType, HttpResponse, HttpRequest, HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule, ControlContainer, NgForm } from '@angular/forms';
import { Subject, fromEvent, throwError, Observable } from 'rxjs';
import { v4 } from 'uuid';
import { DomSanitizer, Title } from '@angular/platform-browser';
import { map, filter, distinctUntilChanged, tap, debounceTime, catchError } from 'rxjs/operators';
import { trigger, state, style, transition, animate, keyframes, AnimationBuilder } from '@angular/animations';
import { __awaiter } from 'tslib';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_AVATAR_SIZES = ['xs', 'sm', 'md', 'lg', 'xl'];
/** @type {?} */
const THF_AVATAR_SIZE_DEFAULT = 'md';
/**
 * \@description
 *
 * O componente `thf-avatar` é um container para imagens em miniatura, possui um formato redondo e cinco opções de
 * tamanho, pode ser utilizado para mostrar a foto do perfil de um usuário, entre outras possibilidades.
 *
 * Além de poder ser utilizado separadamente, é possível usar o `thf-avatar` juntamente com outros componentes e criar
 * layouts ricos e bem interessantes para os usuários, como por exemplo, uma lista de itens ou produtos.
 */
class ThfAvatarBaseComponent {
    constructor() {
        this._size = 'md';
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Tamanho de exibição do componente.
     *
     * Valores válidos:
     *  - `xs` (24x24)
     *  - `sm` (32x32)
     *  - `md` (64x64)
     *  - `lg` (96x96)
     *  - `xl` (144x144)
     *
     * \@default `md`
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this._size = THF_AVATAR_SIZES.includes(value) ? value : THF_AVATAR_SIZE_DEFAULT;
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
}
ThfAvatarBaseComponent.propDecorators = {
    src: [{ type: Input, args: ['t-src',] }],
    size: [{ type: Input, args: ['t-size',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfAvatarBaseComponent
 *
 * \@example
 *
 * <example name="thf-avatar-basic" title="Totvs Avatar Basic" >
 *  <file name="sample-thf-avatar-basic/sample-thf-avatar-basic.component.html"> </file>
 *  <file name="sample-thf-avatar-basic/sample-thf-avatar-basic.component.ts"> </file>
 *  <file name="sample-thf-avatar-basic/sample-thf-avatar-basic.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-avatar-basic/sample-thf-avatar-basic.component.po.ts"> </file>
 * </example>
 *
 * <example name="thf-avatar-labs" title="Totvs Avatar Labs" >
 *  <file name="sample-thf-avatar-labs/sample-thf-avatar-labs.component.html"> </file>
 *  <file name="sample-thf-avatar-labs/sample-thf-avatar-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-avatar-business-card" title="Totvs Avatar - Business Card" >
 *  <file name="sample-thf-avatar-business-card/sample-thf-avatar-business-card.component.html"> </file>
 *  <file name="sample-thf-avatar-business-card/sample-thf-avatar-business-card.component.ts"> </file>
 * </example>
 */
class ThfAvatarComponent extends ThfAvatarBaseComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.src) {
            this.src = undefined;
        }
    }
    /**
     * @return {?}
     */
    onError() {
        this.src = undefined;
    }
}
ThfAvatarComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-avatar',
                template: "<div class=\"thf-avatar thf-avatar-{{ size }}\">\n  <ng-container *ngIf=\"src; then sourceImage; else defaultIcon\"></ng-container>\n</div>\n\n<ng-template #sourceImage>\n  <img class=\"thf-avatar-image\" [src]=\"src\" alt=\"\" (error)=\"onError()\">\n</ng-template>\n\n<ng-template #defaultIcon>\n  <span class=\"thf-icon thf-icon-user thf-avatar-default-icon\"></span>\n</ng-template>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-avatar.
 */
class ThfAvatarModule {
}
ThfAvatarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ThfAvatarComponent
                ],
                exports: [
                    ThfAvatarComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Este componente gera uma estrutura de navegação que apresenta ao usuário a localização
 * da URL atual, exibindo as antecessoras conforme é realizado a navegação na aplicação.
 *
 * Quando não houver espaçamento suficiente para exibi-lás, o componente se encarrega também
 * de agrupar as URLs antecessoras, gerando assim um ícone que permite a visualização em cascata.
 *
 * Caso um endereço seja especificado na propriedade `t-favorite-service`, o componente permite ao usuário
 * favoritar a URL.
 *
 * Havendo necessidade de incluir parâmetros na requisição do serviço,
 * o componente dispõe da propriedade `t-params-service` que recebe um objeto contendo as informações.
 */
class ThfBreadcrumbBaseComponent {
    constructor() {
        this.itemsView = [];
        this._items = [];
    }
    /**
     * \@description
     *
     * Lista de itens do _breadcrumb_.
     *
     * **Exemplo:**
     * ```
     * { label: 'Thf Portal', link: 'portal' }
     * ```
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._items = items;
        this.itemsView = [].concat(items);
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
}
ThfBreadcrumbBaseComponent.propDecorators = {
    favoriteService: [{ type: Input, args: ['t-favorite-service',] }],
    items: [{ type: Input, args: ['t-items',] }],
    paramsService: [{ type: Input, args: ['t-params-service',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfBreadcrumbBaseComponent
 *
 * \@example
 *
 * <example name="thf-breadcrumb-basic" title="Totvs Breadcrumb Basic">
 *  <file name="sample-thf-breadcrumb-basic/sample-thf-breadcrumb-basic.component.html"> </file>
 *  <file name="sample-thf-breadcrumb-basic/sample-thf-breadcrumb-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-breadcrumb-labs" title="Totvs Breadcrumb Labs">
 *  <file name="sample-thf-breadcrumb-labs/sample-thf-breadcrumb-labs.component.html"> </file>
 *  <file name="sample-thf-breadcrumb-labs/sample-thf-breadcrumb-labs.component.ts"> </file>
 * </example>
 */
class ThfBreadcrumbComponent extends ThfBreadcrumbBaseComponent {
    /**
     * @param {?} differs
     * @param {?} element
     * @param {?} renderer
     */
    constructor(differs, element, renderer) {
        super();
        this.element = element;
        this.renderer = renderer;
        this.showDropdown = false;
        this.showDropdownToggle = false;
        this._breadcrumbItemsLenght = 0;
        this.calculatedElement = false;
        this.hiddenWithoutResize = false;
        this.initialized = false;
        this.wasClickedonDropdown = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const clickedOutIconDropdown = this.checkClickOutElement(event, this.dropdownIcon);
            if (clickedOutIconDropdown) {
                this.showDropdown = false;
                this.removeClickoutListener();
            }
        });
        this.differ = differs.find([]).create(null);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initialized = true;
        this.initializeResizeListener();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const breadcrumbWidth = this.breadcrumbElement.nativeElement.offsetWidth;
        // Permite que os disclaimers sejam calculados na primeira vez que o componente torna-se visível,
        // evitando com isso, problemas com Tabs ou Divs que iniciem escondidas.
        if (breadcrumbWidth && !this.calculatedElement && this.initialized) {
            this.initBreadcrumbSize();
        }
        if (this.hiddenWithoutResize) {
            this.debounceResize();
            this.hiddenWithoutResize = false;
        }
        this.checkChangeOnItems();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeClickoutListener();
        this.removeResizeListener();
    }
    /**
     * @return {?}
     */
    toggleDropdown() {
        this.showDropdown = !this.showDropdown;
        this.initializeClickoutListener();
    }
    /**
     * @private
     * @param {?} event
     * @param {?} element
     * @return {?}
     */
    checkClickOutElement(event, element) {
        return element && !element.nativeElement.contains(event.target);
    }
    /**
     * @private
     * @return {?}
     */
    checkChangeOnItems() {
        if (this.differ) {
            /** @type {?} */
            const changes = this.differ.diff(this.items);
            if (changes) {
                this.calcBreadcrumbItemsWidth();
                this.calculatedElement = false;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    calcBreadcrumb() {
        /** @type {?} */
        const breadcrumbFavorite = this.getBreadcrumbFavoriteWidth();
        /** @type {?} */
        const breadcrumb = this.getBreadcrumbWidth(breadcrumbFavorite);
        if (breadcrumb <= this._breadcrumbItemsLenght) {
            this.enableBreadcrumbResponsive();
        }
        else {
            this.disableBreadcrumbResponsive();
        }
    }
    /**
     * @private
     * @return {?}
     */
    getBreadcrumbFavoriteWidth() {
        return this.favoriteService ? this.element.nativeElement
            .querySelector('.thf-breadcrumb-favorite').offsetWidth + 20 : 0;
    }
    /**
     * @private
     * @param {?} breadcrumbFavorite
     * @return {?}
     */
    getBreadcrumbWidth(breadcrumbFavorite) {
        return this.element.nativeElement.querySelector('.thf-breadcrumb').offsetWidth - breadcrumbFavorite;
    }
    /**
     * @private
     * @return {?}
     */
    calcBreadcrumbItemsWidth() {
        /** @type {?} */
        const breadcrumbItem = this.element.nativeElement
            .querySelectorAll('.thf-breadcrumb-item, .thf-breadcrumb-item-unclickable');
        this._breadcrumbItemsLenght = Array.from(breadcrumbItem)
            .map((/**
         * @param {?} breadcrumb
         * @return {?}
         */
        breadcrumb => breadcrumb['offsetWidth']))
            .reduce((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => a + b), 16);
    }
    /**
     * @private
     * @return {?}
     */
    enableBreadcrumbResponsive() {
        this.showDropdownToggle = true;
        this.itemsView = this.items.slice(-2);
        this.dropdownItems = this.items.slice(0, -2).reverse();
    }
    /**
     * @private
     * @return {?}
     */
    disableBreadcrumbResponsive() {
        this.showDropdownToggle = false;
        this.itemsView = [].concat(this.items);
        this.showDropdown = false;
    }
    /**
     * @private
     * @return {?}
     */
    debounceResize() {
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.calculatedElement && !this.hiddenWithoutResize && this.breadcrumbElement.nativeElement.offsetWidth === 0) {
                this.hiddenWithoutResize = true;
            }
            else {
                this.calcBreadcrumb();
            }
        }), 50);
    }
    /**
     * @private
     * @return {?}
     */
    initBreadcrumbSize() {
        this.calcBreadcrumbItemsWidth();
        this.calcBreadcrumb();
        this.calculatedElement = true;
    }
    /**
     * @private
     * @return {?}
     */
    initializeClickoutListener() {
        this.clickoutListener = this.renderer.listen('document', 'click', this.wasClickedonDropdown);
    }
    /**
     * @private
     * @return {?}
     */
    initializeResizeListener() {
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.debounceResize();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    removeClickoutListener() {
        if (this.clickoutListener) {
            this.clickoutListener();
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeResizeListener() {
        this.resizeListener();
    }
}
ThfBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-breadcrumb',
                template: "<div class=\"thf-breadcrumb\" #breadcrumb>\n\n  <ul class=\"thf-breadcrumb-items\">\n\n    <li #dropdownIcon\n      *ngIf=\"showDropdownToggle\"\n      class=\"thf-breadcrumb-item thf-clickable\"\n      (click)=\"toggleDropdown()\">\n\n      <span class=\"thf-breadcrumb-icon-more thf-icon thf-icon-more\"></span>\n      <div class=\"thf-breadcrumb-arrow\"></div>\n    </li>\n\n    <div *ngFor=\"let item of itemsView, let itemIndex = index;\">\n      <thf-breadcrumb-item\n        [t-action]=\"item.action\"\n        [t-label]=\"item.label\"\n        [t-link]=\"item.link\"\n        [t-item-active]=\"itemIndex === (itemsView.length - 1)\">\n      </thf-breadcrumb-item>\n    </div>\n\n  </ul>\n\n  <thf-breadcrumb-favorite *ngIf=\"favoriteService\"\n    [t-favorite-service]=\"favoriteService\"\n    [t-item-active]=\"items[items.length - 1]\"\n    [t-params-service]=\"paramsService\">\n  </thf-breadcrumb-favorite>\n\n  <thf-breadcrumb-dropdown *ngIf=\"showDropdown\"\n    [t-items]=\"dropdownItems\">\n  </thf-breadcrumb-dropdown>\n\n</div>\n"
            }] }
];
/** @nocollapse */
ThfBreadcrumbComponent.ctorParameters = () => [
    { type: IterableDiffers },
    { type: ElementRef },
    { type: Renderer2 }
];
ThfBreadcrumbComponent.propDecorators = {
    breadcrumbElement: [{ type: ViewChild, args: ['breadcrumb', { read: ElementRef, static: true },] }],
    dropdownIcon: [{ type: ViewChild, args: ['dropdownIcon', { read: ElementRef, static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que renderiza o dropdown do thf-breadcrumb.
 */
class ThfBreadcrumbDropdownComponent {
}
ThfBreadcrumbDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-breadcrumb-dropdown',
                template: "<ul class=\"thf-breadcrumb-dropdown\">\n  <li class=\"thf-breadcrumb-dropdown-item\" *ngFor=\"let item of items\" [routerLink]=\"item.link\">\n    {{ item.label }}\n  </li>\n</ul>\n"
            }] }
];
ThfBreadcrumbDropdownComponent.propDecorators = {
    items: [{ type: Input, args: ['t-items',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço utilizado para favoritar/desfavoritar uma url no componente thf-breadcrumb.
 * A API deve retornar um objeto no formato { isFavorite: booleano, url: string }. Em ambos os métodos, GET e POST este
 * objeto deve ser retornado.
 * Ao alterar o status de favorito, a API deve retornar o objeto acima, com o novo status atualizado.
 * No método POST, existe a possibilidade de ser enviado parâmetros junto com a requisição. Neste caso, o objeto enviado
 * para a API terá o formato: { isFavorite: booleano, url: string, params: {} }, onde params é o objeto que pode ser enviado
 * junto com a requisição.
 *
 */
class ThfBreadcrumbFavoriteService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
    }
    /**
     * @return {?}
     */
    get url() { return this._url; }
    /**
     * @return {?}
     */
    get bodyParams() { return this._bodyParams; }
    /**
     * @param {?} url
     * @param {?} params
     * @param {?} item
     * @return {?}
     */
    configService(url, params, item) {
        this._url = url;
        this._bodyParams = {
            isFavorite: false,
            url: item.link,
            params: params
        };
    }
    /**
     * @param {?} status
     * @return {?}
     */
    sendStatusFavorite(status) {
        this.bodyParams['isFavorite'] = status;
        return this.http.post(this.url, this.bodyParams);
    }
    /**
     * @return {?}
     */
    getFavorite() {
        return this.http.get(this.url, { responseType: 'json', params: { url: this.bodyParams['url'] } });
    }
}
ThfBreadcrumbFavoriteService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfBreadcrumbFavoriteService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que renderiza o serviço de favoritar do thf-breadcrumb.
 */
class ThfBreadcrumbFavoriteComponent {
    /**
     * @param {?} service
     */
    constructor(service) {
        this.service = service;
        this.favorite = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.service.configService(this.favoriteService, this.paramsService, this.itemActive);
        this.getStatusFavorite();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.getSubscription) {
            this.getSubscription.unsubscribe();
        }
        if (this.setSubscription) {
            this.setSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    toggleFavoriteAction() {
        this.favorite ? this.setStatusFavorite(false) : this.setStatusFavorite(true);
    }
    /**
     * @private
     * @return {?}
     */
    getStatusFavorite() {
        this.getSubscription = this.service.getFavorite().subscribe((/**
         * @param {?} result
         * @return {?}
         */
        result => this.favorite = result.isFavorite));
    }
    /**
     * @private
     * @param {?} status
     * @return {?}
     */
    setStatusFavorite(status) {
        this.setSubscription = this.service.sendStatusFavorite(status).subscribe((/**
         * @param {?} result
         * @return {?}
         */
        result => this.favorite = result.isFavorite));
    }
}
ThfBreadcrumbFavoriteComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-breadcrumb-favorite',
                template: "<div class=\"thf-breadcrumb-favorite thf-clickable\" (click)=\"toggleFavoriteAction()\">\n\n  <span\n    class=\"thf-icon thf-icon-star thf-breadcrumb-favorite-star thf-clickable\"\n    [class.thf-breadcrumb-favorite-star-active]=\"favorite\">\n  </span>\n\n  <span class=\"thf-hidden-sm thf-breadcrumb-favorite-label\" *ngIf=\"favorite\">Desfavoritar</span>\n  <span class=\"thf-hidden-sm thf-breadcrumb-favorite-label\" *ngIf=\"!favorite\">Favoritar</span>\n</div>\n",
                providers: [ThfBreadcrumbFavoriteService]
            }] }
];
/** @nocollapse */
ThfBreadcrumbFavoriteComponent.ctorParameters = () => [
    { type: ThfBreadcrumbFavoriteService }
];
ThfBreadcrumbFavoriteComponent.propDecorators = {
    favoriteService: [{ type: Input, args: ['t-favorite-service',] }],
    itemActive: [{ type: Input, args: ['t-item-active',] }],
    paramsService: [{ type: Input, args: ['t-params-service',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que renderiza cada item do thf-breadcrumb.
 */
class ThfBreadcrumbItemComponent {
    constructor() {
        // Especifica se item é o link ativo.
        this.itemActive = false;
    }
}
ThfBreadcrumbItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-breadcrumb-item',
                template: "<li *ngIf=\"!itemActive\"\n  [class.thf-breadcrumb-item]=\"link || action\"\n  [class.thf-breadcrumb-item-unclickable]=\"!link && !action\">\n\n  <a *ngIf=\"link\" [routerLink]=\"link\">\n    <label class=\"thf-breadcrumb-label\">{{ label }}</label>\n    <div class=\"thf-breadcrumb-arrow\"></div>\n  </a>\n\n  <a *ngIf=\"!link && action\" (click)=\"action(label)\">\n    <label class=\"thf-breadcrumb-label\">{{ label }}</label>\n    <div class=\"thf-breadcrumb-arrow\"></div>\n  </a>\n\n  <a *ngIf=\"!link && !action\">\n    <label class=\"thf-breadcrumb-label\">{{ label }}</label>\n    <div class=\"thf-breadcrumb-arrow\"></div>\n  </a>\n</li>\n\n<li *ngIf=\"itemActive\" class=\"thf-breadcrumb-item-unclickable\">\n  <label class=\"thf-breadcrumb-label\">{{ label }}</label>\n</li>\n"
            }] }
];
ThfBreadcrumbItemComponent.propDecorators = {
    action: [{ type: Input, args: ['t-action',] }],
    label: [{ type: Input, args: ['t-label',] }],
    link: [{ type: Input, args: ['t-link',] }],
    itemActive: [{ type: Input, args: ['t-item-active',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-breadcrumb.
 *
 */
class ThfBreadcrumbModule {
}
ThfBreadcrumbModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule
                ],
                declarations: [
                    ThfBreadcrumbComponent,
                    ThfBreadcrumbDropdownComponent,
                    ThfBreadcrumbFavoriteComponent,
                    ThfBreadcrumbItemComponent
                ],
                exports: [ThfBreadcrumbComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Idiomas suportados pelas páginas
/** @type {?} */
const thfLocales = ['pt', 'en', 'es'];
// Idioma padrão
/** @type {?} */
const thfLocaleDefault = 'pt';
/**
 * @deprecated
 * Utilize o método `getShortBrowserLanguage`.
 *
 * \@description
 * Retorna idioma do browser ou o idioma padrão.
 * @return {?}
 */
function browserLanguage() {
    return getShortBrowserLanguage();
}
/**
 * Retorna o idioma atual do navegador
 * @return {?}
 */
function getBrowserLanguage() {
    // navigator.userLanguage is the value for IE10
    /** @type {?} */
    const language = navigator.language || navigator['userLanguage'];
    /** @type {?} */
    const shortLanguage = getShortLanguage(language);
    return thfLocales.includes(shortLanguage) ? language : thfLocaleDefault;
}
/**
 * Retorna o idioma do navegador, com somente as duas primeiras letras. Por exemplo: "pt" ou "es".
 *
 * Caso o valor retornado pelo navegador não estiver dentro dos idiomas suportados pelo THF,
 * será retornado a linguagem padrão (thfLocaleDefault).
 * @return {?}
 */
function getShortBrowserLanguage() {
    return getShortLanguage(getBrowserLanguage());
}
/**
 * Retorna o idioma com somente a abreviação do idioma (duas primeiras letras).
 * Por exemplo: "pt" ou "es".
 *
 * \@default pt
 * @param {?} language {string} linguagem.
 *
 * @return {?} sigla do idioma padrão {string}.
 *
 */
function getShortLanguage(language) {
    return (language || thfLocaleDefault).toLowerCase().substring(0, 2);
}
/**
 * @param {?} value
 * @return {?}
 */
function isLanguage(value) {
    /** @type {?} */
    const languageRegex = new RegExp('^[a-z]{2}(\-[a-z]{2})?$', 'i');
    return languageRegex.test(value);
}
/* istanbul ignore next */
/**
 * @return {?}
 */
function reloadCurrentPage() {
    window.location.assign(location.href);
}
/**
 * @param {?} val
 * @return {?}
 */
function convertToBoolean(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === 'on' || val === '');
    }
    if (typeof val === 'number') {
        return val === 1;
    }
    return !!val;
}
/**
 * @param {?} value
 * @param {?=} valueDefault
 * @return {?}
 */
function convertToInt(value, valueDefault) {
    /** @type {?} */
    const validNumber = parseInt(value, 10);
    /** @type {?} */
    const validDefaultValue = parseInt(valueDefault, 10);
    /** @type {?} */
    const defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : undefined;
    return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
/**
 * @param {?} object
 * @param {?} type
 * @return {?}
 */
function isTypeof(object, type) {
    return typeof object === type;
}
/**
 *
 * @param {?} fn Função que será executada dentro do contexto. Podendo ser o nome da função
 * ou a referência da mesma.
 *
 * @param {?} context Contexto do qual a função será executada.
 * @param {?=} param
 * @return {?}
 */
function callFunction(fn, context, param) {
    if (isTypeof(fn, 'function')) {
        fn.call(context, param);
    }
    else {
        context[fn](param);
    }
}
/**
 * @param {?} value
 * @param {?} start
 * @param {?} end
 * @return {?}
 */
function convertIsoToDate(value, start, end) {
    if (value) {
        /** @type {?} */
        const day = parseInt(value.substring(8, 10), 10);
        /** @type {?} */
        const month = parseInt(value.substring(5, 7), 10);
        /** @type {?} */
        const year = parseInt(value.substring(0, 4), 10);
        if (start) {
            /** @type {?} */
            const date = new Date(year, month - 1, day, 0, 0, 0);
            setYearFrom0To100(date, year);
            return date;
        }
        else if (end) {
            /** @type {?} */
            const date = new Date(year, month - 1, day, 23, 59, 59);
            setYearFrom0To100(date, year);
            return date;
        }
        else {
            /** @type {?} */
            const milliseconds = Date.parse(value);
            /** @type {?} */
            const timezone = new Date().getTimezoneOffset() * 60000;
            return new Date(milliseconds + timezone);
        }
    }
}
/**
 * @param {?} date
 * @return {?}
 */
function convertDateToISODate(date) {
    if (date) {
        /** @type {?} */
        const getMonth = date.getMonth() + 1;
        /** @type {?} */
        const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
        /** @type {?} */
        const month = getMonth < 10 ? '0' + getMonth : getMonth;
        /** @type {?} */
        const year = formatYear(date.getFullYear());
        return year + '-' + month + '-' + day;
    }
    else {
        return null;
    }
}
/**
 * @param {?} date
 * @param {?=} time
 * @return {?}
 */
function convertDateToISOExtended(date, time) {
    if (date) {
        /** @type {?} */
        const getMonth = date.getMonth() + 1;
        /** @type {?} */
        const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
        /** @type {?} */
        const month = getMonth < 10 ? '0' + getMonth : getMonth;
        /** @type {?} */
        const year = formatYear(date.getFullYear());
        /** @type {?} */
        const dateString = date.toString();
        if (time !== null) {
            return year + '-' + month + '-' + day + time;
        }
        else {
            return year + '-' + month + '-' + day + 'T' + dateString.substring(16, 24) +
                dateString.substring(28, 31) + ':' + dateString.substring(31, 33);
        }
    }
    else {
        return null;
    }
}
/**
 * Transforma o ano em uma string no formato yyyy e caso o ano seja menor que 1000 preenche com zeros a esquerda.
 * @param {?} year Ano
 * @return {?}
 */
function formatYear(year) {
    if (year >= 1000) {
        return year.toString();
    }
    if (year > 99 && year < 1000) {
        return `0${year}`;
    }
    if (year > 9 && year < 100) {
        return `00${year}`;
    }
    if (year >= 0 && year < 10) {
        return `000${year}`;
    }
}
// Verifica se o navegador em que está sendo usado é Internet Explorer ou Edge
/**
 * @return {?}
 */
function isIEOrEdge() {
    /** @type {?} */
    const userAgent = window.navigator.userAgent;
    return /msie\s|trident\/|edge\//i.test(userAgent);
}
// Verifica qual o dispositivo que está sendo usado
/**
 * @return {?}
 */
function isMobile() {
    /** @type {?} */
    const userAgent = window.navigator.userAgent;
    return userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i);
}
/**
 * @param {?} value
 * @param {?} comparedValue
 * @return {?}
 */
function isEquals(value, comparedValue) {
    return JSON.stringify(value) === JSON.stringify(comparedValue);
}
/**
 * @param {?} event
 * @return {?}
 */
function isKeyCodeEnter(event) {
    return event.keyCode === 13 || event.which === 13;
}
/**
 * Caso o ano original da data seja entre 0 e 100 atribui esse valor ao ano, pois o `new Date` do javascript transforma o ano para 190X.
 * @param {?} date Data
 * @param {?} year Ano original
 * @return {?}
 */
function setYearFrom0To100(date, year) {
    if (year >= 0 && year < 100) {
        date.setFullYear(year);
    }
}
/**
 * @param {?} options
 * @param {?} property
 * @return {?}
 */
function sortOptionsByProperty(options, property) {
    options.sort((/**
     * @param {?} optionA
     * @param {?} optionB
     * @return {?}
     */
    (optionA, optionB) => {
        optionA = optionA[property].toString().toLowerCase();
        optionB = optionB[property].toString().toLowerCase();
        if (optionA < optionB) {
            return -1;
        }
        if (optionA > optionB) {
            return 1;
        }
        return 0;
    }));
}
/**
 * @param {?} list
 * @return {?}
 */
function removeDuplicatedOptions(list) {
    for (let i = 0; i < list.length; i++) {
        if (i === 0) {
            continue;
        }
        if (list.findIndex((/**
         * @param {?} op
         * @return {?}
         */
        op => op.value === list[i].value)) !== i) {
            list.splice(i, 1);
            i--;
        }
    }
}
/**
 * @param {?} list
 * @return {?}
 */
function removeUndefinedAndNullOptions(list) {
    for (let i = 0; i < list.length; i++) {
        if (list[i].value === undefined || list[i].value === null) {
            list.splice(i, 1);
            i--;
        }
    }
}
/**
 * @param {?} value
 * @return {?}
 */
function validValue(value) {
    return (value !== null && value !== undefined && value !== '') || value === false;
}
/**
 * @param {?} url
 * @return {?}
 */
function isExternalLink(url) {
    return url ? url.startsWith('http') : false;
}
/**
 * @param {?} url
 * @return {?}
 */
function openExternalLink(url) {
    window.open(url, '_blank');
}
/**
 * @param {?} link
 * @return {?}
 */
function getFormattedLink(link) {
    /** @type {?} */
    let formattedLink = '';
    // Retira todos os pontos no começo da URL.
    if (link) {
        formattedLink = link.replace(/^(\.)+/g, '');
    }
    // Verifica se foi utilizado uma rota que não comece com barra.
    if (!formattedLink.startsWith('/')) {
        formattedLink = '/'.concat(formattedLink);
    }
    return formattedLink;
}
/**
 * Método responsável por ordenar dois valores.
 *
 * @param {?} leftSide Primeiro valor a ser comparado.
 * @param {?} rightSide Segundo valor a ser comparado.
 * @param {?=} ascending Determina se será em ordem ascendente ou descendente.
 * @return {?}
 */
function sortValues(leftSide, rightSide, ascending = true) {
    if (ascending) {
        if (leftSide < rightSide) {
            return -1;
        }
        else if (leftSide > rightSide) {
            return 1;
        }
    }
    else if (ascending === false) {
        if (leftSide < rightSide) {
            return 1;
        }
        else if (leftSide > rightSide) {
            return -1;
        }
    }
    return 0;
}
/**
 * @param {?} date
 * @param {?} dateStart
 * @param {?} dateEnd
 * @return {?}
 */
function validateDateRange(date, dateStart, dateEnd) {
    if (dateStart && dateEnd) {
        return (date >= dateStart && date <= dateEnd);
    }
    else if (dateStart && !dateEnd) {
        return (date >= dateStart);
    }
    else if (!dateStart && dateEnd) {
        return (date <= dateEnd);
    }
    else {
        return true;
    }
}
/**
 * @return {?}
 */
function uuid() {
    /**
     * @return {?}
     */
    function hex4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return hex4() + hex4() + '-' + hex4() + '-' + hex4() + '-' +
        hex4() + '-' + hex4() + hex4() + hex4();
}
/**
 * @param {?} text
 * @return {?}
 */
function capitalizeFirstLetter(text) {
    return `${text.charAt(0).toUpperCase()}${text.slice(1)}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_BUTTON_TYPES = ['default', 'primary', 'danger', 'link'];
/** @type {?} */
const THF_BUTTON_TYPE_DEFAULT = 'default';
/**
 * \@description
 *
 * O `thf-button` permite que o usuário execute ações predefinidas pelo desenvolvedor.
 *
 * Através dos tipos, é possível identificar a importância de cada ação, sendo ela primária (`primary`) ou até mesmo uma
 * ação irreversível (`danger`), como a exclusão de um registro.
 *
 * #### Boas práticas
 *
 * - Evite `labels` extensos que quebram o layout do `thf-button`, use `labels` diretos, curtos e intuitivos.
 * - Utilize apenas um `thf-button` configurado como `primary` por página.
 * - Para ações irreversíveis use sempre o tipo `danger`.
 */
class ThfButtonBaseComponent {
    constructor() {
        this._disabled = false;
        this._loading = false;
        this._small = false;
        this._type = 'default';
        /**
         * Ação que será executada quando o usuário clicar sobre o `thf-button`.
         */
        this.click = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Exibe um ícone de carregamento à esquerda do _label_ do botão.
     *
     * > Quando esta propriedade estiver habilitada, desabilitará o botão.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set loading(value) {
        this._loading = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get loading() {
        return this._loading;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Deixa o botão menor.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set small(value) {
        this._small = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get small() {
        return this._small;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define o estilo do `thf-button`.
     *
     * Valore válidos:
     *  - `default`: estilo padrão do `thf-button`.
     *  - `primary`: deixa o `thf-button` com destaque, deve ser usado para ações primárias.
     *  - `danger`: deve ser usado para ações que o usuário precisa ter cuidado ao executa-lá.
     *  - `link`: o `thf-button` recebe o estilo de um link.
     *
     * \@default `default`
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = THF_BUTTON_TYPES.includes(value) ? value : THF_BUTTON_TYPE_DEFAULT;
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita o `thf-button` e não permite que o usuário interaja com o mesmo.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
}
ThfButtonBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    loading: [{ type: Input, args: ['t-loading',] }],
    icon: [{ type: Input, args: ['t-icon',] }],
    small: [{ type: Input, args: ['t-small',] }],
    type: [{ type: Input, args: ['t-type',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfButtonBaseComponent
 *
 * \@example
 *
 * <example name="thf-button-basic" title="Totvs Button Basic">
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.html"> </file>
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.ts"> </file>
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.po.ts"> </file>
 * </example>
 *
 * <example name="thf-button-labs" title="Totvs Button Labs">
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.html"> </file>
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.ts"> </file>
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.po.ts"> </file>
 * </example>
 */
class ThfButtonComponent extends ThfButtonBaseComponent {
    /**
     * @return {?}
     */
    onClick() {
        this.click.emit(null);
    }
}
ThfButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-button',
                template: "<button\n  class=\"thf-button thf-text-ellipsis\"\n  type=\"button\"\n  [class.thf-button-danger]=\"type === 'danger'\"\n  [class.thf-button-link]=\"type === 'link'\"\n  [class.thf-button-primary]=\"type === 'primary'\"\n  [class.thf-button-sm] = \"small\"\n  [class.thf-clickable]=\"type === 'link'\"\n  [disabled]=\"disabled || loading\"\n  (click)=\"onClick()\">\n\n  <span *ngIf=\"loading\" class=\"thf-icon thf-button-loading-icon\"></span>\n  <span *ngIf=\"icon\" class=\"thf-icon {{ icon }}\" aria-hidden=\"true\"></span>\n  <span *ngIf=\"label\" class=\"thf-button-label\">{{ label }}</span>\n</button>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-button.
 */
class ThfButtonModule {
}
ThfButtonModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ThfButtonComponent
                ],
                exports: [
                    ThfButtonComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 * \@description
 *
 * Serviço responsável por gerenciar as posições de um elemento em relação a um elemento alvo. Ele pode receber as
 * seguintes posições:
 *
 * - `right`: Posiciona o elemento no lado direito do componente alvo.
 * - `right-bottom`: Posiciona o elemento no lado direito inferior do componente alvo.
 * - `right-top`: Posiciona o elemento no lado direito superior do componente alvo.
 * - `bottom`: Posiciona o elemento abaixo do componente alvo.
 * - `bottom-left`: Posiciona o elemento abaixo e à esquerda do componente alvo.
 * - `bottom-right`: Posiciona o elemento abaixo e à direita do componente alvo.
 * - `left`: Posiciona o elemento no lado esquerdo do componente alvo.
 * - `left-top`: Posiciona o elemento no lado esquerdo superior do componente alvo.
 * - `left-bottom`: Posiciona o elemento no lado esquerdo inferior do componente alvo.
 * - `top`: Posiciona o elemento acima do componente alvo.
 * - `top-right`: Posiciona o elemento acima e à direita do componente alvo.
 * - `top-left`: Posiciona o elemento acima e à esquerda do componente alvo.
 *
 * Caso o elemento não caiba na tela na posição indicada ele será rotacionado automaticamente para se adequar,
 * inicialmente no lado definido como padrão e em seguida seguindo o sentido horário.
 * @type {?}
 */
const thfControlPositionSidesDefault = [
    'bottom', 'bottom-left', 'bottom-right',
    'left', 'left-top', 'left-bottom',
    'top', 'top-right', 'top-left',
    'right', 'right-bottom', 'right-top'
];
class ThfControlPositionService {
    constructor() {
        this.differenceDiagonalToWidthArrow = 3;
        this.isSetElementWidth = false;
        // offset da seta em relação ao canto do componente
        this.offsetArrow = 12;
    }
    /**
     * \@description Ajusta a posição do elemento, caso não couber em tela irá para próxima posição.
     *
     * @param {?} value posição para exibição do elemento
     * @return {?}
     */
    adjustPosition(value) {
        /** @type {?} */
        const position = value || 'bottom';
        this.elementPosition(position);
        this.customPositions && this.customPositions.length ? this.adjustCustomPosition(position) : this.adjustDefaultPosition(position);
    }
    /**
     * \@description Retorna a direção da seta, conforme a posição do elemento.
     * @return {?}
     */
    getArrowDirection() {
        return this.arrowDirection;
    }
    /**
     * \@description Método responsável por definir as propriedades utilizadas para exibir o elemento na posição correta.
     *
     * @param {?} element elemento que será exibido
     * @param {?} elementOffset offSet do elemento
     * @param {?} targetElement elemento de onde deve partir a exibição
     * @param {?=} customPositions posições que sobrescreve as posições padrões
     * @param {?=} isSetElementWidth indica se deve definir o tamanho do elemento a ser exibido, caso for verdadeiro será igual do targetElement
     * @param {?=} isCornerAligned indica se o elemento filho será alinhado nos cantos do elemneto pai.
     * @return {?}
     */
    setElements(element, elementOffset, targetElement, customPositions, isSetElementWidth = false, isCornerAligned = false) {
        this.element = (element instanceof ElementRef) ? element.nativeElement : element;
        this.targetElement = (targetElement instanceof ElementRef) ? targetElement.nativeElement : targetElement;
        this.elementOffset = elementOffset;
        this.customPositions = customPositions;
        this.isSetElementWidth = isSetElementWidth;
        this.isCornerAligned = isCornerAligned;
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    adjustCustomPosition(position) {
        /** @type {?} */
        const positionLength = this.customPositions.length;
        /** @type {?} */
        let sidesCount = 0;
        while (sidesCount++ < positionLength) {
            if (this.overflowAllSides(position)) {
                position = this.nextPosition(position, this.customPositions);
                this.elementPosition(position);
            }
        }
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    adjustDefaultPosition(position) {
        /** @type {?} */
        const mainPositions = this.getMainPositions();
        /** @type {?} */
        const mainPositionLength = mainPositions.length;
        /** @type {?} */
        let mainSidesCount = 0;
        while (mainSidesCount++ < mainPositionLength) {
            /** @type {?} */
            const mainPosition = this.getMainPosition(position);
            this.elementPosition(position);
            if (this.overflowMain(mainPosition)) {
                position = this.nextPosition(mainPosition, mainPositions);
                continue;
            }
            else if (this.overflowAllSides(position)) {
                this.verifySubPositions(position);
                return;
            }
            return;
        }
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    elementPosition(position) {
        this.isCornerAligned ? this.setAlignedElementPosition(position) : this.setElementPosition(position);
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    getMainPosition(position) {
        return (position.indexOf('-') > -1) ? position.substring(0, position.indexOf('-')) : position;
    }
    /**
     * @private
     * @return {?}
     */
    getMainPositions() {
        /** @type {?} */
        const defaultMainPositions = ['top', 'right', 'bottom', 'left'];
        return this.customPositions && this.customPositions.length ?
            this.getMainPositionsByCustomPositions(this.customPositions) : defaultMainPositions;
    }
    /**
     * @private
     * @param {?} customPositions
     * @return {?}
     */
    getMainPositionsByCustomPositions(customPositions) {
        /** @type {?} */
        const mainPositions = [];
        /** @type {?} */
        const customPositionsLength = customPositions.length;
        for (let i = 0; i < customPositionsLength; i++) {
            /** @type {?} */
            const position = customPositions[i];
            /** @type {?} */
            const mainPosition = this.getMainPosition(position);
            if (!mainPositions.includes(mainPosition)) {
                mainPositions.push(mainPosition);
            }
        }
        return mainPositions;
    }
    /**
     * @private
     * @return {?}
     */
    getOverflows() {
        /** @type {?} */
        const sizesAndPositions = this.getSizesAndPositions();
        return {
            right: (sizesAndPositions.element.right > sizesAndPositions.window.innerWidth),
            top: (sizesAndPositions.element.top <= 0),
            left: (sizesAndPositions.element.left <= 0),
            bottom: (sizesAndPositions.element.bottom > sizesAndPositions.window.innerHeight)
        };
    }
    /**
     * @private
     * @return {?}
     */
    getSizesAndPositions() {
        return {
            window: {
                scrollY: window.scrollY,
                scrollX: window.scrollX,
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight
            },
            element: this.element.getBoundingClientRect(),
            target: this.targetElement ? this.targetElement.getBoundingClientRect() : { top: 0, bottom: 0, right: 0, left: 0 }
        };
    }
    /**
     * @private
     * @param {?} position
     * @param {?=} positions
     * @return {?}
     */
    nextPosition(position, positions = []) {
        /** @type {?} */
        const index = positions.indexOf(position);
        /** @type {?} */
        const nextIndex = index + 1;
        if (index > -1 && nextIndex < positions.length) {
            return positions[nextIndex];
        }
        else {
            return positions[0];
        }
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    overflowAllSides(position) {
        /** @type {?} */
        const overflows = this.getOverflows();
        switch (position) {
            case 'top': return overflows.top || overflows.right || overflows.left;
            case 'top-right': return overflows.top || overflows.right;
            case 'top-left': return overflows.top || overflows.left;
            case 'right': return overflows.right || overflows.top || overflows.bottom;
            case 'right-top': return overflows.right || overflows.top;
            case 'right-bottom': return overflows.right || overflows.bottom;
            case 'bottom': return overflows.bottom || overflows.right || overflows.left;
            case 'bottom-right': return overflows.bottom || overflows.right;
            case 'bottom-left': return overflows.bottom || overflows.left;
            case 'left': return overflows.left || overflows.top || overflows.bottom;
            case 'left-top': return overflows.left || overflows.top;
            case 'left-bottom': return overflows.left || overflows.bottom;
        }
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    overflowMain(position) {
        /** @type {?} */
        const overflows = this.getOverflows();
        switch (position) {
            case 'top': return overflows.top;
            case 'right': return overflows.right;
            case 'bottom': return overflows.bottom;
            case 'left': return overflows.left;
        }
    }
    /**
     * @private
     * @param {?} elementPosition
     * @return {?}
     */
    setAlignedArrowDirection(elementPosition) {
        switch (elementPosition) {
            case 'top-left': return 'bottom-left';
            case 'top-right': return 'bottom-right';
            case 'bottom-right': return 'top-right';
            case 'bottom-left': return 'top-left';
        }
    }
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    setAlignedBottomPositions(displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left - displacement + 'px';
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    setAlignedElementPosition(position) {
        this.setElementWidth();
        /** @type {?} */
        const sizesAndPositions = this.getSizesAndPositions();
        switch (position) {
            case 'bottom-left':
                this.setAlignedBottomPositions(0, sizesAndPositions);
                break;
            case 'bottom-right':
                this.setAlignedBottomPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
                break;
            case 'top-left':
                this.setAlignedTopPositions(0, sizesAndPositions);
                break;
            case 'top-right':
                this.setAlignedTopPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
                break;
        }
        this.arrowDirection = this.setAlignedArrowDirection(position);
    }
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    setAlignedTopPositions(displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left - displacement + 'px';
    }
    /**
     * @private
     * @param {?} elementPosition
     * @return {?}
     */
    setArrowDirection(elementPosition) {
        switch (elementPosition) {
            case 'top': return 'bottom';
            case 'top-left': return 'bottom-right';
            case 'top-right': return 'bottom-left';
            case 'right': return 'left';
            case 'right-top': return 'left-bottom';
            case 'right-bottom': return 'left-top';
            case 'bottom': return 'top';
            case 'bottom-right': return 'top-left';
            case 'bottom-left': return 'top-right';
            case 'left': return 'right';
            case 'left-bottom': return 'right-top';
            case 'left-top': return 'right-bottom';
        }
    }
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    setBottomPositions(displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left + (sizesAndPositions.target.width / 2) - displacement + 'px';
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    setElementPosition(position) {
        this.setElementWidth();
        /** @type {?} */
        const sizesAndPositions = this.getSizesAndPositions();
        switch (position) {
            case 'top':
                this.setTopPositions((sizesAndPositions.element.width / 2), sizesAndPositions);
                break;
            case 'top-left':
                this.setTopPositions((sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'top-right':
                this.setTopPositions((this.offsetArrow + this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'right':
                this.setRightPositions((sizesAndPositions.element.height / 2), sizesAndPositions);
                break;
            case 'right-top':
                this.setRightPositions((sizesAndPositions.element.height - this.offsetArrow - this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'right-bottom':
                this.setRightPositions(this.offsetArrow, sizesAndPositions);
                break;
            case 'bottom':
                this.setBottomPositions((sizesAndPositions.element.width / 2), sizesAndPositions);
                break;
            case 'bottom-right':
                this.setBottomPositions((this.offsetArrow + this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'bottom-left':
                this.setBottomPositions((sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'left':
                this.setLeftPositions((sizesAndPositions.element.height / 2), sizesAndPositions);
                break;
            case 'left-bottom':
                this.setLeftPositions(this.offsetArrow, sizesAndPositions);
                break;
            case 'left-top':
                this.setLeftPositions((sizesAndPositions.element.height - this.offsetArrow), sizesAndPositions);
                break;
        }
        this.arrowDirection = this.setArrowDirection(position);
    }
    /**
     * @private
     * @return {?}
     */
    setElementWidth() {
        if (this.isSetElementWidth && this.targetElement) {
            this.element.style.width = `${this.targetElement.clientWidth}px`;
        }
    }
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    setLeftPositions(displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - displacement + (sizesAndPositions.target.height / 2) + 'px';
        this.element.style.left = sizesAndPositions.target.left - sizesAndPositions.element.width - this.elementOffset + 'px';
    }
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    setRightPositions(displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - displacement + (sizesAndPositions.target.height / 2) + 'px';
        this.element.style.left = sizesAndPositions.target.right + this.elementOffset + 'px';
    }
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    setTopPositions(displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left + (sizesAndPositions.target.width / 2) - displacement + 'px';
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    verifySubPositions(position) {
        if (position.indexOf('-') > -1) {
            position = position.substring(0, position.indexOf('-'));
            this.elementPosition(position);
        }
        /** @type {?} */
        let align = 0;
        while (align++ < 3) {
            if (this.overflowAllSides(position)) {
                position = this.nextPosition(position, thfControlPositionSidesDefault);
                this.elementPosition(position);
            }
            else {
                return null;
            }
        }
    }
}
ThfControlPositionService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Array de posições.
/** @type {?} */
const THF_CONTROL_POSITIONS = [
    'right',
    'right-top',
    'right-bottom',
    'top',
    'top-left',
    'top-right',
    'left',
    'left-top',
    'left-bottom',
    'bottom',
    'bottom-left',
    'bottom-right'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CONTENT_MAX_LENGTH = 140;
/** @type {?} */
const THF_TOOLTIP_POSITION_DEFAULT = 'bottom';
/**
 * \@description
 *
 * A diretiva thf-tooltip deve ser utilizada para oferecer informações adicionais quando os usuários
 * passam o mouse sobre o elemento alvo ao qual ela está atribuída.
 *
 * O conteúdo é formado por um pequeno texto que deve contribuir para uma tomada de decisão ou
 * orientação do usuário. A ativação dele pode estar em qualquer componente ou tag HTML.
 *
 * Para textos maiores ou no caso de haver a necessidade de utilizar algum outro elemento como
 * conteúdo deve-se utilizar o [**thf-popover**](https://thf.totvs.com.br/documentation/thf-popover?view=doc).
 */
class ThfTooltipBaseDirective {
    constructor() {
        this._tooltip = '';
        this._tooltipPosition = 'bottom';
    }
    /**
     * \@description
     *
     * Habilita e atribui um texto ao thf-tooltip, com limitação de 140 caracteres.
     * @param {?} tooltip
     * @return {?}
     */
    set tooltip(tooltip) {
        if (tooltip && tooltip.length > CONTENT_MAX_LENGTH) {
            this._tooltip = tooltip.substring(0, CONTENT_MAX_LENGTH);
        }
        else {
            this._tooltip = tooltip;
        }
    }
    /**
     * @return {?}
     */
    get tooltip() {
        return this._tooltip;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a posição que o thf-tooltip abrirá em relação ao componente alvo. Sugere-se que seja
     * usada a orientação "bottom" (abaixo), porém o mesmo é flexível e será rotacionado
     * automaticamente para se adequar a tela, caso necessário.
     *
     * Posições válidas:
     * - `right`: Posiciona o thf-tooltip no lado direito do componente alvo.
     * - `right-bottom`: Posiciona o thf-tooltip no lado direito inferior do componente alvo.
     * - `right-top`: Posiciona o thf-tooltip no lado direito superior do componente alvo.
     * - `bottom`: Posiciona o thf-tooltip abaixo do componente alvo.
     * - `bottom-left`: Posiciona o thf-tooltip abaixo e à esquerda do componente alvo.
     * - `bottom-right`: Posiciona o thf-tooltip abaixo e à direita do componente alvo.
     * - `left`: Posiciona o thf-tooltip no lado esquerdo do componente alvo.
     * - `left-top`: Posiciona o thf-tooltip no lado esquerdo superior do componente alvo.
     * - `left-bottom`: Posiciona o thf-tooltip no lado esquerdo inferior do componente alvo.
     * - `top`: Posiciona o thf-tooltip acima do componente alvo.
     * - `top-right`: Posiciona o thf-tooltip acima e à direita do componente alvo.
     * - `top-left`: Posiciona o thf-tooltip acima e à esquerda do componente alvo.
     *
     * \@default bottom
     * @param {?} position
     * @return {?}
     */
    set tooltipPosition(position) {
        this._tooltipPosition = THF_CONTROL_POSITIONS.includes(position) ? position : THF_TOOLTIP_POSITION_DEFAULT;
    }
    /**
     * @return {?}
     */
    get tooltipPosition() {
        return this._tooltipPosition;
    }
}
ThfTooltipBaseDirective.propDecorators = {
    tooltip: [{ type: Input, args: ['t-tooltip',] }],
    tooltipPosition: [{ type: Input, args: ['t-tooltip-position',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfTooltipBaseDirective
 *
 * \@example
 *
 * <example name="thf-tooltip-basic" title="Totvs Tooltip Basic" >
 *  <file name="sample-thf-tooltip-basic/sample-thf-tooltip-basic.component.html"> </file>
 *  <file name="sample-thf-tooltip-basic/sample-thf-tooltip-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tooltip-labs" title="Totvs Tooltip Labs" >
 *  <file name="sample-thf-tooltip-labs/sample-thf-tooltip-labs.component.html"> </file>
 *  <file name="sample-thf-tooltip-labs/sample-thf-tooltip-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tooltip-new-user" title="Totvs Tooltip - New User" >
 *  <file name="sample-thf-tooltip-new-user/sample-thf-tooltip-new-user.component.html"> </file>
 *  <file name="sample-thf-tooltip-new-user/sample-thf-tooltip-new-user.component.ts"> </file>
 * </example>
 *
 */
class ThfTooltipDirective extends ThfTooltipBaseDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} thfControlPosition
     */
    constructor(elementRef, renderer, thfControlPosition) {
        super();
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.thfControlPosition = thfControlPosition;
        this.tooltipOffset = 8;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initScrollEventListenerFunction();
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.tooltip) {
                this.tooltipContent ? this.showTooltip() : this.createTooltip();
                this.removeArrow(this.arrowDirection);
                this.thfControlPosition.adjustPosition(this.tooltipPosition);
                this.arrowDirection = this.thfControlPosition.getArrowDirection();
                this.addArrow(this.arrowDirection);
                this.lastTooltipText = this.tooltip;
            }
        }));
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        this.hideTooltip();
    }
    /**
     * @private
     * @param {?} arrowDirection
     * @return {?}
     */
    addArrow(arrowDirection) {
        this.renderer.addClass(this.divArrow, `thf-arrow-${arrowDirection}`);
    }
    /**
     * @private
     * @return {?}
     */
    addScrollEventListener() {
        window.addEventListener('scroll', this.eventListenerFunction, true);
    }
    // Monta a estrutura do tooltip
    /**
     * @private
     * @return {?}
     */
    createTooltip() {
        this.tooltipContent = this.renderer.createElement('div');
        this.renderer.addClass(this.tooltipContent, 'thf-tooltip');
        this.divArrow = this.renderer.createElement('div');
        this.renderer.addClass(this.divArrow, 'thf-tooltip-arrow');
        this.divContent = this.renderer.createElement('div');
        this.renderer.addClass(this.divContent, 'thf-tooltip-content');
        this.textContent = this.renderer.createText(this.tooltip);
        this.renderer.appendChild(this.divContent, this.textContent);
        this.renderer.appendChild(this.tooltipContent, this.divArrow);
        this.renderer.appendChild(this.tooltipContent, this.divContent);
        this.renderer.appendChild(this.elementRef.nativeElement, this.tooltipContent);
        this.thfControlPosition.setElements(this.tooltipContent, this.tooltipOffset, this.elementRef);
        this.addScrollEventListener();
    }
    /**
     * @private
     * @return {?}
     */
    initScrollEventListenerFunction() {
        this.eventListenerFunction = (/**
         * @return {?}
         */
        () => {
            if (!this.isHidden) {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.thfControlPosition.adjustPosition(this.tooltipPosition);
                }));
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    hideTooltip() {
        if (this.tooltipContent) {
            this.renderer.addClass(this.tooltipContent, 'thf-invisible');
            this.isHidden = true;
            this.removeScrollEventListener();
        }
    }
    /**
     * @private
     * @param {?} arrowDirection
     * @return {?}
     */
    removeArrow(arrowDirection) {
        if (this.elementRef.nativeElement.querySelector(`.thf-arrow-${arrowDirection}`)) {
            this.renderer.removeClass(this.divArrow, `thf-arrow-${arrowDirection}`);
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeScrollEventListener() {
        window.removeEventListener('scroll', this.eventListenerFunction, true);
    }
    /**
     * @private
     * @return {?}
     */
    showTooltip() {
        this.renderer.removeClass(this.tooltipContent, 'thf-invisible');
        this.updateTextContent();
        this.isHidden = false;
        this.addScrollEventListener();
    }
    /**
     * @private
     * @return {?}
     */
    updateTextContent() {
        if (this.lastTooltipText !== this.tooltip) {
            this.renderer.removeChild(this.divContent, this.textContent);
            this.textContent = this.renderer.createText(this.tooltip);
            this.renderer.appendChild(this.divContent, this.textContent);
        }
    }
}
ThfTooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: '[t-tooltip]',
                providers: [ThfControlPositionService]
            },] }
];
/** @nocollapse */
ThfTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ThfControlPositionService }
];
ThfTooltipDirective.propDecorators = {
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo da diretiva Thf-Tooltip.
 */
class ThfTooltipModule {
}
ThfTooltipModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [ThfTooltipDirective],
                exports: [ThfTooltipDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfButtonGroupToggle = {
    /** Seleção múltipla. */
    Multiple: 'multiple',
    /** Seleção desabilitada. */
    None: 'none',
    /** Seleção única. */
    Single: 'single',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_TOGGLE_TYPE_DEFAULT = 'none';
/**
 * \@description
 *
 * O componente `thf-button-group` é formado por um conjunto de botões distribuídos horizontalmente.
 * Cada botão do grupo é tratado de forma individual, recebendo assim um rótulo, uma ação bem como se deverá estar habilitado ou não.
 *
 * Este componente além de servir como um agrupador de botões para ação, também permite que sejam utilizados
 * para seleções multiplas e únicas.
 *
 * O grupo de botões deve ser utilizado para organizar as ações de maneira uniforme e transmitir a ideia de que os botões fazem
 * parte de um mesmo contexto.
 *
 * #### Boas práticas
 *
 * - Evite usar o `thf-button-group` com apenas 1 ação, para isso utilize o `thf-button`.
 * - Procure utilizar no máximo 3 ações para cada `thf-button-group`.
 *
 * > As recomendações do `thf-button` também valem para o `thf-button-group`.
 */
class ThfButtonGroupBaseComponent {
    constructor() {
        this._small = false;
        this._toggle = THF_TOGGLE_TYPE_DEFAULT;
        /**
         * Lista de botões.
         */
        this.buttons = [];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Torna o grupo de botões com tamanho minificado.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set small(value) {
        this._small = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get small() {
        return this._small;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define o modo de seleção de botões.
     *
     * > Veja os valores válidos no *enum* `ThfMultiselectFilterMode`.
     *
     * \@default `none`
     * @param {?} value
     * @return {?}
     */
    set toggle(value) {
        this._toggle = ((/** @type {?} */ (Object))).values(ThfButtonGroupToggle).includes(value) ? value : THF_TOGGLE_TYPE_DEFAULT;
        this.checkSelecteds(this._toggle);
    }
    /**
     * @return {?}
     */
    get toggle() {
        return this._toggle;
    }
    /**
     * @param {?} buttonClicked
     * @param {?} buttonIndex
     * @return {?}
     */
    onButtonClick(buttonClicked, buttonIndex) {
        if (this.toggle === ThfButtonGroupToggle.Single) {
            this.buttons.forEach((/**
             * @param {?} button
             * @param {?} index
             * @return {?}
             */
            (button, index) => button.selected = index === buttonIndex ? !buttonClicked.selected : false));
        }
        else if (this.toggle === ThfButtonGroupToggle.Multiple) {
            buttonClicked.selected = !buttonClicked.selected;
        }
    }
    /**
     * @private
     * @param {?} toggleMode
     * @return {?}
     */
    checkSelecteds(toggleMode) {
        if (toggleMode === ThfButtonGroupToggle.None) {
            this.deselectAllButtons();
        }
        else if (toggleMode === ThfButtonGroupToggle.Single) {
            /** @type {?} */
            const hasMoreOneSelected = this.buttons.filter((/**
             * @param {?} button
             * @return {?}
             */
            button => button.selected)).length > 1;
            if (hasMoreOneSelected) {
                this.deselectAllButtons();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    deselectAllButtons() {
        this.buttons.forEach((/**
         * @param {?} button
         * @return {?}
         */
        button => button.selected = false));
    }
}
ThfButtonGroupBaseComponent.propDecorators = {
    buttons: [{ type: Input, args: ['t-buttons',] }],
    small: [{ type: Input, args: ['t-small',] }],
    toggle: [{ type: Input, args: ['t-toggle',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfButtonGroupBaseComponent
 *
 * \@example
 *
 * <example name="thf-button-group-basic" title="Totvs Button Group Basic">
 *  <file name="sample-thf-button-group-basic/sample-thf-button-group-basic.component.html"> </file>
 *  <file name="sample-thf-button-group-basic/sample-thf-button-group-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-button-group-labs" title="Totvs Button Group Labs">
 *  <file name="sample-thf-button-group-labs/sample-thf-button-group-labs.component.html"> </file>
 *  <file name="sample-thf-button-group-labs/sample-thf-button-group-labs.component.ts"> </file>
 * </example>
 *
 *
 * <example name="thf-button-group-attendance" title="Totvs Button Group - Attendance">
 *  <file name="sample-thf-button-group-attendance/sample-thf-button-group-attendance.component.html"> </file>
 *  <file name="sample-thf-button-group-attendance/sample-thf-button-group-attendance.component.ts"> </file>
 * </example>
 *
 * <example name="thf-button-group-post" title="Totvs Button Group - Post">
 *  <file name="sample-thf-button-group-post/sample-thf-button-group-post.component.html"> </file>
 *  <file name="sample-thf-button-group-post/sample-thf-button-group-post.component.ts"> </file>
 * </example>
 */
class ThfButtonGroupComponent extends ThfButtonGroupBaseComponent {
    /**
     * @param {?} viewRef
     */
    constructor(viewRef) {
        super();
        // Get instance of parent to execute the actions
        this.parentRef = viewRef['_view']['component'];
    }
}
ThfButtonGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-button-group',
                template: "<div class=\"thf-button-group-container\">\n  <thf-button\n    *ngFor=\"let button of buttons; index as i\"\n    class=\"thf-sm-12 thf-button-group\"\n    [class.thf-button-group-button-selected]=\"button.selected\"\n    [class.thf-button-group-disabled]=\"button.disabled\"\n    t-tooltip-position=\"bottom\"\n    [t-disabled]=\"button.disabled\"\n    [t-icon]=\"button.icon\"\n    [t-label]=\"button.label\"\n    [t-small]=\"small\"\n    [t-tooltip]=\"!button.disabled ? button.tooltip : undefined\"\n    (t-click)=\"button.action.call(parentRef, button); onButtonClick(button, i)\">\n  </thf-button>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfButtonGroupComponent.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-button-group.
 */
class ThfButtonGroupModule {
}
ThfButtonGroupModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfButtonModule,
                    ThfTooltipModule
                ],
                declarations: [
                    ThfButtonGroupComponent
                ],
                exports: [
                    ThfButtonGroupComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfCalendarLocales = ['pt', 'en', 'es'];
/** @type {?} */
const thfCalendarLocaleDefault = 'pt';
/**
 * \@description
 *
 * O `thf-calendar` é um componente para seleção de datas. Ele permite uma fácil navegação clicando nas setas
 * de direcionamento e nos *labels* do ano ou mês.
 *
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * this.date = '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * this.date = '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * this.date = new Date(2017, 10, 28);
 * ```
 *
 * > Independentemente do formato utilizado, o componente trata o valor do *model* internamente com o
 * formato **Data (E8601DAw.): yyyy-mm-dd**.
 *
 * Importante:
 *
 * - Caso seja definida uma data fora do range da data mínima e data máxima via *ngModel* o componente mostrará
 * a data desabilitada porém o *model* não será alterado.
 * - Caso seja definida uma data inválida a mesma não será atribuída ao calendário porém o *model* manterá a data inválida.
 */
class ThfCalendarBaseComponent {
    /**
     * @param {?} thfDate
     * @param {?} thfCalendarLangService
     */
    constructor(thfDate, thfCalendarLangService) {
        this.thfDate = thfDate;
        this.thfCalendarLangService = thfCalendarLangService;
        this.dayVisible = false;
        this.displayMonths = Array();
        this.displayWeekDays = Array();
        this.monthVisible = false;
        this.yearVisible = false;
        this.onTouched = null;
        this.propagateChange = null;
        this.today = new Date();
        /**
         * Evento disparado ao selecionar um dia do calendário.
         */
        this.change = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Idioma do calendário.
     *
     * Valores válidos:
     *  - `pt`
     *  - `en`
     *  - `es`
     *
     * \@default `pt`
     * @param {?} locale
     * @return {?}
     */
    set locale(locale) {
        this._locale = thfCalendarLocales.includes(locale) ? locale : thfCalendarLocaleDefault;
        this.initializeLanguage();
    }
    /**
     * @return {?}
     */
    get locale() {
        return this._locale;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a data máxima possível de ser selecionada.
     *
     * Pode receber os seguintes formatos de data:
     *
     * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
     * ```
     * this.date = '2017-11-28T00:00:00-02:00';
     * ```
     *
     * - **Data (E8601DAw.): yyyy-mm-dd**
     * ```
     * this.date = '2017-11-28';
     * ```
     *
     * - **JavaScript Date Object:**
     * ```
     * this.date = new Date(2017, 10, 28);
     * ```
     * @param {?} maxDate
     * @return {?}
     */
    set maxDate(maxDate) {
        this._maxDate = this.thfDate.getDateForDateRange(maxDate, false);
    }
    /**
     * @return {?}
     */
    get maxDate() {
        return this._maxDate;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a data mínima possível de ser selecionada.
     *
     * Pode receber os seguintes formatos de data:
     *
     * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
     * ```
     * this.date = '2017-11-28T00:00:00-02:00';
     * ```
     *
     * - **Data (E8601DAw.): yyyy-mm-dd**
     * ```
     * this.date = '2017-11-28';
     * ```
     *
     * - **JavaScript Date Object:**
     * ```
     * this.date = new Date(2017, 10, 28);
     * ```
     * @param {?} minDate
     * @return {?}
     */
    set minDate(minDate) {
        this._minDate = this.thfDate.getDateForDateRange(minDate, true);
    }
    /**
     * @return {?}
     */
    get minDate() {
        return this._minDate;
    }
    /**
     * @return {?}
     */
    initializeLanguage() {
        this.thfCalendarLangService.setLanguage(this.locale);
        this.displayWeekDays = this.thfCalendarLangService.getWeekDaysArray();
        this.displayMonths = this.thfCalendarLangService.getMonthsArray();
        this.displayMonth = this.displayMonths[this.displayMonthNumber];
    }
}
ThfCalendarBaseComponent.propDecorators = {
    locale: [{ type: Input, args: ['t-locale',] }],
    maxDate: [{ type: Input, args: ['t-max-date',] }],
    minDate: [{ type: Input, args: ['t-min-date',] }],
    change: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfCalendarLangService {
    constructor() {
        this.language = 'pt';
        this.months = [
            {
                pt: 'Janeiro',
                en: 'January',
                es: 'Enero'
            },
            {
                pt: 'Fevereiro',
                en: 'February',
                es: 'Febrero'
            },
            {
                pt: 'Março',
                en: 'March',
                es: 'Marzo'
            },
            {
                pt: 'Abril',
                en: 'April',
                es: 'Abril'
            },
            {
                pt: 'Maio',
                en: 'May',
                es: 'Mayo'
            },
            {
                pt: 'Junho',
                en: 'June',
                es: 'Junio'
            },
            {
                pt: 'Julho',
                en: 'July',
                es: 'Julio'
            },
            {
                pt: 'Agosto',
                en: 'August',
                es: 'Agosto'
            },
            {
                pt: 'Setembro',
                en: 'September',
                es: 'Setiembre'
            },
            {
                pt: 'Outubro',
                en: 'October',
                es: 'Octubre'
            },
            {
                pt: 'Novembro',
                en: 'November',
                es: 'Noviembre'
            },
            {
                pt: 'Dezembro',
                en: 'December',
                es: 'Diciembre'
            }
        ];
        this.shortWeekDays = [
            {
                pt: 'Dom',
                en: 'Sun',
                es: 'Dom'
            },
            {
                pt: 'Seg',
                en: 'Mon',
                es: 'Lun'
            },
            {
                pt: 'Ter',
                en: 'Tue',
                es: 'Mar'
            },
            {
                pt: 'Qua',
                en: 'Wed',
                es: 'Mié'
            },
            {
                pt: 'Qui',
                en: 'Thu',
                es: 'Jue'
            },
            {
                pt: 'Sex',
                en: 'Fri',
                es: 'Vie'
            },
            {
                pt: 'Sáb',
                en: 'Sat',
                es: 'Sáb'
            }
        ];
        this.monthLabel = {
            pt: 'Mês',
            en: 'Month',
            es: 'Mes'
        };
        this.yearLabel = {
            pt: 'Ano',
            en: 'Year',
            es: 'Año'
        };
    }
    /**
     * @param {?} month
     * @return {?}
     */
    getMonth(month) {
        return this.months[month][this.language];
    }
    /**
     * @return {?}
     */
    getMonthLabel() {
        return this.monthLabel[this.language];
    }
    /**
     * @return {?}
     */
    getMonthsArray() {
        /** @type {?} */
        const arrMonths = Array();
        for (let i = 0; i < this.months.length; i++) {
            arrMonths.push(this.months[i][this.language]);
        }
        return arrMonths;
    }
    /**
     * @param {?} day
     * @return {?}
     */
    getWeekDays(day) {
        return this.shortWeekDays[day][this.language];
    }
    /**
     * @return {?}
     */
    getWeekDaysArray() {
        /** @type {?} */
        const arrWeekDays = Array();
        for (let i = 0; i < this.shortWeekDays.length; i++) {
            arrWeekDays.push(this.shortWeekDays[i][this.language]);
        }
        return arrWeekDays;
    }
    /**
     * @return {?}
     */
    getYearLabel() {
        return this.yearLabel[this.language];
    }
    /**
     * @param {?} language
     * @return {?}
     */
    setLanguage(language) {
        if (language && language.length >= 2) {
            language = language.toLowerCase().slice(0, 2);
            this.language = (language === 'pt' || language === 'en' || language === 'es') ? language : 'pt';
        }
    }
}
ThfCalendarLangService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfCalendarServiceFirstWeekDayDefault = 0;
class ThfCalendarService {
    /**
     * @param {?} year
     * @param {?} month
     * @param {?=} dayFormatter
     * @param {?=} weekFormatter
     * @return {?}
     */
    monthDates(year, month, dayFormatter = null, weekFormatter = null) {
        if ((typeof month !== 'number') || (month < 0) || (month > 11)) {
            throw Error(('month must be a number (Jan is 0)'));
        }
        /** @type {?} */
        const weeks = [];
        /** @type {?} */
        let week = [];
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let date = new Date(year, month, 1);
        if (year >= 0 && year < 100) {
            date.setFullYear(year);
        }
        date = this.weekStartDate(date);
        do {
            for (i = 0; i < 7; i++) {
                week.push(dayFormatter ? dayFormatter(date) : date);
                date = new Date(date.getTime());
                date.setDate(date.getDate() + 1);
            }
            weeks.push(weekFormatter ? weekFormatter(week) : week);
            week = [];
        } while ((date.getMonth() <= month) && (date.getFullYear() === year));
        return weeks;
    }
    /**
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    monthDays(year, month) {
        /** @type {?} */
        const getDayOrZero = (/**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            return date.getMonth() === month ? date : 0;
        });
        return this.monthDates(year, month, getDayOrZero);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    weekStartDate(date) {
        /** @type {?} */
        const startDate = new Date(date.getTime());
        while (startDate.getDay() !== thfCalendarServiceFirstWeekDayDefault) {
            startDate.setDate(startDate.getDate() - 1);
        }
        return startDate;
    }
}
ThfCalendarService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
class ThfDateService {
    constructor() {
        this.dateRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])$');
        this.isoRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])' +
            'T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|' +
            '-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])' +
            '(?:|:?[0-5]\\d)$');
    }
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param {?} dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} minDate Definir `true` caso seja `minDate`.
     * @param {?} maxDate Definir `true` caso seja `maxDate`.
     * @return {?}
     */
    convertIsoToDate(dateString, minDate, maxDate) {
        if (dateString) {
            const { year, month, day } = this.getDateFromIso(dateString);
            if (minDate) {
                /** @type {?} */
                const date = new Date(year, month - 1, day, 0, 0, 0);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else if (maxDate) {
                /** @type {?} */
                const date = new Date(year, month - 1, day, 23, 59, 59);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else {
                /** @type {?} */
                const miliseconds = Date.parse(dateString);
                /** @type {?} */
                const timezone = new Date().getTimezoneOffset() * 60000;
                return new Date(miliseconds + timezone);
            }
        }
    }
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param {?} date Data no formato `Date`.
     * @return {?}
     */
    convertDateToISO(date) {
        if (date) {
            /** @type {?} */
            const fullYear = date.getFullYear();
            /** @type {?} */
            const getMonth = date.getMonth() + 1;
            /** @type {?} */
            const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
            /** @type {?} */
            const month = getMonth < 10 ? '0' + getMonth : getMonth;
            /** @type {?} */
            const year = this.formatYear(fullYear);
            return year + '-' + month + '-' + day;
        }
        else {
            return null;
        }
    }
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param {?} year Ano a ser validado.
     * @return {?}
     */
    formatYear(year) {
        if (year > 999) {
            return year.toString();
        }
        if (year > 99 && year < 1000) {
            return `0${year}`;
        }
        if (year > 9 && year < 100) {
            return `00${year}`;
        }
        if (year >= 0 && year < 10) {
            return `000${year}`;
        }
    }
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param {?} isoDate Ano em formato string.
     * @return {?}
     */
    getDateFromIso(isoDate) {
        /** @type {?} */
        const day = parseInt(isoDate.substring(8, 10), 10);
        /** @type {?} */
        const month = parseInt(isoDate.substring(5, 7), 10);
        /** @type {?} */
        const year = parseInt(isoDate.substring(0, 4), 10);
        return { year, month, day };
    }
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param {?} date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     * @return {?}
     */
    getDateForDateRange(date, isMinDate) {
        /** @type {?} */
        const lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
        if (date instanceof Date) {
            const { year, month, day } = this.splitDate(date);
            /** @type {?} */
            const validDate = new Date(year, month, day, ...lastHour);
            this.setYearFrom0To100(validDate, year);
            return validDate;
        }
        else if (this.isValidIso(date)) {
            return this.convertIsoToDate(date, isMinDate, !isMinDate);
        }
    }
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param {?=} dateA primeira data
     * @param {?=} dateB segunda data
     * @return {?}
     */
    isDateRangeValid(dateA = '', dateB = '') {
        /** @type {?} */
        const dateASplitted = dateA.split('-').map((/**
         * @param {?} item
         * @return {?}
         */
        item => parseInt(item, 10)));
        /** @type {?} */
        const dateBSplitted = dateB.split('-').map((/**
         * @param {?} item
         * @return {?}
         */
        item => parseInt(item, 10)));
        for (let index = 0; index <= dateASplitted.length; index++) {
            if (dateASplitted[index] > dateBSplitted[index]) {
                return true;
            }
            else if (dateASplitted[index] < dateBSplitted[index]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param {?} stringDate Data.
     * @return {?}
     */
    isValidIso(stringDate) {
        return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
    }
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param {?} date Data.
     * @param {?} year .
     * @return {?}
     */
    setYearFrom0To100(date, year) {
        if (year >= 0 && year < 100) {
            date.setFullYear(year);
        }
    }
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param {?} leftSide Primeira data a ser comparada.
     * @param {?} rightSide Segunda data a ser comparada.
     * @param {?} ascending Determina se será em ordem crescente ou decrescente.
     * @return {?}
     */
    sortDate(leftSide, rightSide, ascending) {
        return sortValues(this.validateDate(leftSide), this.validateDate(rightSide), ascending);
    }
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param {?} date Valor da data.
     * @return {?}
     */
    splitDate(date) {
        /** @type {?} */
        const year = date.getFullYear();
        /** @type {?} */
        const month = date.getMonth();
        /** @type {?} */
        const day = date.getDate();
        return { year, month, day };
    }
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param {?} date Data a ser validada.
     * @param {?} minDate Data inicial.
     * @param {?} maxDate Data final.
     * @return {?}
     */
    validateDateRange(date, minDate, maxDate) {
        if (minDate && maxDate) {
            return (date >= minDate && date <= maxDate);
        }
        else if (minDate && !maxDate) {
            return (date >= minDate);
        }
        else if (!minDate && maxDate) {
            return (date <= maxDate);
        }
        else {
            return true;
        }
    }
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @private
     * @param {?} date Data que será validada.
     * @return {?}
     */
    validateDate(date) {
        /** @type {?} */
        const validDate = date instanceof Date ? this.convertDateToISO(date) : date;
        return this.isValidIso(validDate) ? validDate : undefined;
    }
}
ThfDateService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfCalendarBaseComponent
 *
 * \@example
 *
 * <example name="thf-calendar-basic" title="Totvs Calendar Basic" >
 *  <file name="sample-thf-calendar-basic/sample-thf-calendar-basic.component.html"> </file>
 *  <file name="sample-thf-calendar-basic/sample-thf-calendar-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-calendar-labs" title="Totvs Calendar Labs" >
 *  <file name="sample-thf-calendar-labs/sample-thf-calendar-labs.component.html"> </file>
 *  <file name="sample-thf-calendar-labs/sample-thf-calendar-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-calendar-ticket-sales" title="Totvs Calendar - Ticket Sales" >
 *  <file name="sample-thf-calendar-ticket-sales/sample-thf-calendar-ticket-sales.component.html"> </file>
 *  <file name="sample-thf-calendar-ticket-sales/sample-thf-calendar-ticket-sales.component.ts"> </file>
 * </example>
 */
class ThfCalendarComponent extends ThfCalendarBaseComponent {
    /**
     * @param {?} thfCalendarService
     * @param {?} thfCalendarLangService
     * @param {?} thfDate
     */
    constructor(thfCalendarService, thfCalendarLangService, thfDate) {
        super(thfDate, thfCalendarLangService);
        this.thfCalendarService = thfCalendarService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
    }
    /**
     * @param {?} displayValue
     * @param {?} propertyValue
     * @return {?}
     */
    getBackgroundColor(displayValue, propertyValue) {
        return (displayValue === propertyValue) ? 'thf-calendar-box-background-selected' : 'thf-calendar-box-background';
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayBackgroundColor(date) {
        return this.getDayColor(date, 'background');
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayForegroundColor(date) {
        return this.getDayColor(date, 'foreground');
    }
    /**
     * @param {?} displayValue
     * @param {?} propertyValue
     * @return {?}
     */
    getForegroundColor(displayValue, propertyValue) {
        return (displayValue === propertyValue) ? 'thf-calendar-box-foreground-selected' : 'thf-calendar-box-foreground';
    }
    /**
     * @return {?}
     */
    getMonthLabel() {
        return this.thfCalendarLangService.getMonthLabel();
    }
    /**
     * @return {?}
     */
    getYearLabel() {
        return this.thfCalendarLangService.getYearLabel();
    }
    /**
     * @return {?}
     */
    onNextMonth() {
        this.displayMonthNumber < 11 ? this.updateDisplay(this.displayYear, this.displayMonthNumber + 1) :
            this.updateDisplay(this.displayYear + 1, 0);
    }
    /**
     * @return {?}
     */
    onPreviousMonth() {
        this.displayMonthNumber > 0 ? this.updateDisplay(this.displayYear, this.displayMonthNumber - 1) :
            this.updateDisplay(this.displayYear - 1, 11);
    }
    // Ao selecionar uma data
    /**
     * @param {?} date
     * @return {?}
     */
    onSelectDate(date) {
        this.date = date;
        this.dateIso = this.thfDate.convertDateToISO(date);
        if (this.propagateChange) {
            this.propagateChange(this.dateIso);
        }
        this.change.emit(this.dateIso);
    }
    // Ao selecionar um mês
    /**
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    onSelectMonth(year, month) {
        this.selectDay();
        this.updateDisplay(year, month);
    }
    // Ao selecionar um ano
    /**
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    onSelectYear(year, month) {
        // Se veio da tela de seleção de mês
        this.lastDisplay === 'month' ? this.selectMonth() : this.selectDay();
        this.currentYear = year;
        this.updateDisplay(year, month);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouched = func;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @return {?}
     */
    selectDay() {
        this.dayVisible = true;
        this.monthVisible = false;
        this.yearVisible = false;
        this.lastDisplay = 'day';
    }
    /**
     * @return {?}
     */
    selectMonth() {
        this.dayVisible = false;
        this.monthVisible = true;
        this.yearVisible = false;
        this.lastDisplay = 'month';
    }
    /**
     * @return {?}
     */
    selectYear() {
        this.dayVisible = false;
        this.monthVisible = false;
        this.yearVisible = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateYear(value) {
        this.updateDisplay(this.displayYear + value, this.displayMonthNumber);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    validateModel(model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.writeDate(value);
        }
        else {
            this.date = undefined;
            this.updateDate(this.today);
        }
    }
    /**
     * @private
     * @param {?} year
     * @return {?}
     */
    addAllYearsInDecade(year) {
        /** @type {?} */
        let i;
        for (i = year; i < year + 10; i++) {
            this.displayDecade.push(i);
        }
    }
    /**
     * @private
     * @param {?} date1
     * @param {?} date2
     * @return {?}
     */
    equalsDate(date1, date2) {
        try {
            return date1.getFullYear() === date2.getFullYear() &&
                date1.getMonth() === date2.getMonth() &&
                date1.getDate() === date2.getDate();
        }
        catch (error) {
            return false;
        }
    }
    // Obtém um array de todos os anos desta década
    /**
     * @private
     * @param {?} year
     * @return {?}
     */
    getDecadeArray(year) {
        this.displayDecade = Array();
        if (year % 10 !== 0) {
            while (year % 10 !== 0) {
                year--;
            }
        }
        this.updateDecade(year);
    }
    /**
     * @private
     * @param {?} date
     * @param {?} local
     * @return {?}
     */
    getColorForDate(date, local) {
        return this.thfDate.validateDateRange(date, this.minDate, this.maxDate) ? `thf-calendar-box-${local}-selected` :
            `thf-calendar-box-${local}-selected-disabled`;
    }
    /**
     * @private
     * @param {?} date
     * @param {?} local
     * @return {?}
     */
    getColorForDateRange(date, local) {
        return this.thfDate.validateDateRange(date, this.minDate, this.maxDate) ? `thf-calendar-box-${local}` :
            `thf-calendar-box-${local}-disabled`;
    }
    /**
     * @private
     * @param {?} date
     * @param {?} local
     * @return {?}
     */
    getColorForToday(date, local) {
        return this.thfDate.validateDateRange(date, this.minDate, this.maxDate) ? `thf-calendar-box-${local}-today` :
            `thf-calendar-box-${local}-today-disabled`;
    }
    /**
     * @private
     * @param {?} date
     * @param {?} local
     * @return {?}
     */
    getDayColor(date, local) {
        if (this.equalsDate(date, this.date)) {
            return this.getColorForDate(date, local);
        }
        else if (this.equalsDate(date, this.today)) {
            return this.getColorForToday(date, local);
        }
        else {
            return this.getColorForDateRange(date, local);
        }
    }
    /**
     * @private
     * @return {?}
     */
    init() {
        this.date && this.thfDate.isValidIso(this.thfDate.convertDateToISO(this.date)) ?
            this.updateDate(this.date) : this.updateDate(this.today);
        this.initializeLanguage();
        this.selectDay();
    }
    /**
     * @private
     * @param {?} date
     * @return {?}
     */
    selectDateFromDate(date) {
        this.date = date;
        this.onSelectDate(this.date);
    }
    /**
     * @private
     * @param {?} stringDate
     * @return {?}
     */
    selectDateFromIso(stringDate) {
        const { year, month, day } = this.thfDate.getDateFromIso(stringDate);
        /** @type {?} */
        const date = new Date(year, month - 1, day);
        this.thfDate.setYearFrom0To100(date, year);
        this.date = date;
        this.onSelectDate(this.date);
    }
    /**
     * @private
     * @param {?} date
     * @return {?}
     */
    updateDate(date) {
        if (date) {
            this.currentMonthNumber = date.getMonth();
            this.currentYear = date.getFullYear();
            this.updateDisplay(this.currentYear, this.currentMonthNumber);
        }
    }
    /**
     * @private
     * @param {?} year
     * @return {?}
     */
    updateDecade(year) {
        this.addAllYearsInDecade(year);
        this.displayStartDecade = year;
        this.displayFinalDecade = year + 9;
    }
    /**
     * @private
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    updateDisplay(year, month) {
        /** @type {?} */
        const calendarArray = this.thfCalendarService.monthDays(year, month);
        this.displayDays = [].concat.apply([], calendarArray);
        this.displayMonthNumber = month;
        this.displayMonth = this.displayMonths[month];
        this.displayYear = year;
        this.getDecadeArray(year);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    writeDate(value) {
        value instanceof Date ? this.selectDateFromDate(value) : this.writeDateIso(value);
        this.updateDate(this.date);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    writeDateIso(value) {
        this.thfDate.isValidIso(value) ? this.selectDateFromIso(value) : this.date = undefined;
    }
}
ThfCalendarComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-calendar',
                template: "<div class=\"thf-calendar\">\n  <div *ngIf=\"dayVisible\">\n    <div class=\"thf-calendar-nav\">\n      <span class=\"thf-calendar-nav-left thf-icon thf-icon-arrow-left\" (click)=\"onPreviousMonth()\"></span>\n      <div class=\"thf-calendar-nav-title\" attr-calendar>\n        <span class=\"thf-clickable thf-mr-1\" (click)=\"selectMonth()\">{{ displayMonth }}</span>\n        <span class=\"thf-clickable\" (click)=\"selectYear()\">{{ displayYear }}</span>\n      </div>\n      <span class=\"thf-calendar-nav-right thf-icon thf-icon-arrow-right\" (click)=\"onNextMonth()\"></span>\n    </div>\n    <div class=\"thf-calendar-content\">\n      <div class=\"thf-calendar-labels\">\n        <div class=\"thf-calendar-label\" *ngFor=\"let day of displayWeekDays\">\n            {{ day.toLowerCase() }}\n        </div>\n      </div>\n      <div class=\"thf-calendar-content-list-day\">\n        <div *ngFor=\"let day of displayDays\"\n          class=\"thf-calendar-day\"\n          [ngClass]=\"getDayBackgroundColor(day)\"\n          (click)=\"onSelectDate(day)\">\n          <span *ngIf=\"day != 0\" [ngClass]=\"getDayForegroundColor(day)\">\n            {{ day.getDate() }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"monthVisible\">\n    <div class=\"thf-calendar-nav\">\n      <span class=\"thf-calendar-nav-left thf-icon thf-icon-arrow-left\" (click)=\"updateYear(-1)\"></span>\n      <div class=\"thf-calendar-nav-title\" attr-calendar>\n        <span class=\"thf-clickable\" (click)=\"selectYear()\">{{ displayYear }}</span>\n      </div>\n      <span class=\"thf-calendar-nav-right thf-icon thf-icon-arrow-right\" (click)=\"updateYear(1)\"></span>\n    </div>\n    <div class=\"thf-calendar-content\">\n      <div class=\"thf-calendar-labels\">\n        <div class=\"thf-calendar-label\">\n          {{ getMonthLabel() }}\n        </div>\n      </div>\n      <div class=\"thf-calendar-content-list-month\">\n        <div *ngFor=\"let month of displayMonths; let i = index;\" class=\"thf-calendar-month\"\n          [ngClass]=\"getBackgroundColor(i, displayMonthNumber)\"\n          (click)=\"onSelectMonth(displayYear, i)\" attr-calendar>\n          <span [ngClass]=\"getForegroundColor(i, displayMonthNumber)\">\n            {{ month }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"yearVisible\">\n    <div class=\"thf-calendar-nav\">\n      <span class=\"thf-calendar-nav-left thf-icon thf-icon-arrow-left\" (click)=\"updateYear(-10)\"></span>\n      <div class=\"thf-calendar-nav-title\">\n        {{ displayStartDecade }} - {{ displayFinalDecade }}\n      </div>\n      <span class=\"thf-calendar-nav-right thf-icon thf-icon-arrow-right\" (click)=\"updateYear(10)\"></span>\n    </div>\n    <div class=\"thf-calendar-content\">\n      <div class=\"thf-calendar-labels\">\n        <div class=\"thf-calendar-label\">\n          {{ getYearLabel() }}\n        </div>\n      </div>\n      <div class=\"thf-calendar-content-list-year\">\n        <div *ngFor=\"let year of displayDecade; let i = index;\" class=\"thf-calendar-year\"\n          [ngClass]=\"getBackgroundColor(year, currentYear)\"\n          (click)=\"onSelectYear(year, displayMonthNumber)\"attr-calendar>\n          <span [ngClass]=\"getForegroundColor(year, currentYear)\">\n            {{ year }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n",
                providers: [
                    ThfCalendarService,
                    ThfCalendarLangService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfCalendarComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfCalendarComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfCalendarComponent.ctorParameters = () => [
    { type: ThfCalendarService },
    { type: ThfCalendarLangService },
    { type: ThfDateService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente `thf-calendar`.
 */
class ThfCalendarModule {
}
ThfCalendarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [ThfCalendarComponent],
                exports: [ThfCalendarComponent],
                providers: [
                    ThfCalendarLangService,
                    ThfCalendarService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfChartType = {
    /**
     * **Gráfico pizza:** utilizado para exibir proporções de valores a partir de um todo.
     */
    Pie: 'pie',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfChartDefaultHeight = 400;
/** @type {?} */
const thfChartTypeDefault = ThfChartType.Pie;
/** @type {?} */
const thfChartMinHeight = 200;
/**
 * \@description
 *
 * O `thf-chart` é um componente para renderização de dados através de gráficos, com isso facilitando a compreensão e tornando a
 * visualização destes dados mais agradável.
 *
 * Este componente também possibilita a definição das seguintes propriedades: altura do gráfico; série(s) que irão compor o gráfico;
 * título do gráfico; e tipo de gráfico.
 *
 * Além das definições de propriedades, também é possível definir uma ação que será executada ao clicar em determinado elemento do gráfico
 * e outra que será executada ao passar o *mouse* sobre o elemento.
 *
 * #### Boas práticas
 *
 * - Para que o gráfico não fique ilegível e incompreensível, evite uma quantia excessiva de séries.
 *
 * @abstract
 */
class ThfChartBaseComponent {
    constructor() {
        this._height = thfChartDefaultHeight;
        this._type = thfChartTypeDefault;
        this.thfChartType = ThfChartType;
        /**
         * Evento executado quando o usuário clicar sobre um elemento do gráfico.
         *
         * > Será passado por parâmetro um objeto contendo a categoria e valor da série.
         */
        this.seriesClick = new EventEmitter();
        /**
         * Evento executado quando o usuário passar o *mouse* sobre um elemento do gráfico.
         *
         * > Será passado por parâmetro um objeto contendo a categoria e valor da série.
         */
        this.seriesHover = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a altura do gráfico.
     *
     * > O valor mínimo que pode ser informado é 200.
     *
     * \@default `400px`
     * @param {?} value
     * @return {?}
     */
    set height(value) {
        /** @type {?} */
        const intValue = convertToInt(value);
        /** @type {?} */
        let height;
        if (isTypeof(value, 'number')) {
            height = intValue <= thfChartMinHeight ? thfChartMinHeight : intValue;
        }
        else {
            height = thfChartDefaultHeight;
        }
        this._height = height;
        this.rebuildComponent();
    }
    /**
     * @return {?}
     */
    get height() {
        return this._height;
    }
    // TODO quando houver a necessidade de informar um type.
    // /**
    //  * @optional
    //  *
    //  * @description
    //  *
    //  * Define o tipo de gráfico.
    //  *
    //  * > Veja os valores válidos no *enum* `ThfChartType`.
    //  *
    //  * @default `ThfChartType.Pie`
    //  */
    // @Input('t-type') set type(value: ThfChartType) {
    //   this._type = (<any>Object).values(ThfChartType).includes(value) ? value : thfChartTypeDefault;
    // }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSeriesClick(event) {
        this.seriesClick.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSeriesHover(event) {
        this.seriesHover.emit(event);
    }
}
ThfChartBaseComponent.propDecorators = {
    height: [{ type: Input, args: ['t-height',] }],
    series: [{ type: Input, args: ['t-series',] }],
    title: [{ type: Input, args: ['t-title',] }],
    seriesClick: [{ type: Output, args: ['t-series-click',] }],
    seriesHover: [{ type: Output, args: ['t-series-hover',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Array de cores para gráficos definido pela equipe de UX Totvs.
/** @type {?} */
const ThfChartColors = [
    ['#29B6C5'],
    ['#0C6C94', '#29B6C5'],
    ['#0C6C94', '#29B6C5', '#C9ECF0'],
    ['#0C6C94', '#0B92B4', '#29B6C5', '#94DAE2'],
    ['#0C6C94', '#0B92B4', '#29B6C5', '#94DAE2', '#C9ECF0'],
    ['#0C6C94', '#00A5C5', '#0082A8', '#31628D', '#364473', '#32285C'],
    ['#0C6C94', '#00AACB', '#018DAE', '#277099', '#325783', '#35426E', '#32285D'],
    ['#0C6C94', '#00AFCE', '#0194B6', '#117FA2', '#0088AC', '#23789F', '#2B6992', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#364E7C', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#364E7C', '#36436F', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#364E7C', '#36436F', '#333565', '#32285C'],
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfChartAnimationDurationTime = 1500;
/** @type {?} */
const thfChartAngleStepInterval = Math.PI * 2 / Math.floor(thfChartAnimationDurationTime / 60);
/** @type {?} */
const thfChartCompleteCircle = 0.0001;
/** @type {?} */
const thfChartPadding = 24;
/** @type {?} */
const thfChartStartAngle = -Math.PI / 2;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Padding = 24;
/**
 * @abstract
 */
class ThfChartDynamicTypeComponent {
    constructor() {
        this.onSerieClick = new Subject();
        this.onSerieHover = new Subject();
        this.series = [];
    }
    /**
     * @param {?} chartWrapperElement
     * @param {?} chartHeaderElement
     * @param {?} chartLegendElement
     * @return {?}
     */
    calculateSVGContainerDimensions(chartWrapperElement, chartHeaderElement, chartLegendElement) {
        /** @type {?} */
        const svgContainerHeightCalc = this.height - chartHeaderElement - chartLegendElement - (Padding * 2);
        this.svgHeight = svgContainerHeightCalc <= 0 ? 0 : svgContainerHeightCalc;
        this.centerX = chartWrapperElement / 2;
    }
    /**
     * @return {?}
     */
    calculateTotalValue() {
        this.totalValue = this.series.reduce((/**
         * @param {?} previousValue
         * @param {?} serie
         * @return {?}
         */
        (previousValue, serie) => previousValue + serie.value), 0);
    }
}
ThfChartDynamicTypeComponent.propDecorators = {
    chartBody: [{ type: ViewChild, args: ['chartBody', { static: true },] }],
    svgContainer: [{ type: ViewChild, args: ['svgContainer', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfChartPieComponent extends ThfChartDynamicTypeComponent {
    /**
     * @param {?} el
     * @param {?} ngZone
     * @param {?} renderer
     */
    constructor(el, ngZone, renderer) {
        super();
        this.el = el;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.chartItemsEndAngleList = [];
        this.svgPathElementsList = [];
    }
    /**
     * @private
     * @param {?} value
     * @param {?} totalValue
     * @return {?}
     */
    static calculateEndAngle(value, totalValue) {
        return value / totalValue * (Math.PI * 2);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeWindowResizeListener();
        this.removeWindowScrollListener();
        this.animationRunning = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.chartInitSetup();
        this.setEventListeners();
    }
    /**
     * @private
     * @return {?}
     */
    animationSetup() {
        this.chartItemStartAngle = thfChartStartAngle;
        this.chartItemEndAngle = this.chartItemsEndAngleList[0];
        this.animationRunning = true;
        this.drawPathInit();
    }
    /**
     * @private
     * @return {?}
     */
    calculateAngleRadians() {
        this.series.forEach((/**
         * @param {?} serie
         * @param {?} index
         * @return {?}
         */
        (serie, index) => this.chartItemsEndAngleList[index] = ThfChartPieComponent.calculateEndAngle(serie.value, this.totalValue)));
    }
    /**
     * @private
     * @param {?} angleCurrentPosition
     * @return {?}
     */
    calculateCurrentEndAngle(angleCurrentPosition) {
        /** @type {?} */
        const isSerieDrawCompleted = this.chartItemStartAngle + angleCurrentPosition > this.chartItemStartAngle + this.chartItemEndAngle;
        if (isSerieDrawCompleted) {
            return (this.chartItemStartAngle + this.chartItemEndAngle) - thfChartCompleteCircle;
        }
        else {
            return this.chartItemStartAngle + angleCurrentPosition;
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    changeTooltipPosition(event) {
        if (this.tooltipElement && this.tooltipElement.classList.contains('thf-invisible')) {
            this.showTooltip();
        }
        /** @type {?} */
        const tooltipPositions = this.setTooltipPositions(event);
        this.renderer.setStyle(this.tooltipElement, 'left', `${tooltipPositions.left}px`);
        this.renderer.setStyle(this.tooltipElement, 'top', `${tooltipPositions.top}px`);
    }
    /**
     * @private
     * @return {?}
     */
    chartInitSetup() {
        this.calculateSVGContainerDimensions(this.chartWrapper, this.chartHeader, this.chartLegend);
        this.calculateTotalValue();
        this.calculateAngleRadians();
        this.createSVGElements();
        this.animationSetup();
    }
    /**
     * @private
     * @param {?} index
     * @param {?} serie
     * @param {?} svgPathsWrapper
     * @return {?}
     */
    createPath(index, serie, svgPathsWrapper) {
        /** @type {?} */
        const svgPath = this.renderer.createElement('svg:path', 'svg');
        this.renderer.setAttribute(svgPath, 'class', 'thf-path-item');
        this.renderer.setAttribute(svgPath, 'fill', this.colors[index]);
        this.renderer.setAttribute(svgPath, 'data-tooltip-category', serie.category);
        this.renderer.setAttribute(svgPath, 'data-tooltip-value', serie.value.toString());
        this.renderer.setAttribute(svgPath, 'data-tooltip-text', serie.tooltip || `${serie.category}: ${serie.value}`);
        svgPathsWrapper.appendChild(svgPath);
        this.renderer.appendChild(this.svgElement, svgPathsWrapper);
        this.svgPathElementsList.push(svgPath);
    }
    /**
     * @private
     * @return {?}
     */
    createPaths() {
        /** @type {?} */
        const svgPathsWrapper = this.renderer.createElement('svg:g', 'svg');
        this.series.forEach((/**
         * @param {?} serie
         * @param {?} index
         * @return {?}
         */
        (serie, index) => this.createPath(index, serie, svgPathsWrapper)));
    }
    /**
     * @private
     * @return {?}
     */
    createSVGElements() {
        this.svgElement = this.renderer.createElement('svg:svg', 'svg');
        this.renderer.setAttribute(this.svgElement, 'viewBox', `0 0 ${this.chartWrapper} ${this.centerX * 2}`);
        this.renderer.setAttribute(this.svgElement, 'preserveAspectRatio', 'xMidYMin meet');
        this.renderer.setAttribute(this.svgElement, 'class', 'thf-chart-svg-element');
        this.renderer.setAttribute(this.svgElement, 'width', `${this.chartWrapper - thfChartPadding * 2}`);
        this.renderer.setAttribute(this.svgElement, 'height', `${this.svgHeight}`);
        this.svgContainer.nativeElement.appendChild(this.svgElement);
        this.createPaths();
    }
    /**
     * @private
     * @param {?} path
     * @param {?} chartItemStartAngle
     * @param {?} chartItemEndAngle
     * @return {?}
     */
    drawPath(path, chartItemStartAngle, chartItemEndAngle) {
        /** @type {?} */
        const largeArc = (chartItemEndAngle - chartItemStartAngle) % (Math.PI * 2) > Math.PI ? 1 : 0;
        /** @type {?} */
        const startX = this.centerX + Math.cos(chartItemStartAngle) * this.centerX;
        /** @type {?} */
        const startY = this.centerX + Math.sin(chartItemStartAngle) * this.centerX;
        /** @type {?} */
        const endX = this.centerX + Math.cos(chartItemEndAngle) * this.centerX;
        /** @type {?} */
        const endY = this.centerX + Math.sin(chartItemEndAngle) * this.centerX;
        /** @type {?} */
        const pathCoordinates = [
            'M', startX, startY,
            'A', this.centerX, this.centerX, 0, largeArc, 1, endX, endY,
            'L', this.centerX, this.centerX,
            'Z'
        ].join(' ');
        return path.setAttribute('d', pathCoordinates);
    }
    /**
     * @private
     * @return {?}
     */
    drawPathInit() {
        if (!this.animationRunning) {
            return;
        }
        else {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => this.drawSeries()));
        }
    }
    /**
     * @private
     * @param {?=} currentSerieIndex
     * @param {?=} angleCurrentPosition
     * @return {?}
     */
    drawSeries(currentSerieIndex = 0, angleCurrentPosition = 0) {
        /** @type {?} */
        const isFinishedDrawingCurrentSeries = angleCurrentPosition > this.chartItemEndAngle;
        /** @type {?} */
        const isFinishedDrawingAllSeries = currentSerieIndex === this.svgPathElementsList.length;
        if (isFinishedDrawingAllSeries) {
            return;
        }
        if (isFinishedDrawingCurrentSeries) {
            this.chartItemStartAngle = this.chartItemStartAngle + this.chartItemEndAngle;
            currentSerieIndex++;
            this.chartItemEndAngle = this.chartItemsEndAngleList[currentSerieIndex];
            angleCurrentPosition = 0;
        }
        else {
            angleCurrentPosition += thfChartAngleStepInterval;
            this.drawPath(this.svgPathElementsList[currentSerieIndex], this.chartItemStartAngle, this.calculateCurrentEndAngle(angleCurrentPosition));
        }
        window.requestAnimationFrame(this.drawSeries.bind(this, currentSerieIndex, angleCurrentPosition));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    emitEventOnEnter(event) {
        this.onSerieHover.next(event);
    }
    /**
     * @private
     * @return {?}
     */
    onMouseClick() {
        /** @type {?} */
        const serieOnClick = { category: this.chartElementCategory, value: this.chartElementValue };
        this.onSerieClick.next(serieOnClick);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onMouseEnter(event) {
        this.tooltipElement = this.chartBody.nativeElement.lastChild;
        this.chartElementCategory = event.target.getAttributeNS(null, 'data-tooltip-category');
        this.chartElementValue = event.target.getAttributeNS(null, 'data-tooltip-value');
        this.tooltipText = event.target.getAttributeNS(null, 'data-tooltip-text');
        this.showTooltip();
        this.changeTooltipPosition(event);
        /** @type {?} */
        const serieOnEnter = { category: this.chartElementCategory, value: this.chartElementValue };
        this.emitEventOnEnter(serieOnEnter);
    }
    /**
     * @private
     * @return {?}
     */
    onWindowResize() {
        this.calculateSVGContainerDimensions(this.chartWrapper, this.chartHeader, this.chartLegend);
        this.renderer.setAttribute(this.svgElement, 'width', `${this.chartWrapper - thfChartPadding * 2}`);
        this.renderer.setAttribute(this.svgElement, 'height', `${this.svgHeight}`);
    }
    /**
     * @private
     * @return {?}
     */
    removeTooltip() {
        if (this.tooltipElement) {
            this.renderer.addClass(this.tooltipElement, 'thf-invisible');
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeWindowResizeListener() {
        if (this.windowResizeListener) {
            this.windowResizeListener();
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeWindowScrollListener() {
        if (this.windowScrollListener) {
            this.windowScrollListener();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setEventListeners() {
        /** @type {?} */
        let chartSeries = this.el.nativeElement.querySelectorAll('.thf-path-item');
        chartSeries = Array.from(chartSeries);
        chartSeries.forEach((/**
         * @param {?} serie
         * @return {?}
         */
        serie => {
            this.renderer.listen(serie, 'click', this.onMouseClick.bind(this));
            this.renderer.listen(serie, 'mouseenter', this.onMouseEnter.bind(this));
            this.renderer.listen(serie, 'mousemove', this.changeTooltipPosition.bind(this));
            this.renderer.listen(serie, 'mouseleave', this.removeTooltip.bind(this));
        }));
        this.windowResizeListener = this.renderer.listen(window, 'resize', this.onWindowResize.bind(this));
        this.windowScrollListener = this.renderer.listen(this.checkingIfScrollsWithThfPage(), 'scroll', this.removeTooltip.bind(this));
    }
    /**
     * @private
     * @return {?}
     */
    checkingIfScrollsWithThfPage() {
        /** @type {?} */
        const thfPageContent = document.getElementsByClassName('thf-page-content');
        return thfPageContent.length ? thfPageContent[0] : window;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    setTooltipPositions(event) {
        /** @type {?} */
        const displacement = 8;
        return {
            left: event.clientX - this.tooltipElement.offsetWidth / 2,
            top: event.clientY - this.tooltipElement.offsetHeight - displacement
        };
    }
    /**
     * @private
     * @return {?}
     */
    showTooltip() {
        this.renderer.removeClass(this.tooltipElement, 'thf-invisible');
    }
}
ThfChartPieComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-chart-pie',
                template: "<div #chartBody class=\"thf-chart-body\">\n  <div #svgContainer class=\"thf-chart-svg-container\"></div>\n  <div class=\"thf-chart-tooltip thf-tooltip thf-invisible\">\n    <div class=\"thf-tooltip-arrow thf-arrow-bottom\"></div>\n    <div class=\"thf-tooltip-content\">{{ tooltipText }}</div>\n  </div>\n</div>"
            }] }
];
/** @nocollapse */
ThfChartPieComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfChartBaseComponent
 *
 * \@example
 *
 * <example name="thf-chart-basic" title="Totvs Chart Basic">
 *  <file name="sample-thf-chart-basic/sample-thf-chart-basic.component.html"> </file>
 *  <file name="sample-thf-chart-basic/sample-thf-chart-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-chart-labs" title="Totvs Chart Labs">
 *  <file name="sample-thf-chart-labs/sample-thf-chart-labs.component.html"> </file>
 *  <file name="sample-thf-chart-labs/sample-thf-chart-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-chart-coffee-ranking" title="Totvs Chart - Coffee Ranking">
 *  <file name="sample-thf-chart-coffee-ranking/sample-thf-chart-coffee-ranking.component.html"> </file>
 *  <file name="sample-thf-chart-coffee-ranking/sample-thf-chart-coffee-ranking.component.ts"> </file>
 * </example>
 */
class ThfChartComponent extends ThfChartBaseComponent {
    /**
     * @param {?} changeDetector
     * @param {?} componentFactoryResolver
     * @param {?} differs
     */
    constructor(changeDetector, componentFactoryResolver, differs) {
        super();
        this.changeDetector = changeDetector;
        this.componentFactoryResolver = componentFactoryResolver;
        this.differs = differs;
        this.calculatedElement = false;
        this.initialized = false;
        this.windowResizeListener = new Subject();
        this.mappings = {
            [ThfChartType.Pie]: ThfChartPieComponent,
        };
        this.onResize = (/**
         * @return {?}
         */
        () => this.windowResizeListener.next());
        this.differ = this.differs.find([]).create(null);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initialized = true;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const charWrapperWidth = this.chartWrapper.nativeElement.offsetWidth;
        // Permite que o chart seja calculado na primeira vez que o componente torna-se visível,
        // evitando com isso, problemas com Tabs ou Divs que iniciem escondidas.
        if (charWrapperWidth && !this.calculatedElement && this.initialized) {
            this.calculatedElement = true;
            this.getSeriesColor();
            this.dynamicComponentSetting();
        }
        this.checkingForSerieChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeWindowResizeListener();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.getSeriesColor();
    }
    /**
     * @return {?}
     */
    rebuildComponent() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.dynamicComponentSetting();
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkingForSerieChanges() {
        if (this.componentRef && this.differ) {
            /** @type {?} */
            const changeSeries = this.differ.diff(this.series);
            if (changeSeries) {
                this.getSeriesColor();
                this.rebuildComponent();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    createComponent() {
        /** @type {?} */
        const componentType = this.getComponentType(this.type);
        /** @type {?} */
        const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
        this.componentRef = this.chartContainer.createComponent(factory);
        /** @type {?} */
        const instance = (/** @type {?} */ (this.componentRef.instance));
        this.setChartProperties(instance);
        return instance;
    }
    /**
     * @private
     * @return {?}
     */
    dynamicComponentSetting() {
        /** @type {?} */
        const instance = this.createComponent();
        this.setResizeListenerSubscribe(instance);
        this.changeDetector.detectChanges();
        this.setClickSubscribe(instance);
        this.setHoverSubscribe(instance);
    }
    /**
     * @private
     * @param {?} typeName
     * @return {?}
     */
    getComponentType(typeName) {
        return this.mappings[typeName];
    }
    /**
     * @private
     * @return {?}
     */
    getSeriesColor() {
        /** @type {?} */
        const colorsLength = ThfChartColors.length - 1;
        if (!this.series) {
            return this.colors = ThfChartColors[colorsLength];
        }
        /** @type {?} */
        const seriesLength = this.series.length - 1;
        if (seriesLength > colorsLength) {
            /** @type {?} */
            let colors = ThfChartColors[colorsLength];
            // recupera o resultado da divisao entre tamanho das series e o numero de cores disponiveis
            /** @type {?} */
            const quantityDuplicates = seriesLength / colorsLength;
            for (let i = 1; i <= quantityDuplicates; i++) {
                colors = colors.concat(ThfChartColors[colorsLength]);
            }
            return this.colors = colors;
        }
        return this.colors = ThfChartColors[seriesLength];
    }
    /**
     * @private
     * @return {?}
     */
    removeWindowResizeListener() {
        if (this.onResize) {
            this.onResize = (/**
             * @return {?}
             */
            () => { });
        }
    }
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    setChartProperties(instance) {
        instance.chartHeader = this.chartHeader.nativeElement.offsetHeight;
        instance.chartLegend = this.chartLegend.nativeElement.offsetHeight;
        instance.chartWrapper = this.chartWrapper.nativeElement.offsetWidth;
        instance.colors = this.colors;
        instance.height = this.height;
        instance.series = this.series || [];
    }
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    setClickSubscribe(instance) {
        instance.onSerieClick.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this.onSeriesClick(event);
        }));
    }
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    setHoverSubscribe(instance) {
        instance.onSerieHover.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this.onSeriesHover(event);
        }));
    }
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    setResizeListenerSubscribe(instance) {
        this.windowResizeListener.subscribe((/**
         * @return {?}
         */
        () => {
            instance.chartHeader = this.chartHeader.nativeElement.offsetHeight;
            instance.chartLegend = this.chartLegend.nativeElement.offsetHeight;
            instance.chartWrapper = this.chartWrapper.nativeElement.offsetWidth;
        }));
    }
}
ThfChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-chart',
                template: "<div #chartWrapper class=\"thf-chart-wrapper\">\n  <div #chartHeader class=\"thf-chart-header\">\n    <div class=\"thf-chart-title\">{{ title }}</div>\n  </div>\n  <ng-template #chartContainer></ng-template>\n  <div #chartLegend class=\"thf-chart-legend\">\n    <div class=\"thf-chart-legend-container\">\n      <div class=\"thf-chart-legend-item\" *ngFor=\"let serie of series; let i = index\">\n        <div class=\"thf-chart-legend-square\" [style.background]=\"colors[i]\"></div>\n        <span class=\"thf-chart-legend-text\">{{ serie.category }}</span>\n      </div>\n    </div>\n  </div>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfChartComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers }
];
ThfChartComponent.propDecorators = {
    chartContainer: [{ type: ViewChild, args: ['chartContainer', { read: ViewContainerRef, static: true },] }],
    chartHeader: [{ type: ViewChild, args: ['chartHeader', { static: true },] }],
    chartLegend: [{ type: ViewChild, args: ['chartLegend', { static: true },] }],
    chartWrapper: [{ type: ViewChild, args: ['chartWrapper', { static: true },] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente `thf-chart`.
 */
class ThfChartModule {
}
ThfChartModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    ThfChartComponent,
                    ThfChartPieComponent,
                ],
                entryComponents: [
                    ThfChartPieComponent
                ],
                exports: [
                    ThfChartComponent,
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O `thf-container` é um componente que visa facilitar o agrupamento de conteúdos.
 * Por padrão o mesmo exibe uma borda, um efeito de sombra ao seu redor e um espaçamento em sua parte interna, os quais
 * podem ser desabilitados. Ao remover sua borda a sombra também será removida. Além disso, sua altura acompanha a
 * quantidade do conteúdo, porém pode ser fixada. Para controlar sua largura, utilize o [Grid System](/guides/grid-system),
 * assim possibilitando o tratamento para diferentes resoluções.
 */
class ThfContainerBaseComponent {
    constructor() {
        this._noBorder = false;
        this._noPadding = false;
        this._noShadow = false;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a altura do `thf-container`.
     *
     * > Caso não seja definido um valor, a altura se ajustará de acordo com o conteúdo.
     * @param {?} value
     * @return {?}
     */
    set height(value) {
        this._height = convertToInt(value);
    }
    /**
     * @return {?}
     */
    get height() {
        return this._height;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita a borda e a sombra em torno do `thf-container`.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set noBorder(value) {
        this._noBorder = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get noBorder() {
        return this._noBorder;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita o espaçamento interno do `thf-container`.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set noPadding(value) {
        this._noPadding = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get noPadding() {
        return this._noPadding;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita o sombreamento em torno do `thf-container`.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set noShadow(value) {
        this._noShadow = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get noShadow() {
        return this._noShadow;
    }
}
ThfContainerBaseComponent.propDecorators = {
    height: [{ type: Input, args: ['t-height',] }],
    noBorder: [{ type: Input, args: ['t-no-border',] }],
    noPadding: [{ type: Input, args: ['t-no-padding',] }],
    noShadow: [{ type: Input, args: ['t-no-shadow',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfContainerBaseComponent
 *
 * \@example
 *
 * <example name="thf-container-basic" title="Totvs Container Basic">
 *  <file name="sample-thf-container-basic/sample-thf-container-basic.component.html"> </file>
 *  <file name="sample-thf-container-basic/sample-thf-container-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-container-labs" title="Totvs Container Labs">
 *  <file name="sample-thf-container-labs/sample-thf-container-labs.component.html"> </file>
 *  <file name="sample-thf-container-labs/sample-thf-container-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-container-dashboard" title="Totvs Container - Dashboard">
 *  <file name="sample-thf-container-dashboard/sample-thf-container-dashboard.component.html"> </file>
 *  <file name="sample-thf-container-dashboard/sample-thf-container-dashboard.component.ts"> </file>
 *  <file name="sample-thf-container-dashboard/sample-thf-container-dashboard.service.ts"> </file>
 * </example>
 */
class ThfContainerComponent extends ThfContainerBaseComponent {
}
ThfContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-container',
                template: "<div class=\"thf-container\"\n  [class.thf-container-no-border]=\"noBorder\"\n  [class.thf-container-no-padding]=\"noPadding\"\n  [class.thf-container-no-shadow]=\"noShadow\"\n  [style.height]=\"height ? height + 'px' : 'auto'\">\n  <ng-content></ng-content>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente `thf-container`.
 */
class ThfContainerModule {
}
ThfContainerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    ThfContainerComponent
                ],
                declarations: [
                    ThfContainerComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_DISCLAIMER_TYPES = ['default', 'danger'];
/** @type {?} */
const THF_DISCLAIMER_DEFAULT_TYPE = 'default';
/**
 * \@docsPrivate
 *
 * \@description
 *
 * O componente thf-disclaimer é responsável por representar tags.
 * Seu uso é recomendado em buscas e em campos onde é necessário representar objetos selecionados,
 * como por exemplo, no thf-multi-select.
 *
 */
class ThfDisclaimerBaseComponent {
    constructor() {
        this._type = 'default';
        this._hideClose = false;
        this.showDisclaimer = true;
        /**
         * Evento disparado ao fechar o disclaimer.
         * Para este evento será passado como parâmetro um objeto com value, label e property.
         */
        this.closeAction = new EventEmitter();
    }
    /**
     * \@description
     *
     * Esta propriedade esconde o botão para fechamento do thf-disclaimer, ao utilizar esta propriedade
     * sem passar valor a mesma é setada como false, onde o botão de fechamento está visível.
     *
     * \@default false
     * @param {?} value
     * @return {?}
     */
    set hideClose(value) {
        this._hideClose = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get hideClose() {
        return this._hideClose;
    }
    /**
     * \@description
     *
     * Tipo do thf-disclaimer. Pode ser 'default' ou 'danger'.
     *
     * \@default default
     * \@optional
     * @param {?} type
     * @return {?}
     */
    set type(type) {
        this._type = THF_DISCLAIMER_TYPES.includes(type) ? type : THF_DISCLAIMER_DEFAULT_TYPE;
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @return {?}
     */
    close() {
        this.showDisclaimer = false;
        this.closeAction.emit({ value: this.value, label: this.label, property: this.property });
    }
    /**
     * @return {?}
     */
    getLabel() {
        return this.label ? this.label : this.value;
    }
}
ThfDisclaimerBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    value: [{ type: Input, args: ['t-value',] }],
    property: [{ type: Input, args: ['t-property',] }],
    hideClose: [{ type: Input, args: ['t-hide-close',] }],
    closeAction: [{ type: Output, args: ['t-close-action',] }],
    type: [{ type: Input, args: ['t-type',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfDisclaimerBaseComponent
 *
 * \@examplePrivate
 *
 * <example-private name="thf-disclaimer" title="Totvs Disclaimer">
 *   <file name="sample-thf-disclaimer.component.html"> </file>
 *   <file name="sample-thf-disclaimer.component.ts"> </file>
 * </example-private>
 */
class ThfDisclaimerComponent extends ThfDisclaimerBaseComponent {
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyPress(event) {
        if (isKeyCodeEnter(event)) {
            this.close();
        }
    }
}
ThfDisclaimerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-disclaimer',
                template: "<div *ngIf=\"showDisclaimer === true\" class=\"thf-disclaimer\">\n\n  <span class=\"thf-disclaimer-label\"\n    [class.thf-disclaimer-label-danger]=\"type === 'danger'\">\n    {{getLabel()}}\n  </span>\n\n  <span *ngIf=\"hideClose === false\"\n    class=\"thf-disclaimer-remove thf-icon thf-icon-close thf-clickable\"\n    tabindex=\"0\"\n    [class.thf-disclaimer-remove-danger]=\"type === 'danger'\"\n    (click)=\"close()\"\n    (keydown)=\"onKeyPress($event)\">\n  </span>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-disclaimer.
 */
class ThfDisclaimerModule {
}
ThfDisclaimerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [ThfDisclaimerComponent],
                exports: [ThfDisclaimerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfDisclaimerGroupLiteralsDefault = {
    en: { removeAll: 'Remove all' },
    es: { removeAll: 'Eliminar todos' },
    pt: { removeAll: 'Remover todos' }
};
/**
 * \@description
 *
 * O componente `thf-disclaimer-group` é recomendado para manipular palavras-chave de filtros aplicados em uma pesquisa.
 *
 * À partir de dois *disclaimers* com o botão **fechar** habilitado, o componente renderiza de forma automática um novo e destacado
 * *disclaimer* que possibilita **remover todos**, mas que também pode ser desabilitado.
 *
 * Também é possível navegar entre os *disclaimers* através do teclado utilizando a tecla *tab* e, para remoção do *disclaimer* selecionado,
 * basta pressionar a tecla *enter*. Esta funcionalidade não se aplica caso a propriedade `hideClose` estiver habilitada.
 *
 * > Veja a integração destas funcionalidade no componente [thf-page-list](/documentation/thf-page-list).
 */
class ThfDisclaimerGroupBaseComponent {
    /**
     * @param {?} differs
     */
    constructor(differs) {
        this._disclaimers = [];
        this._hideRemoveAll = false;
        this.previousDisclaimers = [];
        this.literals = Object.assign({}, thfDisclaimerGroupLiteralsDefault[thfLocaleDefault], thfDisclaimerGroupLiteralsDefault[browserLanguage()]);
        /**
         * Função que será disparada quando a lista de *disclaimers* for modificada.
         */
        this.change = new EventEmitter();
        this.differ = differs.find([]).create(null);
    }
    /** Lista de *disclaimers*. */
    /**
     * \@description
     *
     * Lista de *disclaimers*.
     *
     * Para que a lista de *disclaimers* seja atualizada dinamicamente deve-se passar uma nova referência do array de `ThfDisclaimer`.
     *
     * Exemplo adicionando um *disclaimer* no array:
     *
     * ```
     * this.disclaimers = [...this.disclaimers, disclaimer];
     * ```
     *
     * ou
     *
     * ```
     * this.disclaimers = this.disclaimers.concat(disclaimer);
     * ```
     * @param {?} value
     * @return {?}
     */
    set disclaimers(value) {
        this.previousDisclaimers = [...this.disclaimers];
        this._disclaimers = this.checkDisclaimers(value);
    }
    /**
     * @return {?}
     */
    get disclaimers() {
        return this._disclaimers;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Oculta o botão para remover todos os *disclaimers* do grupo.
     *
     * > Por padrão, o mesmo é exibido à partir de dois ou mais *disclaimers* com a opção `hideClose` habilitada.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set hideRemoveAll(value) {
        this._hideRemoveAll = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get hideRemoveAll() {
        return this._hideRemoveAll;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.checkChanges();
    }
    /**
     * @param {?} disclaimer
     * @param {?=} emitChange
     * @return {?}
     */
    closeItem(disclaimer, emitChange = true) {
        /** @type {?} */
        const itemIndex = this.disclaimers.findIndex((/**
         * @param {?} d
         * @return {?}
         */
        d => d['$id'] === disclaimer['$id']));
        this.disclaimers.splice(itemIndex, 1);
        if (emitChange) {
            this.emitChangeDisclaimers();
        }
    }
    /**
     * @return {?}
     */
    isRemoveAll() {
        return !this.hideRemoveAll && this.disclaimers.filter((/**
         * @param {?} c
         * @return {?}
         */
        c => !c.hideClose)).length > 1;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyPress(event) {
        if (isKeyCodeEnter(event)) {
            this.removeAllItems();
        }
    }
    /**
     * @return {?}
     */
    removeAllItems() {
        /** @type {?} */
        const removeItems = [];
        this.disclaimers.forEach((/**
         * @param {?} disclaimer
         * @return {?}
         */
        disclaimer => {
            if (!disclaimer.hideClose) {
                removeItems.push(disclaimer);
            }
        }));
        removeItems.forEach((/**
         * @param {?} disclaimer
         * @return {?}
         */
        disclaimer => this.closeItem(disclaimer, false)));
        this.emitChangeDisclaimers();
    }
    /**
     * @private
     * @return {?}
     */
    checkChanges() {
        if (this.differ) {
            /** @type {?} */
            const changes = this.differ.diff(this.disclaimers);
            if (changes && this.disclaimersAreChanged(this.disclaimers)) {
                this.emitChangeDisclaimers();
            }
        }
    }
    /**
     * @private
     * @param {?} disclaimers
     * @return {?}
     */
    checkDisclaimers(disclaimers) {
        if (Array.isArray(disclaimers)) {
            for (let i = 0; i < disclaimers.length; i++) {
                /** @type {?} */
                const disclaimer = disclaimers[i];
                if (disclaimer.value || disclaimer.value === 0 || disclaimer.value === false) {
                    disclaimer['$id'] = v4();
                }
                else {
                    disclaimers.splice(i, 1);
                    i--;
                }
            }
            return disclaimers;
        }
        return [];
    }
    /**
     * @private
     * @param {?} disclaimers
     * @return {?}
     */
    disclaimersAreChanged(disclaimers) {
        /** @type {?} */
        const currentValues = disclaimers;
        if (currentValues.length !== this.previousDisclaimers.length) {
            return true;
        }
        return currentValues.some((/**
         * @param {?} disclaimer
         * @param {?} index
         * @return {?}
         */
        (disclaimer, index) => disclaimer.value !== this.previousDisclaimers[index].value
            || disclaimer.property !== this.previousDisclaimers[index].property));
    }
    /**
     * @private
     * @return {?}
     */
    emitChangeDisclaimers() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.change.emit(this.disclaimers);
        }));
        this.previousDisclaimers = [...this._disclaimers];
    }
}
ThfDisclaimerGroupBaseComponent.propDecorators = {
    disclaimers: [{ type: Input, args: ['t-disclaimers',] }],
    hideRemoveAll: [{ type: Input, args: ['t-hide-remove-all',] }],
    title: [{ type: Input, args: ['t-title',] }],
    change: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfDisclaimerGroupBaseComponent
 *
 * \@example
 *
 * <example name="thf-disclaimer-group-basic" title="Totvs Disclaimer Group Basic">
 *   <file name="sample-thf-disclaimer-group-basic/sample-thf-disclaimer-group-basic.component.html"> </file>
 *   <file name="sample-thf-disclaimer-group-basic/sample-thf-disclaimer-group-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-disclaimer-group-labs" title="Totvs Disclaimer Group Labs">
 *   <file name="sample-thf-disclaimer-group-labs/sample-thf-disclaimer-group-labs.component.html"> </file>
 *   <file name="sample-thf-disclaimer-group-labs/sample-thf-disclaimer-group-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-disclaimer-group-sw-planets" title="Totvs Disclaimer Group - Star Wars Planets">
 *   <file name="sample-thf-disclaimer-group-sw-planets/sample-thf-disclaimer-group-sw-planets.component.html"> </file>
 *   <file name="sample-thf-disclaimer-group-sw-planets/sample-thf-disclaimer-group-sw-planets.component.ts"> </file>
 *   <file name="sample-thf-disclaimer-group-sw-planets/sample-thf-disclaimer-group-sw-planets.service.ts"> </file>
 * </example>
 *
 */
class ThfDisclaimerGroupComponent extends ThfDisclaimerGroupBaseComponent {
    /**
     * @param {?} differs
     */
    constructor(differs) {
        super(differs);
    }
}
ThfDisclaimerGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-disclaimer-group',
                template: "<div class=\"thf-disclaimer-group\" *ngIf=\"disclaimers.length > 0\" >\n  <div class=\"thf-disclaimer-group-title\">{{ title }}</div>\n\n  <thf-disclaimer-remove *ngIf=\"isRemoveAll()\"\n    class=\"thf-disclaimer-group-disclaimer-align\"\n    [t-label]=\"literals.removeAll\"\n    (keydown)=\"onKeyPress($event)\"\n    (t-remove-all-action)=\"removeAllItems()\">\n  </thf-disclaimer-remove>\n\n  <thf-disclaimer *ngFor=\"let disclaimer of disclaimers\"\n    class=\"thf-disclaimer-group-disclaimer-align\"\n    [t-hide-close]=\"disclaimer.hideClose\"\n    [t-label]=\"disclaimer.label\"\n    [t-property]=\"disclaimer.property\"\n    [t-value]=\"disclaimer.value\"\n    (t-close-action)=\"closeItem(disclaimer)\">\n  </thf-disclaimer>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfDisclaimerGroupComponent.ctorParameters = () => [
    { type: IterableDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Este é um componente interno utilizado pelo thf-disclaimer-group, se comporta como um botão e recebe uma ação para remover todos os
 * thf-disclaimers do grupo.
 */
class ThfDisclaimerRemoveComponent {
    constructor() {
        /**
         * Ação para remover todos.
         */
        this.removeAllAction = new EventEmitter();
    }
    // Emite a ação de remover todos.
    /**
     * @return {?}
     */
    removeAction() {
        this.removeAllAction.emit();
    }
}
ThfDisclaimerRemoveComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-disclaimer-remove',
                template: "<thf-disclaimer\n  class=\"thf-clickable\"\n  tabindex=\"0\"\n  t-hide-close=\"true\"\n  t-type=\"danger\"\n  [t-label]=\"label\"\n  (click)=\"removeAction()\">\n</thf-disclaimer>\n"
            }] }
];
ThfDisclaimerRemoveComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    removeAllAction: [{ type: Output, args: ['t-remove-all-action',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-disclaimer-group.
 */
class ThfDisclaimerGroupModule {
}
ThfDisclaimerGroupModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfDisclaimerModule
                ],
                declarations: [ThfDisclaimerGroupComponent, ThfDisclaimerRemoveComponent],
                exports: [ThfDisclaimerGroupComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Este componente apresenta uma linha demarcadora de blocos e pode conter um *label*. Seu uso é indicado para definição
 * e organização de informações em uma tela e sua característica é semelhante à tag `<hr>`.
 */
class ThfDividerBaseComponent {
}
ThfDividerBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfDividerBaseComponent
 *
 * \@example
 *
 * <example name="thf-divider-basic" title="Totvs Divider Basic" >
 *  <file name="sample-thf-divider-basic/sample-thf-divider-basic.component.html"> </file>
 *  <file name="sample-thf-divider-basic/sample-thf-divider-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-divider-labs" title="Totvs Divider Labs" >
 *  <file name="sample-thf-divider-labs/sample-thf-divider-labs.component.html"> </file>
 *  <file name="sample-thf-divider-labs/sample-thf-divider-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-divider-user-detail" title="Totvs Divider - User Detail" >
 *  <file name="sample-thf-divider-user-detail/sample-thf-divider-user-detail.component.html"> </file>
 *  <file name="sample-thf-divider-user-detail/sample-thf-divider-user-detail.component.ts"> </file>
 * </example>
 */
class ThfDividerComponent extends ThfDividerBaseComponent {
}
ThfDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-divider',
                template: "<div class=\"thf-divider\">\n  <div *ngIf=\"label\" class=\"thf-divider-label\">{{ label }}</div>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-divider.
 */
class ThfDividerModule {
}
ThfDividerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ThfDividerComponent
                ],
                exports: [
                    ThfDividerComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfPopupDefaultPosition = 'bottom-left';
/**
 * \@description
 *
 * O componente `thf-popup` é um container pequeno recomendado para ações de navegação:
 * Ele abre sobreposto aos outros componentes.
 *
 * É possível escolher as posições do `thf-popup` em relação ao componente alvo, para isto veja a propriedade `t-position`.
 *
 * Também é possível informar um _template_ _header_ para o `thf-popup`, que será exibido acima das ações.
 * Para funcionar corretamente é preciso adicionar a propriedade `t-popup-header-template` no elemento que servirá de template, por exemplo:
 *
 * ```
 * <thf-popup [t-target]="target">
 *   <div t-popup-header-template>
 *     <div>
 *       Dev Totvs
 *     </div>
 *     <div>
 *       dev.totvs\@totvs.com.br
 *     </div>
 *   </div>
 * </thf-popup >
 * ```
 */
class ThfPopupBaseComponent {
    constructor() {
        this._hideArrow = false;
        this._isCornerAlign = false;
        this._position = thfPopupDefaultPosition;
        this.arrowDirection = 'top-right';
        this.showPopup = false;
    }
    /**
     * Lista de ações que serão exibidas no componente.
     * @param {?} value
     * @return {?}
     */
    set actions(value) {
        this._actions = Array.isArray(value) ? value : [];
    }
    /**
     * @return {?}
     */
    get actions() {
        return this._actions;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Oculta a seta do componente *popup*.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set hideArrow(value) {
        this._hideArrow = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get hideArrow() {
        return this._hideArrow;
    }
    // Define se o `thf-popup` será alinhado pelos cantos do elemento target.
    /**
     * @param {?} value
     * @return {?}
     */
    set isCornerAlign(value) {
        this._isCornerAlign = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get isCornerAlign() {
        return this._isCornerAlign;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a posição inicial que o `thf-popup` abrirá em relação ao componente alvo. Sugere-se que seja
     * usada a orientação `bottom-left` (abaixo e a esquerda), porém o mesmo é flexível e será rotacionado
     * automaticamente para se adequar a tela, caso necessário.
     *
     * > Caso seja definido um `t-custom-positions` o componente irá abrir na posição definida na propriedade `t-position`
     * e caso não caiba na posição inicial ele irá rotacionar seguindo a ordem de posições definidas no `t-custom-positions`.
     *
     * Posições válidas:
     * - `right`: Posiciona o thf-popup no lado direito do componente alvo.
     * - `right-bottom`: Posiciona o thf-popup no lado direito inferior do componente alvo.
     * - `right-top`: Posiciona o thf-popup no lado direito superior do componente alvo.
     * - `bottom`: Posiciona o thf-popup abaixo do componente alvo.
     * - `bottom-left`: Posiciona o thf-popup abaixo e à esquerda do componente alvo.
     * - `bottom-right`: Posiciona o thf-popup abaixo e à direita do componente alvo.
     * - `left`: Posiciona o thf-popup no lado esquerdo do componente alvo.
     * - `left-top`: Posiciona o thf-popup no lado esquerdo superior do componente alvo.
     * - `left-bottom`: Posiciona o thf-popup no lado esquerdo inferior do componente alvo.
     * - `top`: Posiciona o thf-popup acima do componente alvo.
     * - `top-right`: Posiciona o thf-popup acima e à direita do componente alvo.
     * - `top-left`: Posiciona o thf-popup acima e à esquerda do componente alvo.
     *
     * \@default `bottom-left`
     * @param {?} value
     * @return {?}
     */
    set position(value) {
        this._position = THF_CONTROL_POSITIONS.includes(value) ? value : thfPopupDefaultPosition;
    }
    /**
     * @return {?}
     */
    get position() {
        return this._position;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define as posições e a sequência que o `thf-popup` poderá rotacionar. A sequência será definida pela ordem passada
     * no *array*. Caso não seja definido, o `thf-popup` irá rotacionar em todas as posições válidas.
     *
     * > O componente sempre irá abrir na posição definida no `t-position` e caso não caiba na posição definida o mesmo
     * irá rotacionar seguindo a ordem definida pelo `t-custom-position`.
     *
     * Posições válidas:
     * - `right`: Posiciona o thf-popup no lado direito do componente alvo.
     * - `right-bottom`: Posiciona o thf-popup no lado direito inferior do componente alvo.
     * - `right-top`: Posiciona o thf-popup no lado direito superior do componente alvo.
     * - `bottom`: Posiciona o thf-popup abaixo do componente alvo.
     * - `bottom-left`: Posiciona o thf-popup abaixo e à esquerda do componente alvo.
     * - `bottom-right`: Posiciona o thf-popup abaixo e à direita do componente alvo.
     * - `left`: Posiciona o thf-popup no lado esquerdo do componente alvo.
     * - `left-top`: Posiciona o thf-popup no lado esquerdo superior do componente alvo.
     * - `left-bottom`: Posiciona o thf-popup no lado esquerdo inferior do componente alvo.
     * - `top`: Posiciona o thf-popup acima do componente alvo.
     * - `top-right`: Posiciona o thf-popup acima e à direita do componente alvo.
     * - `top-left`: Posiciona o thf-popup acima e à esquerda do componente alvo.
     * @param {?} value
     * @return {?}
     */
    set customPositions(value) {
        this._customPositions = Array.isArray(value) ? value : [];
    }
    /**
     * @return {?}
     */
    get customPositions() {
        return this._customPositions;
    }
    /**
     * \@description
     *
     * Para utilizar o `thf-popup` deve-se colocar uma variável local no componente que disparará o evento
     * de abertura no mesmo e com isso, invocará a função `toggle`, por exemplo:
     *
     * ```
     * <span #icon class="thf-icon thf-icon-credit-payment" (click)="popup.toggle()">
     *   Credit Actions
     * </span>
     *
     * <thf-popup #popup
     *   [t-actions]="actions"
     *   [t-target]="icon">
     * </thf-popup>
     * ```
     *
     * Caso o elemento alvo for um componente, será preciso obter o `ElementRef` do mesmo e passá-lo à propriedade, por exemplo:
     *
     * ```
     * // component.html
     *
     * <thf-button #thfButton
     *   t-label="Open Popover"
     *   (t-click)="popup.toggle()">
     * </thf-button>
     *
     * <thf-popup #popup
     *   [t-actions]="actions"
     *   [t-target]="thfButtonRef">
     * </thf-popup>
     *
     * // component.ts
     *
     * \@ViewChild('thfButton', { read: ElementRef }) thfButtonRef: ElementRef;
     * ```
     * @param {?} value
     * @return {?}
     */
    set target(value) {
        this._target = (value instanceof ElementRef) ? value.nativeElement : value;
    }
    /**
     * @return {?}
     */
    get target() {
        return this._target;
    }
}
ThfPopupBaseComponent.propDecorators = {
    actions: [{ type: Input, args: ['t-actions',] }],
    hideArrow: [{ type: Input, args: ['t-hide-arrow',] }],
    isCornerAlign: [{ type: Input, args: ['t-is-corner-align',] }],
    position: [{ type: Input, args: ['t-position',] }],
    customPositions: [{ type: Input, args: ['t-custom-positions',] }],
    target: [{ type: Input, args: ['t-target',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@docsExtends ThfPopupBaseComponent
 *
 * \@example
 *
 * <example name="thf-popup-basic" title="Totvs Popup - Basic">
 *   <file name="sample-thf-popup-basic/sample-thf-popup-basic.component.html"> </file>
 *   <file name="sample-thf-popup-basic/sample-thf-popup-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-popup-labs" title="Totvs Popup - Labs">
 *   <file name="sample-thf-popup-labs/sample-thf-popup-labs.component.html"> </file>
 *   <file name="sample-thf-popup-labs/sample-thf-popup-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-popup-email" title="Totvs Popup Email">
 *   <file name="sample-thf-popup-email/sample-thf-popup-email.component.html"> </file>
 *   <file name="sample-thf-popup-email/sample-thf-popup-email.component.ts"> </file>
 * </example>
 *
 */
class ThfPopupComponent extends ThfPopupBaseComponent {
    /**
     * @param {?} viewContainerRef
     * @param {?} renderer
     * @param {?} router
     * @param {?} thfControlPosition
     * @param {?} changeDetector
     */
    constructor(viewContainerRef, renderer, router, thfControlPosition, changeDetector) {
        super();
        this.renderer = renderer;
        this.router = router;
        this.thfControlPosition = thfControlPosition;
        this.changeDetector = changeDetector;
        this.onScroll = (/**
         * @return {?}
         */
        () => {
            if (this.showPopup) {
                this.close();
            }
        });
        this.parentRef = viewContainerRef['_view']['component'];
    }
    /**
     * Fecha o componente *popup*.
     *
     * > Por padrão, este comportamento é acionado somente ao clicar fora do componente ou em determinada ação / url.
     * @return {?}
     */
    close() {
        this.removeListeners();
        this.showPopup = false;
    }
    /**
     * @param {?} popupAction
     * @return {?}
     */
    onActionClick(popupAction) {
        /** @type {?} */
        const actionNoDisabled = popupAction && !this.returnBooleanValue(popupAction, 'disabled');
        if (popupAction && popupAction.action && actionNoDisabled) {
            this.close();
            return callFunction(popupAction.action, this.parentRef, this.param || popupAction);
        }
        if (popupAction && popupAction.url && actionNoDisabled) {
            this.close();
            return this.openUrl(popupAction.url);
        }
    }
    /**
     * Abre o componente *popup*.
     *
     * > É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     * @param {?=} param
     * @return {?}
     */
    open(param) {
        this.oldTarget = this.target;
        this.param = param;
        this.showPopup = true;
        this.changeDetector.detectChanges();
        this.validateInitialContent();
    }
    /**
     * @param {?} popupAction
     * @param {?} property
     * @return {?}
     */
    returnBooleanValue(popupAction, property) {
        return isTypeof(popupAction[property], 'function') ? popupAction[property](this.param || popupAction) : popupAction[property];
    }
    /**
     * Responsável por abrir e fechar o *popup*.
     *
     * Quando disparado abrirá o *popup* e caso o mesmo já estiver aberto e possuir o mesmo `target` irá fecha-lo.
     *
     * É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     * @param {?=} param
     * @return {?}
     */
    toggle(param) {
        this.showPopup && this.oldTarget === this.target ? this.close() : this.open(param);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    clickedOutDisabledItem(event) {
        /** @type {?} */
        const containsItemDisabled = this.elementContains(event.target, 'thf-popup-item-disabled') ||
            this.elementContains(event.target.parentElement, 'thf-popup-item-disabled');
        return !containsItemDisabled;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    clickedOutHeaderTemplate(event) {
        /** @type {?} */
        const popupHeaderTemplate = this.popupRef && this.popupRef.nativeElement.querySelector('[t-popup-header-template]');
        return !(popupHeaderTemplate && popupHeaderTemplate.contains(event.target));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    clickedOutTarget(event) {
        return this.target && !this.target.contains(event.target);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    closePopupOnClickout(event) {
        if (this.clickedOutTarget(event) && this.clickedOutDisabledItem(event) && this.clickedOutHeaderTemplate(event)) {
            this.close();
        }
    }
    /**
     * @private
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    elementContains(element, className) {
        return element && element.classList.contains(className);
    }
    /**
     * @private
     * @return {?}
     */
    hasContentToShow() {
        return !!(this.popupRef.nativeElement && this.popupRef.nativeElement.clientHeight);
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.close();
        }));
        this.clickoutListener = this.renderer.listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.closePopupOnClickout(event);
        }));
        window.addEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    openUrl(url) {
        if (isExternalLink(url)) {
            return openExternalLink(url);
        }
        if (url) {
            return this.router.navigate([url]);
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.clickoutListener) {
            this.clickoutListener();
        }
        if (this.resizeListener) {
            this.resizeListener();
        }
        window.removeEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    setPosition() {
        this.thfControlPosition.setElements(this.popupRef.nativeElement, 8, this.target, this.customPositions, false, this.isCornerAlign);
        this.thfControlPosition.adjustPosition(this.position);
        this.arrowDirection = this.thfControlPosition.getArrowDirection();
    }
    /**
     * @private
     * @return {?}
     */
    validateInitialContent() {
        if (this.hasContentToShow()) {
            this.setPosition();
            this.initializeListeners();
        }
        else {
            this.close();
        }
    }
}
ThfPopupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-popup',
                template: "<div #popupRef class=\"thf-popup\" *ngIf=\"showPopup\">\n\n  <div *ngIf=\"!hideArrow\" class=\"thf-popup-arrow thf-arrow-{{ arrowDirection }}\"></div>\n\n  <ng-content select=\"[t-popup-header-template]\"></ng-content>\n\n  <ng-container *ngFor=\"let action of actions; let actionIndex = index\">\n    <div *ngIf=\"action.visible !== false\"\n      [class.thf-popup-item-default]=\"action.type !== 'danger'\"\n      [class.thf-popup-item-danger]=\"action.type === 'danger'\"\n      [class.thf-popup-item-disabled]=\"returnBooleanValue(action, 'disabled')\"\n      [class.thf-popup-item-separator]=\"action.separator && actionIndex !== 0\"\n      [class.thf-popup-item-selected]=\"action.selected\"\n      (click)=\"onActionClick(action)\">\n\n      <span *ngIf=\"action.icon\" class=\"thf-icon {{ action.icon }} thf-popup-icon-item\"></span>\n      {{ action.label }}\n\n    </div>\n  </ng-container>\n\n</div>\n",
                providers: [ThfControlPositionService]
            }] }
];
/** @nocollapse */
ThfPopupComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: Router },
    { type: ThfControlPositionService },
    { type: ChangeDetectorRef }
];
ThfPopupComponent.propDecorators = {
    popupRef: [{ type: ViewChild, args: ['popupRef', { read: ElementRef, static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-popup.
 */
class ThfPopupModule {
}
ThfPopupModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    ThfPopupComponent,
                ],
                exports: [
                    ThfPopupComponent
                ],
                providers: [],
                schemas: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-dropdown` pode ser utilizado como um agrupador de ações e / ou opções.
 *
 * > Caso não haja configuração de rotas em sua aplicação, se faz necessário importar o `RouterModule`
 * no módulo principal para o correto funcionamento deste componente:
 *
 * ```
 * import { RouterModule } from '\@angular/router';
 *
 * \@NgModule({
 *   imports: [
 *     ...
 *     RouterModule.forRoot([]),
 *     ThfModule
 *   ],
 *   declarations: [
 *     AppComponent
 *   ],
 *   exports: [],
 *   providers: [],
 *   bootstrap: [
 *     AppComponent
 *   ]
 * })
 * export class AppModule { }
 * ```
 * > Para maiores dúvidas referente à configuração de rotas, acesse em nosso portal /Guias /Começando
 * [/Configurando as rotas do thf-menu](/guides/getting-started).
 */
class ThfDropdownBaseComponent {
    constructor() {
        this._disabled = false;
        this.icon = 'thf-icon-arrow-down';
        this.open = false;
    }
    /**
     * Lista de ações que serão exibidas no componente.
     * @param {?} value
     * @return {?}
     */
    set actions(value) {
        this._actions = Array.isArray(value) ? value : [];
    }
    /**
     * @return {?}
     */
    get actions() {
        return this._actions;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita o campo.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
}
ThfDropdownBaseComponent.propDecorators = {
    actions: [{ type: Input, args: ['t-actions',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    label: [{ type: Input, args: ['t-label',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfDropdownBaseComponent
 *
 * \@example
 *
 * <example name="thf-dropdown-basic" title="Totvs Dropdown Basic" >
 *  <file name="sample-thf-dropdown-basic/sample-thf-dropdown-basic.component.html"> </file>
 *  <file name="sample-thf-dropdown-basic/sample-thf-dropdown-basic.component.ts"> </file>
 *  <file name="sample-thf-dropdown-basic/sample-thf-dropdown-basic.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-dropdown-basic/sample-thf-dropdown-basic.component.po.ts"> </file>
 * </example>
 *
 * <example name="thf-dropdown-labs" title="Totvs Dropdown Labs" >
 *  <file name="sample-thf-dropdown-labs/sample-thf-dropdown-labs.component.html"> </file>
 *  <file name="sample-thf-dropdown-labs/sample-thf-dropdown-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-dropdown-social-network" title="Totvs Dropdown - Social Network" >
 *  <file name="sample-thf-dropdown-social-network/sample-thf-dropdown-social-network.component.html"> </file>
 *  <file name="sample-thf-dropdown-social-network/sample-thf-dropdown-social-network.component.ts"> </file>
 * </example>
 */
class ThfDropdownComponent extends ThfDropdownBaseComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super();
        this.renderer = renderer;
        this.onScroll = (/**
         * @return {?}
         */
        () => {
            if (this.open) {
                this.hideDropdown();
            }
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (isKeyCodeEnter(event)) {
            this.toggleDropdown();
        }
    }
    /**
     * @return {?}
     */
    toggleDropdown() {
        this.dropdownRef && !this.open && !this.disabled ? this.showDropdown() : this.hideDropdown();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    checkClickArea(event) {
        return this.dropdownRef && this.dropdownRef.nativeElement.contains(event.target);
    }
    /**
     * @private
     * @return {?}
     */
    hideDropdown() {
        this.icon = 'thf-icon-arrow-down';
        this.removeListeners();
        this.popupRef.close();
        this.open = false;
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.clickoutListener = this.renderer.listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.wasClickedOnDropdown(event);
        }));
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.hideDropdown();
        }));
        window.addEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.clickoutListener) {
            this.clickoutListener();
        }
        if (this.resizeListener) {
            this.resizeListener();
        }
        window.removeEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    showDropdown() {
        this.icon = 'thf-icon-arrow-up';
        this.initializeListeners();
        this.popupRef.open();
        this.open = true;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    wasClickedOnDropdown(event) {
        /** @type {?} */
        const clickedOnDropdown = this.checkClickArea(event);
        if (!clickedOnDropdown) {
            this.hideDropdown();
        }
    }
}
ThfDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-dropdown',
                template: "<div #dropdownRef\n  class=\"thf-dropdown\"\n  tabindex=\"{{ disabled ? -1 : 0 }}\"\n  (click)=\"toggleDropdown()\"\n  (keydown)=\"onKeyDown($event)\">\n\n  <div class=\"thf-dropdown-button\" [ngClass]=\"{'thf-dropdown-button-disabled' : disabled}\">\n    {{ label }}\n    <div class=\"thf-dropdown-icon thf-icon {{icon}}\"></div>\n  </div>\n\n  <thf-popup #popupRef\n    t-hide-arrow\n    t-is-corner-align\n    t-position=\"bottom-left\"\n    [t-actions]=\"actions\"\n    [t-custom-positions]=\"['bottom-left', 'top-left']\"\n    [t-target]=\"dropdownRef\">\n  </thf-popup>\n\n</div>\n"
            }] }
];
/** @nocollapse */
ThfDropdownComponent.ctorParameters = () => [
    { type: Renderer2 }
];
ThfDropdownComponent.propDecorators = {
    dropdownRef: [{ type: ViewChild, args: ['dropdownRef', { read: ElementRef, static: true },] }],
    popupRef: [{ type: ViewChild, args: ['popupRef', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-dropdown.
 */
class ThfDropdownModule {
}
ThfDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfPopupModule
                ],
                declarations: [ThfDropdownComponent],
                exports: [ThfDropdownComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfDefaultLanguage = 'THF_DEFAULT_LANGUAGE';
/** @type {?} */
const thfLocaleKey = 'THF_USER_LOCALE';
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço responsável por gerenciar as linguagens da aplicação.
 */
class ThfLanguageService {
    /**
     * @param {?} language
     * @return {?}
     */
    set languageDefault(language) {
        if (language && isLanguage(language)) {
            localStorage.setItem(thfDefaultLanguage, language);
        }
    }
    /**
     * @return {?}
     */
    get languageDefault() {
        return localStorage.getItem(thfDefaultLanguage);
    }
    /**
     * \@description
     *
     * Método responsável por retornar o idioma ativo.
     *
     * A busca do idioma será feita na seguinte ordem:
     *
     *   1 - o idioma que foi armazenado no *localStorage*, através do método `setLanguage()` utilizado pelo i18n.
     *
     *   2 - o valor inserido nas configurações do módulo do i18n através do parâmetro `config`, sendo o idioma inserido
     * na propriedade `language` da interface `ThfI18nConfigDefault`.
     *
     *   3 - o idioma do navegador utilizado.
     *
     * > Caso o idioma do navegador não seja suportado pelo THF (`pt`, `en` ou `es`), será retornado valor `pt`.
     *
     * **Retorno:** `string` com a sigla do idioma ativo.
     * @return {?}
     */
    getLanguage() {
        /** @type {?} */
        const language = localStorage.getItem(thfLocaleKey) || this.languageDefault || getBrowserLanguage();
        return language && language.toLowerCase();
    }
    /**
     * \@description
     *
     * Método responsável por retornar o idioma *default* da aplicação definido nas configurações do módulo do i18n através
     * do parâmetro `config`.
     *
     * **Retorno:** `string` com a sigla do idioma *default*.
     * @return {?}
     */
    getLanguageDefault() {
        return this.languageDefault;
    }
    /**
     * \@description
     *
     * Método responsável por retornar a abreviação do idioma ativo na aplicação.
     *
     * \@default `pt`
     *
     * **Retorno:** `string` com a sigla abreviada do idioma ativo.
     * @return {?}
     */
    getShortLanguage() {
        /** @type {?} */
        const language = this.getLanguage();
        /** @type {?} */
        const shortLanguage = getShortLanguage(language);
        return thfLocales.includes(shortLanguage) ? shortLanguage : thfLocaleDefault;
    }
    /**
     * \@description
     *
     * Método para salvar o idioma da aplicação no *storage*, utilizado pelo serviço do i18n.
     *
     * > Ao definir um idioma por este método, todos os módulos da aplicação utilizarão o idioma definido.
     *
     * @param {?} language sigla do idioma.
     *
     * Esta sigla deve ser composta por duas letras representando o idioma,
     * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
     *
     * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
     * @return {?}
     */
    setLanguage(language) {
        if (!isLanguage(language)) {
            return;
        }
        localStorage.setItem(thfLocaleKey, language.toLowerCase());
    }
    /**
     * \@description
     *
     * Método que define o idioma configurado a partir do parâmetro `config` utilizado pelo módulo do i18n.
     *
     * > Ao definir um idioma por este serviço, apenas o módulo do i18n referente a esta configuração utilizará o idioma definido.
     *
     * @param {?} language sigla do idioma.
     *
     * Esta sigla deve ser composta por duas letras representando o idioma,
     * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
     *
     * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
     * @return {?}
     */
    setLanguageDefault(language) {
        this.languageDefault = language;
    }
}
ThfLanguageService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ThfLanguageService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ThfLanguageService_Factory() { return new ThfLanguageService(); }, token: ThfLanguageService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfLoadingOverlayLiteralsDefault = {
    en: (/** @type {?} */ ({
        loading: 'Loading',
    })),
    es: (/** @type {?} */ ({
        loading: 'Cargando',
    })),
    pt: (/** @type {?} */ ({
        loading: 'Carregando',
    }))
};
/**
 *
 * \@description
 *
 * Este componente mostra ao usuário uma imagem de _loading_ e bloqueia a página inteira ou o container escolhido,
 * enquanto aguarda a resposta de alguma requisição.
 */
class ThfLoadingOverlayBaseComponent {
    /**
     * @param {?} languageService
     */
    constructor(languageService) {
        this.languageService = languageService;
        this._screenLock = false;
        if (!this.text) {
            this.text = this.getTextDefault();
        }
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define se o _overlay_ será aplicado a um container ou a página inteira.
     *
     * \@default `false`
     * @param {?} screenLock
     * @return {?}
     */
    set screenLock(screenLock) {
        this._screenLock = convertToBoolean(screenLock);
    }
    /**
     * @return {?}
     */
    get screenLock() {
        return this._screenLock;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Texto a ser exibido no componente.
     *
     * > O valor padrão será traduzido acordo com o idioma configurado no [**ThfI18n**](/documentation/thf-i18n) ou navegador.
     *
     * \@default `Carregando`
     * @param {?} value
     * @return {?}
     */
    set text(value) {
        this._text = value || this.getTextDefault();
    }
    /**
     * @return {?}
     */
    get text() {
        return this._text;
    }
    /**
     * @private
     * @return {?}
     */
    getTextDefault() {
        /** @type {?} */
        const language = this.languageService.getShortLanguage();
        return thfLoadingOverlayLiteralsDefault[language].loading;
    }
}
ThfLoadingOverlayBaseComponent.propDecorators = {
    screenLock: [{ type: Input, args: ['t-screen-lock',] }],
    text: [{ type: Input, args: ['t-text',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@docsExtends ThfLoadingOverlayBaseComponent
 *
 * \@example
 *
 * <example name="thf-loading-overlay-basic" title="Totvs Loading Overlay Basic">
 *  <file name="sample-thf-loading-overlay-basic/sample-thf-loading-overlay-basic.component.html"> </file>
 *  <file name="sample-thf-loading-overlay-basic/sample-thf-loading-overlay-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-loading-overlay-labs" title="Totvs Loading Overlay Labs">
 *  <file name="sample-thf-loading-overlay-labs/sample-thf-loading-overlay-labs.component.html"> </file>
 *  <file name="sample-thf-loading-overlay-labs/sample-thf-loading-overlay-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-loading-overlay-connection-test" title="Totvs Loading Overlay - Connection Test">
 *  <file name="sample-thf-loading-overlay-connection-test/sample-thf-loading-overlay-connection-test.component.html"> </file>
 *  <file name="sample-thf-loading-overlay-connection-test/sample-thf-loading-overlay-connection-test.component.ts"> </file>
 * </example>
 */
class ThfLoadingOverlayComponent extends ThfLoadingOverlayBaseComponent {
    /**
     * @param {?} changeDetector
     * @param {?} languageService
     */
    constructor(changeDetector, languageService) {
        super(languageService);
        this.changeDetector = changeDetector;
    }
}
ThfLoadingOverlayComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-loading-overlay',
                template: "<div\n  [class.thf-overlay-absolute]=\"!screenLock\"\n  [class.thf-overlay-fixed]=\"screenLock\">\n  <thf-loading class=\"thf-loading-overlay-content\" [t-text]=\"text\"></thf-loading>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfLoadingOverlayComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ThfLanguageService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do serviço `thf-language`.
 */
class ThfLanguageModule {
}
ThfLanguageModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    ThfLanguageService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Este componente tem o objetivo de mostrar visualmente aos usuários que a aplicação está processando
 * ou aguardando a resposta de alguma requisição.
 */
class ThfLoadingBaseComponent {
    constructor() {
        /**
         * Texto a ser exibido no componente.
         */
        this.text = 'Carregando';
    }
}
ThfLoadingBaseComponent.propDecorators = {
    text: [{ type: Input, args: ['t-text',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfLoadingBaseComponent
 */
class ThfLoadingComponent extends ThfLoadingBaseComponent {
}
ThfLoadingComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-loading',
                template: "<div class=\"thf-loading\">\n  <span class=\"thf-loading-icon\"></span>\n  <span class=\"thf-loading-label thf-text-ellipsis\" *ngIf=\"text\">{{text}}</span>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 *
 * Módulo do componente thf-loading-overlay.
 */
class ThfLoadingModule {
}
ThfLoadingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfLanguageModule
                ],
                declarations: [
                    ThfLoadingComponent,
                    ThfLoadingOverlayComponent
                ],
                exports: [
                    ThfLoadingComponent,
                    ThfLoadingOverlayComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-modal` é utilizado para incluir conteúdos rápidos e informativos.
 *
 * No cabeçalho do componente é possível definir um título e como também permite ocultar o ícone de fechamento da modal.
 *
 * Em seu corpo é possível definir um conteúdo informativo, podendo utilizar componentes como por exemplo `thf-chart`,
 * `thf-table` e os demais componentes do THF.
 *
 * No rodapé encontram-se os botões de ação primária e secundária, no qual permitem definir uma ação e um rótulo, bem como
 * definir um estado de carregando e / ou desabilitado. Também é possível definir o botão com o tipo *danger*.
 *
 * > É possível fechar a modal através da tecla *ESC*, quando a propriedade `t-hide-close` não estiver habilitada.
 */
class ThfModalBaseComponent {
    constructor() {
        this._hideClose = false;
        this._size = 'md';
        /**
         * Define o fechamento da modal ao clicar fora da mesma.
         * Informe o valor `true` para ativar o fechamento ao clicar fora da modal.
         */
        this.clickOut = false;
        // Controla se a modal fica oculto ou visível, por padrão é oculto
        this.isHidden = true;
        // Event emmiter para quando a modal é fechada pelo 'X'.
        this.onXClosed = new EventEmitter();
    }
    /**
     * Define o tamanho da modal.
     *
     * Valores válidos:
     *  - `sm` (pequeno)
     *  - `md` (médio)
     *  - `lg` (grande)
     *  - `xl` (extra grande)
     *  - `auto` (automático)
     *
     * > Quando informado `auto` a modal calculará automaticamente seu tamanho baseado em seu conteúdo.
     * Caso não seja informado um valor, a modal terá o tamanho definido como `md`.
     *
     * > Todas as opções de tamanho possuem uma largura máxima de **768px**.
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        /** @type {?} */
        const sizes = ['sm', 'md', 'lg', 'xl', 'auto'];
        this._size = sizes.indexOf(value) > -1 ? value : 'md';
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set setClickOut(value) {
        this.clickOut = (value === '') ? false : convertToBoolean(value);
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Oculta o ícone de fechar do cabeçalho da modal.
     *
     * > Caso a propriedade estiver habilitada, não será possível fechar a modal através da tecla *ESC*.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set hideClose(value) {
        this._hideClose = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get hideClose() {
        return this._hideClose;
    }
    /**
     * Função para fechar a modal.
     * @param {?=} xClosed
     * @return {?}
     */
    close(xClosed = false) {
        this.isHidden = true;
        if (xClosed) {
            this.onXClosed.emit(xClosed);
        }
    }
    /**
     * Função para abrir a modal.
     * @return {?}
     */
    open() {
        this.validPrimaryAction();
        this.isHidden = false;
    }
    /**
     * @return {?}
     */
    validPrimaryAction() {
        if (!this.primaryAction) {
            this.primaryAction = {
                action: (/**
                 * @return {?}
                 */
                () => this.close()),
                label: 'Ok',
            };
        }
        if (!this.primaryAction['action']) {
            this.primaryAction['action'] = (/**
             * @return {?}
             */
            () => this.close());
        }
        if (!this.primaryAction['label']) {
            this.primaryAction['label'] = 'Ok';
        }
    }
}
ThfModalBaseComponent.propDecorators = {
    title: [{ type: Input, args: ['t-title',] }],
    primaryAction: [{ type: Input, args: ['t-primary-action',] }],
    secondaryAction: [{ type: Input, args: ['t-secondary-action',] }],
    size: [{ type: Input, args: ['t-size',] }],
    setClickOut: [{ type: Input, args: ['t-click-out',] }],
    hideClose: [{ type: Input, args: ['t-hide-close',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfModalService {
}
ThfModalService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfModalBaseComponent
 *
 * \@example
 *
 * <example name="thf-modal-basic" title="Totvs Modal Basic">
 *  <file name="sample-thf-modal-basic/sample-thf-modal-basic.component.html"> </file>
 *  <file name="sample-thf-modal-basic/sample-thf-modal-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-modal-labs" title="Totvs Modal Labs">
 *  <file name="sample-thf-modal-labs/sample-thf-modal-labs.component.html"> </file>
 *  <file name="sample-thf-modal-labs/sample-thf-modal-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-modal-fruits-salad" title="Totvs Modal - Fruits Salad">
 *  <file name="sample-thf-modal-fruits-salad/sample-thf-modal-fruits-salad.component.html"> </file>
 *  <file name="sample-thf-modal-fruits-salad/sample-thf-modal-fruits-salad.component.ts"> </file>
 * </example>
 */
class ThfModalComponent extends ThfModalBaseComponent {
    /**
     * @param {?} thfModalService
     * @param {?} renderer
     * @param {?} changeDetector
     */
    constructor(thfModalService, renderer, changeDetector) {
        super();
        this.thfModalService = thfModalService;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        this.focusableElements = 'input, select, textarea, button:not([disabled]), a';
        this.id = v4();
    }
    /**
     * @param {?=} xClosed
     * @return {?}
     */
    close(xClosed = false) {
        this.thfModalService.modalActive = undefined;
        super.close(xClosed);
        this.removeEventListeners();
        if (this.sourceElement) {
            this.sourceElement.focus();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeModalOnEscapeKey(event) {
        if (!this.hideClose) {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        }
    }
    /**
     * @return {?}
     */
    getPrimaryActionButtonType() {
        return this.primaryAction.danger ? 'danger' : 'primary';
    }
    /**
     * @return {?}
     */
    getSecondaryActionButtonType() {
        return this.secondaryAction && this.secondaryAction.danger && !this.primaryAction.danger ? 'danger' : 'default';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClickOut(event) {
        if (this.clickOut && !this.modalContent.nativeElement.contains(event.target)) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    open() {
        this.sourceElement = document.activeElement;
        super.open();
        this.handleFocus();
    }
    /**
     * @private
     * @return {?}
     */
    handleFocus() {
        this.thfModalService.modalActive = this.id;
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.modalContent) {
                this.initFocus();
                document.addEventListener('focus', this.focusFunction, true);
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    initFocus() {
        this.focusFunction = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.thfModalService.modalActive = this.thfModalService.modalActive || this.id;
            /** @type {?} */
            const modalElement = this.modalContent.nativeElement;
            if (!modalElement.contains(event.target) && this.thfModalService.modalActive === this.id) {
                event.stopPropagation();
                this.firstElement.focus();
            }
        });
        this.setFirstElement();
        if (this.hideClose) {
            this.firstElement.focus();
        }
        else {
            /** @type {?} */
            const firstFieldElement = this.modalContent.nativeElement.querySelectorAll(this.focusableElements)[1] ||
                this.modalContent.nativeElement;
            firstFieldElement.focus();
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeEventListeners() {
        document.removeEventListener('focus', this.focusFunction, true);
    }
    /**
     * @private
     * @return {?}
     */
    setFirstElement() {
        this.firstElement = this.modalContent.nativeElement.querySelector(this.focusableElements) || this.modalContent.nativeElement;
    }
}
ThfModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-modal',
                template: "<div *ngIf=\"!isHidden\"\n  class=\"thf-modal\"\n  tabindex=\"0\"\n  (keydown.esc)=\"closeModalOnEscapeKey($event)\">\n\n  <div class=\"thf-modal-overlay\">\n    <div class=\"thf-modal-container thf-pb-2 thf-pt-2\" (click)=\"onClickOut($event)\">\n\n      <div class=\"thf-modal-vertical-align\">\n        <div #modalContent\n          class=\"thf-modal-content thf-modal-{{ size }}\"\n          tabindex=\"-1\">\n\n          <div class=\"thf-modal-header\">\n            <div class=\"thf-modal-title thf-text-ellipsis\">\n              {{ title }}\n            </div>\n\n            <a *ngIf=\"!hideClose\"\n              class=\"thf-modal-header-close-button\"\n              tabindex=\"0\"\n              (click)=\"close(true)\">\n              <span class=\"thf-icon thf-icon-close\"></span>\n            </a>\n          </div>\n\n          <div class=\"thf-modal-body\">\n            <ng-content></ng-content>\n          </div>\n\n          <div class=\"thf-modal-footer\">\n            <thf-button *ngIf=\"secondaryAction\"\n              [t-disabled]=\"secondaryAction.disabled\"\n              [t-label]=\"secondaryAction.label\"\n              [t-loading]=\"secondaryAction.loading\"\n              [t-type]=\"getSecondaryActionButtonType()\"\n              (t-click)=\"secondaryAction.action()\">\n            </thf-button>\n\n            <thf-button\n              class=\"thf-button-modal-first-action\"\n              [t-disabled]=\"primaryAction.disabled\"\n              [t-label]=\"primaryAction.label\"\n              [t-loading]=\"primaryAction.loading\"\n              [t-type]=\"getPrimaryActionButtonType()\"\n              (t-click)=\"primaryAction.action()\">\n            </thf-button>\n          </div>\n\n        </div>\n      </div>\n\n    </div>\n  </div>\n</div>\n\n"
            }] }
];
/** @nocollapse */
ThfModalComponent.ctorParameters = () => [
    { type: ThfModalService },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
ThfModalComponent.propDecorators = {
    modalContent: [{ type: ViewChild, args: ['modalContent', { read: ElementRef, static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-modal
 */
class ThfModalModule {
}
ThfModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfButtonModule
                ],
                declarations: [
                    ThfModalComponent
                ],
                exports: [ThfModalComponent],
                providers: [ThfModalService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Pipe responsável por apresentar um horário baseado no formato de entrada definido na API da Totvs.
 */
class ThfTimePipe {
    /**
     * @param {?} time
     * @param {?=} format
     * @return {?}
     */
    transform(time, format) {
        /** @type {?} */
        const hourRegex = /^(([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9][\.]?([0-9]{1,6})?$/g;
        if (isTypeof(time, 'string') && hourRegex.test(time)) {
            /** @type {?} */
            const amountOfF = format ? format.lastIndexOf('f') - format.indexOf('f') + 1 : 0;
            /** @type {?} */
            const miliseconds = this.addDotMiliseconds(time.substring(9, 9 + amountOfF), amountOfF);
            /** @type {?} */
            const formatMiliseconds = this.getFormatMiliseconds(amountOfF);
            return this.formatValue(time, format, formatMiliseconds, miliseconds);
        }
        return null;
    }
    /**
     * @private
     * @param {?} miliseconds
     * @param {?} amountOfF
     * @return {?}
     */
    addDotMiliseconds(miliseconds, amountOfF) {
        if (miliseconds && amountOfF) {
            miliseconds = '.' + miliseconds;
        }
        return miliseconds;
    }
    /**
     * @private
     * @param {?} time
     * @param {?} format
     * @param {?} formatMiliseconds
     * @param {?} miliseconds
     * @return {?}
     */
    formatValue(time, format, formatMiliseconds, miliseconds) {
        if (time && format) {
            /** @type {?} */
            const hour = time.substring(0, 2);
            /** @type {?} */
            const minutes = time.substring(3, 5);
            /** @type {?} */
            const seconds = time.substring(6, 8);
            format = format.replace('HH', hour);
            format = format.replace('mm', minutes);
            format = format.replace('ss', seconds);
            format = format.replace(`.${formatMiliseconds}`, miliseconds);
            return format;
        }
        else {
            return time;
        }
    }
    /**
     * @private
     * @param {?} amountOfF
     * @return {?}
     */
    getFormatMiliseconds(amountOfF) {
        /** @type {?} */
        let formatMiliseconds = '';
        for (let i = 0; i < amountOfF; i++) {
            formatMiliseconds += 'f';
        }
        return formatMiliseconds;
    }
}
ThfTimePipe.decorators = [
    { type: Pipe, args: [{
                name: 'thf_time'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do pipe `thf-time`.
 */
class ThfTimeModule {
}
ThfTimeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ThfTimePipe
                ],
                imports: [],
                exports: [
                    ThfTimePipe
                ],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por exibir ícones nas colunas.
 */
class ThfTableColumnIconComponent {
    /**
     * Lista de um ou mais ícones que serão exibidos em sua respectiva coluna.
     * @param {?} value
     * @return {?}
     */
    set icons(value) {
        this._icons = this.convertToColumnIcon(value);
    }
    /**
     * @return {?}
     */
    get icons() {
        return this._icons;
    }
    /**
     * @param {?} iconColumn
     * @return {?}
     */
    checkDisabled(iconColumn) {
        return iconColumn.disabled ? iconColumn.disabled(this.row) : false;
    }
    /**
     * @param {?} columnIcon
     * @return {?}
     */
    getIconColorClass(columnIcon) {
        /** @type {?} */
        const color = this.getIconColor(columnIcon) || this.getIconColor(this.column);
        return color ? `thf-text-${color}` : '';
    }
    /**
     * @param {?} iconColumn
     * @return {?}
     */
    onIconClick(iconColumn) {
        /** @type {?} */
        const isAbleAction = !this.checkDisabled(iconColumn);
        if (iconColumn.action && isAbleAction) {
            iconColumn.action(this.row, iconColumn);
        }
        else if (this.column.action && isAbleAction) {
            this.column.action(this.row, iconColumn || this.column);
        }
    }
    /**
     * @param {?} text
     * @param {?} iconColumn
     * @return {?}
     */
    tooltipMouseEnter(text, iconColumn) {
        if (this.checkDisabled(iconColumn)) {
            this.tooltipText = undefined;
        }
        else {
            this.tooltipText = text;
        }
    }
    /**
     * @return {?}
     */
    tooltipMouseLeave() {
        this.tooltipText = undefined;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    convertToColumnIcon(value) {
        if (value instanceof Array) {
            return value.map((/**
             * @param {?} val
             * @return {?}
             */
            val => {
                return typeof val === 'string' ? { value: val } : val;
            }));
        }
        if (typeof value === 'string') {
            return [{ value }];
        }
        return [];
    }
    /**
     * @private
     * @param {?} column
     * @return {?}
     */
    getIconColor(column) {
        return typeof column.color === 'function' ? column.color(this.row, column) : column.color;
    }
}
ThfTableColumnIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table-column-icon',
                template: "<ng-container *ngFor=\"let iconColumn of icons\">\n  <span class=\"thf-icon\"\n    [class.thf-clickable]=\"!checkDisabled(iconColumn) && iconColumn.action || column.action \"\n    [ngClass]=\"[checkDisabled(iconColumn) ? 'thf-table-icon-disabled' : getIconColorClass(iconColumn), iconColumn.icon || iconColumn.value]\"\n    [t-tooltip]=\"tooltipText\"\n    (click)=\"onIconClick(iconColumn)\"\n    (mouseenter)=\"tooltipMouseEnter(iconColumn.tooltip, iconColumn)\"\n    (mouseleave)=\"tooltipMouseLeave()\">\n  </span>\n</ng-container>\n"
            }] }
];
ThfTableColumnIconComponent.propDecorators = {
    column: [{ type: Input, args: ['t-column',] }],
    icons: [{ type: Input, args: ['t-icons',] }],
    row: [{ type: Input, args: ['t-row',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfColorPaletteEnum = {
    /** #0c9abe */
    Color01: 'color-01',
    /** #2c85c8 */
    Color02: 'color-02',
    /** #2c43c8 */
    Color03: 'color-03',
    /** #5843c8 */
    Color04: 'color-04',
    /** #ab43c8 */
    Color05: 'color-05',
    /** #ab4391 */
    Color06: 'color-06',
    /** #c64840 */
    Color07: 'color-07',
    /** #ea9b3e */
    Color08: 'color-08',
    /** #abc249 */
    Color09: 'color-09',
    /** #56b96b */
    Color10: 'color-10',
    /** #00b28e */
    Color11: 'color-11',
    /** #06a6a5 */
    Color12: 'color-12',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfColorPaletteService {
    /**
     * @param {?} value
     * @return {?}
     */
    getColor(value) {
        return ((/** @type {?} */ (Object))).values(ThfColorPaletteEnum).includes(value.color) ?
            value.color : this.getColorFromType(value.type || value.color);
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    getColorFromType(type) {
        switch (type) {
            case 'danger':
                return ThfColorPaletteEnum.Color07;
            case 'success':
                return ThfColorPaletteEnum.Color11;
            case 'warning':
                return ThfColorPaletteEnum.Color08;
            default:
                return ThfColorPaletteEnum.Color01;
        }
    }
}
ThfColorPaletteService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação da representação da legenda, em formato de texto .
 */
class ThfTableColumnLabelComponent {
    /**
     * @param {?} thfColorPaletteService
     */
    constructor(thfColorPaletteService) {
        this.thfColorPaletteService = thfColorPaletteService;
    }
    /**
     * Objeto com os dados do label
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value) {
            value.color = this.thfColorPaletteService.getColor(value);
        }
        this._value = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
}
ThfTableColumnLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table-column-label',
                template: "<span\n  [class]=\"'thf-table-column-label thf-' + value?.color\">\n  {{ value?.label }}\n</span>\n"
            }] }
];
/** @nocollapse */
ThfTableColumnLabelComponent.ctorParameters = () => [
    { type: ThfColorPaletteService }
];
ThfTableColumnLabelComponent.propDecorators = {
    value: [{ type: Input, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por exibir link nas colunas.
 */
class ThfTableColumnLinkComponent {
    /**
     * @return {?}
     */
    get type() {
        if (this.disabled) {
            return 'disabled';
        }
        if (this.action) {
            return 'action';
        }
        if (isExternalLink(this.link)) {
            return 'externalLink';
        }
        return 'internalLink';
    }
}
ThfTableColumnLinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table-column-link',
                template: "<ng-container [ngSwitch]=\"type\">\n  <p *ngSwitchCase=\"'disabled'\" class=\"thf-table-link-disabled\">{{ value }}</p>\n  <a *ngSwitchCase=\"'action'\" class=\"thf-table-link\" (click)=\"action(value, row)\">{{ value }}</a>\n  <a *ngSwitchCase=\"'externalLink'\" class=\"thf-table-link\" [href]=\"link\" target=\"_blank\">{{ value }}</a>\n  <a *ngSwitchCase=\"'internalLink'\" class=\"thf-table-link\" [routerLink]=\"link\">{{ value }}</a>\n</ng-container>\n"
            }] }
];
ThfTableColumnLinkComponent.propDecorators = {
    action: [{ type: Input, args: ['t-action',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    link: [{ type: Input, args: ['t-link',] }],
    row: [{ type: Input, args: ['t-row',] }],
    value: [{ type: Input, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfTableContainer = ['border', 'shadow'];
/** @type {?} */
const thfTableContainerDefault = 'border';
/** @type {?} */
const thfTableLiteralsDefault = {
    en: (/** @type {?} */ ({
        noColumns: 'Columns are not defined',
        noData: 'No data found',
        loadingData: 'Loading',
        loadMoreData: 'Load more data',
        seeCompleteSubtitle: 'See complete subtitle',
        completeSubtitle: 'Complete subtitle'
    })),
    es: (/** @type {?} */ ({
        noColumns: 'Columnas no definidas',
        noData: 'Datos no encontrados',
        loadingData: 'Cargando datos',
        loadMoreData: 'Cargar más resultados',
        seeCompleteSubtitle: 'Ver subtitulo completo',
        completeSubtitle: 'Subtitulo completo'
    })),
    pt: (/** @type {?} */ ({
        noColumns: 'Nenhuma definição de colunas',
        noData: 'Nenhum dado encontrado',
        loadingData: 'Carregando',
        loadMoreData: 'Carregar mais resultados',
        seeCompleteSubtitle: 'Ver legenda completa',
        completeSubtitle: 'Legenda completa'
    }))
};
/**
 * \@description
 *
 * Este componente de tabela é utilizado para exibição de listas, com diferentes tipos de dados que podem ser texto,
 * data, horário e número com formato personalizado.
 *
 * É possivel criar uma tabela com ordenação de dados, linhas com detalhes, coluna de seleção de linhas,
 * coluna com ações e também carregamento por demanda com o botão "Carregar mais resultados".
 *
 * Também existe a possibilidade de utilizar _template_ para os detalhes das linhas,
 * veja mais em **[t-table-row-template](/documentation/thf-table-row-template)**.
 *
 * Quando a largura de todas as colunas for definida, caso o tamanho total delas seja maior que a tabela, será exibido um scroll horizontal.
 *
 * @abstract
 */
class ThfTableBaseComponent {
    /**
     * @param {?} thfDate
     */
    constructor(thfDate) {
        this.thfDate = thfDate;
        this._actions = [];
        this._columns = [];
        this._hideDetail = false;
        this._hideTextOverflow = false;
        this._loading = false;
        /**
         * Ação executada quando todas as linhas são selecionadas por meio do *checkbox* que seleciona todas as linhas.
         */
        this.allSelected = new EventEmitter();
        /**
         * Ação executada quando a seleção das linhas é desmarcada por meio do *checkbox* que seleciona todas as linhas.
         */
        this.allUnselected = new EventEmitter();
        /**
         * Ação executada ao selecionar uma linha do `thf-table`.
         */
        this.selected = new EventEmitter();
        /**
         * Recebe uma ação de clique para o botão "Carregar mais resultados", caso nenhuma ação for definida o mesmo
         * não é visível.
         */
        this.showMore = new EventEmitter();
        /**
         * Ação executada ao desmarcar a seleção de uma linha do `thf-table`.
         */
        this.unselected = new EventEmitter();
        this.selectAll = false;
        this.sortedColumn = { property: (/** @type {?} */ (null)), ascending: true };
    }
    /**
     * \@description
     *
     * Lista de itens da tabela.
     * > Se falso, será inicializado como um *array* vazio.
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._items = Array.isArray(items) ? items : [];
        // when haven't items, selectAll should be unchecked.
        if (!this.hasItems()) {
            this.selectAll = false;
        }
        else if (!this.hasColumns()) {
            this.columns = this.getDefaultColumns(items[0]);
        }
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Lista das colunas da tabela, deve receber um *array* de objetos que implementam a interface `ThfTableColumn`.
     * Por padrão receberá como valor a primeira coluna da lista de itens da tabela.
     * > Caso não encontre valor, a mensagem 'Nenhuma definição de colunas' será exibida.
     *
     * @param {?} columns
     * @return {?}
     */
    set columns(columns) {
        this._columns = columns || [];
        if (this._columns.length) {
            this.setColumnLink();
            this.calculateWidthHeaders();
        }
        else if (this.hasItems()) {
            this._columns = this.getDefaultColumns(this.items[0]);
        }
    }
    /**
     * @return {?}
     */
    get columns() {
        return this._columns;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Adiciona um contorno arredondado ao `thf-table`, as opções são:
     * - `border`: com bordas/linhas.
     * - `shadow`: com sombras.
     *
     * \@default `border`
     * @param {?} value
     * @return {?}
     */
    set container(value) {
        this._container = thfTableContainer.includes(value) ? value : thfTableContainerDefault;
        this.showContainer(this._container);
    }
    /**
     * @return {?}
     */
    get container() {
        return this._container;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Se verdadeiro, habilita a quebra de texto ao transborda-lo dentro de qualquer coluna.
     * > Quando ocorrer a quebra de texto, ao passar o mouse no conteúdo da célula,
     * o mesmo será exibido através do [`thf-tooltip`](/documentation/thf-tooltip).
     * @param {?} hideTextOverflow
     * @return {?}
     */
    set hideTextOverflow(hideTextOverflow) {
        this._hideTextOverflow = convertToBoolean(hideTextOverflow);
    }
    /**
     * @return {?}
     */
    get hideTextOverflow() {
        return this._hideTextOverflow;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a altura da tabela em *pixels* e fixa o cabeçalho.
     * @param {?} height
     * @return {?}
     */
    set height(height) {
        this._height = height;
        this.calculateHeightTableContainer(height);
        this.calculateWidthHeaders();
    }
    /**
     * @return {?}
     */
    get height() {
        return this._height;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Habilita a visualização da lista de detalhes de cada linha da coluna.
     *
     * \@default `false`
     * @param {?} hideDetail
     * @return {?}
     */
    set hideDetail(hideDetail) {
        this._hideDetail = hideDetail != null && hideDetail.toString() === '' ? true : convertToBoolean(hideDetail);
        this.calculateWidthHeaders();
    }
    /**
     * @return {?}
     */
    get hideDetail() {
        return this._hideDetail;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-table`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfTableLiterals = {
     *    loadMoreData: 'Buscar mais dados',
     *    loadingData: 'Processando',
     *    noColumns: 'Sem colunas',
     *    noData: 'Sem dados',
     *    seeCompleteSubtitle: 'Mostrar legenda completa',
     *    completeSubtitle: 'Todas legendas'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfTableLiterals = {
     *    noData: 'Sem dados'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-table
     *   [t-literals]="customLiterals">
     * </thf-table>
     * ```
     *
     *  > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfTableLiteralsDefault[thfLocaleDefault], thfTableLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfTableLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfTableLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Bloqueia interação do usuário com os dados da _table_, apresentando um _loading_ ao centro da mesma.
     *
     * \@default `false`
     * @param {?} loading
     * @return {?}
     */
    set loading(loading) {
        this._loading = convertToBoolean(loading);
        this.calculateWidthHeaders();
    }
    /**
     * @return {?}
     */
    get loading() {
        return this._loading;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Habilita na primeira coluna a opção de selecionar linhas,
     * todos os itens da lista possuem a propriedade dinâmica `$selected` para identificar se a linha está selecionada.
     * > Exemplo: `item.$selected` ou `item['$selected']`.
     * > Os itens filhos possuem comportamento independente do item pai.
     *
     * \@default `false`
     * @param {?} checkbox
     * @return {?}
     */
    set checkbox(checkbox) {
        this._checkbox = (/** @type {?} */ (checkbox)) === '' ? true : convertToBoolean(checkbox);
        this.calculateWidthHeaders();
    }
    /**
     * @return {?}
     */
    get checkbox() {
        return this._checkbox;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define uma lista de ações.
     *
     * Quando houver apenas uma ação definida ela será exibida diretamente na coluna, caso contrário, o componente
     * se encarrega de agrupá-las exibindo o ícone [**thf-icon-more**](/guides/icons) que listará as ações ao ser clicado.
     *
     * **A coluna de ações não será exibida quando:**
     *  - a lista conter valores inválidos ou indefinidos.
     *  - tenha uma única ação e a mesma não for visível.
     * @param {?} actions
     * @return {?}
     */
    set actions(actions) {
        this._actions = actions;
        this.calculateWidthHeaders();
    }
    /**
     * @return {?}
     */
    get actions() {
        return this._actions;
    }
    /**
     * @param {?} sort
     * @return {?}
     */
    set setSort(sort) {
        this.sort = sort === '' ? false : convertToBoolean(sort);
    }
    /**
     * @param {?} showMoreDisabled
     * @return {?}
     */
    set setShowMoreDisabled(showMoreDisabled) {
        this.showMoreDisabled = showMoreDisabled === '' ? false : convertToBoolean(showMoreDisabled);
    }
    /**
     * @param {?} striped
     * @return {?}
     */
    set setStriped(striped) {
        this.striped = striped === '' ? false : convertToBoolean(striped);
    }
    /**
     * @param {?} hideSelectAll
     * @return {?}
     */
    set setHideSelectAll(hideSelectAll) {
        this.hideSelectAll = hideSelectAll === '' ? false : convertToBoolean(hideSelectAll);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set setSingleSelect(value) {
        this.singleSelect = value === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.singleSelect || this.hideSelectAll) {
            this.selectAll = false;
            this.hideSelectAll = true;
        }
    }
    /**
     * @return {?}
     */
    selectAllRows() {
        if (!this.hideSelectAll) {
            this.selectAll = !this.selectAll;
            this.items.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                item.$selected = this.selectAll;
            }));
            this.emitSelectAllEvents(this.selectAll, this.items);
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    selectRow(row) {
        row.$selected = !row.$selected;
        this.emitSelectEvents(row);
        this.configAfterSelectRow(this.items, row);
    }
    /**
     * @param {?} row
     * @return {?}
     */
    selectDetailRow(row) {
        this.emitSelectEvents(row);
    }
    // Colunas que são inseridas no <head> da tabela
    /**
     * @return {?}
     */
    getMainColumns() {
        /** @type {?} */
        const typesValid = ['string', 'number', 'boolean', 'date', 'time', 'dateTime', 'currency', 'subtitle', 'link', 'label', 'icon'];
        return this.columns.filter((/**
         * @param {?} col
         * @return {?}
         */
        col => !col.type || typesValid.includes(col.type)));
    }
    // Retorna a coluna da lista de colunas que é do tipo detail
    /**
     * @return {?}
     */
    getColumnMasterDetail() {
        return this.columns.find((/**
         * @param {?} col
         * @return {?}
         */
        col => col.type === 'detail'));
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    getClassColor(row, column) {
        return column.color ? `thf-text-${this.getColumnColor(row, column)}` : '';
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    getColumnColor(row, column) {
        /** @type {?} */
        const columnColor = column.color;
        return isTypeof(columnColor, 'function') ? columnColor(row, column.property) : columnColor;
    }
    // Retorna as colunas com status
    /**
     * @return {?}
     */
    getSubtitleColumns() {
        return this.columns.filter((/**
         * @param {?} col
         * @return {?}
         */
        col => col.type === 'subtitle'));
    }
    // Retorna as colunas com ícones
    /**
     * @return {?}
     */
    getIconColumns() {
        return this.columns.filter((/**
         * @param {?} col
         * @return {?}
         */
        col => col.type === 'icon'));
    }
    // Retorna o nome da coluna do tipo detail
    /**
     * @return {?}
     */
    getNameColumnDetail() {
        /** @type {?} */
        const detail = this.getColumnMasterDetail();
        return detail ? detail.property : null;
    }
    /**
     * Retorna as linhas do `thf-table` que estão selecionadas.
     * @return {?}
     */
    getSelectedRows() {
        return this.items.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item.$selected));
    }
    /**
     * Retorna as linhas do `thf-table` que não estão selecionadas.
     * @return {?}
     */
    getUnselectedRows() {
        return this.items.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => !item.$selected));
    }
    /**
     * @return {?}
     */
    hasColumns() {
        return this.columns && this.columns.length > 0;
    }
    /**
     * @return {?}
     */
    hasItems() {
        return this.items && this.items.length > 0;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    toggleRowAction(row) {
        /** @type {?} */
        const toggleShowAction = row.$showAction;
        this.items.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            if (item.$showAction) {
                item.$showAction = false;
            }
        }));
        row.$showAction = !toggleShowAction;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    sortColumn(column) {
        if (!this.sort || column.type === 'detail') {
            return;
        }
        this.sortedColumn.ascending = this.sortedColumn.property === column ? !this.sortedColumn.ascending : true;
        this.sortArray(column, this.sortedColumn.ascending);
        this.sortedColumn.property = column;
    }
    /**
     * @param {?} column
     * @param {?} ascending
     * @return {?}
     */
    sortArray(column, ascending) {
        this.items.sort((/**
         * @param {?} leftSide
         * @param {?} rightSide
         * @return {?}
         */
        (leftSide, rightSide) => {
            if (column.type === 'date' || column.type === 'dateTime') {
                return this.thfDate.sortDate(leftSide[column.property], rightSide[column.property], ascending);
            }
            else {
                return sortValues(leftSide[column.property], rightSide[column.property], ascending);
            }
        }));
    }
    /**
     * @return {?}
     */
    onShowMore() {
        this.showMore.emit(null);
    }
    /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    getDefaultColumns(item) {
        /** @type {?} */
        const keys = Object.keys(item);
        return keys.filter((/**
         * @param {?} key
         * @return {?}
         */
        key => (typeof item[key] !== 'object'))).map((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            return { label: capitalizeFirstLetter(key), property: key };
        }));
    }
    /**
     * @private
     * @param {?} rows
     * @param {?} row
     * @return {?}
     */
    configAfterSelectRow(rows, row) {
        if (this.singleSelect) {
            this.unselectOtherRows(rows, row);
        }
        else if (!this.hideSelectAll) {
            this.selectAll = this.isEverySelected(rows);
        }
    }
    /**
     * @private
     * @param {?} selectAll
     * @param {?} rows
     * @return {?}
     */
    emitSelectAllEvents(selectAll, rows) {
        selectAll ? this.allSelected.emit(rows) : this.allUnselected.emit(rows);
    }
    /**
     * @private
     * @param {?} row
     * @return {?}
     */
    emitSelectEvents(row) {
        row.$selected ? this.selected.emit(row) : this.unselected.emit(row);
    }
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    isEverySelected(items) {
        /** @type {?} */
        const someCheckedOrIndeterminate = (/**
         * @param {?} item
         * @return {?}
         */
        item => item.$selected || item.$selected === null);
        /** @type {?} */
        const everyChecked = (/**
         * @param {?} item
         * @return {?}
         */
        item => item.$selected);
        if (items.every(everyChecked)) {
            return true;
        }
        if (items.some(someCheckedOrIndeterminate)) {
            return null;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    setColumnLink() {
        this.columns.forEach((/**
         * @param {?} column
         * @return {?}
         */
        column => {
            if (column['type'] === 'link' && !column['link']) {
                column['link'] = 'link';
            }
        }));
    }
    /**
     * @private
     * @param {?} rows
     * @param {?} row
     * @return {?}
     */
    unselectOtherRows(rows, row) {
        rows.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            if (item !== row) {
                item.$selected = false;
            }
        }));
    }
}
ThfTableBaseComponent.propDecorators = {
    items: [{ type: Input, args: ['t-items',] }],
    columns: [{ type: Input, args: ['t-columns',] }],
    container: [{ type: Input, args: ['t-container',] }],
    hideTextOverflow: [{ type: Input, args: ['t-hide-text-overflow',] }],
    height: [{ type: Input, args: ['t-height',] }],
    hideDetail: [{ type: Input, args: ['t-hide-detail',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    loading: [{ type: Input, args: ['t-loading',] }],
    checkbox: [{ type: Input, args: ['t-checkbox',] }],
    actions: [{ type: Input, args: ['t-actions',] }],
    setSort: [{ type: Input, args: ['t-sort',] }],
    setShowMoreDisabled: [{ type: Input, args: ['t-show-more-disabled',] }],
    setStriped: [{ type: Input, args: ['t-striped',] }],
    setHideSelectAll: [{ type: Input, args: ['t-hide-select-all',] }],
    setSingleSelect: [{ type: Input, args: ['t-single-select',] }],
    allSelected: [{ type: Output, args: ['t-all-selected',] }],
    allUnselected: [{ type: Output, args: ['t-all-unselected',] }],
    selected: [{ type: Output, args: ['t-selected',] }],
    showMore: [{ type: Output, args: ['t-show-more',] }],
    unselected: [{ type: Output, args: ['t-unselected',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Esta diretiva permite que seja apresentada informações adicionais a respeito de uma determinada linha de
 * dados, de forma que possam ser exibidas e ocultadas através do botão de acionamento.
 *
 * > Quando utilizada, sobrepõe as funcionalidade básicas do *master-detail*.
 *
 * Em seu uso, deve-se utilizar como parâmetro a referência da _linha_ e/ou _índice_, sendo por padrão linha. Caso não seja declarado,
 * o componente não exibirá conteúdo.
 *  - Linha: `row` determina o item da linha corrente.
 *  - Índice: `rowIndex` determina o índice da linha corrente.
 *
 * Esta diretiva compõe-se de dois meios para uso, de forma explícita tal como em *syntax sugar*. Veja a seguir ambos, respectivamente:
 *
 * ```
 * ...
 * <thf-table
 *   [t-columns]="columns"
 *   [t-items]="items">
 *     <ng-template t-table-row-template let-rowItem let-i="rowIndex" [t-table-row-template-show]="isShow">
 *       <detail-row [row]="rowItem"></detail-row>
 *     </ng-template>
 * ...
 * ```
 *
 * ```
 * ...
 * <thf-table
 *   [t-columns]="columns"
 *   [t-items]="items">
 *     <div *t-table-row-template="let rowItem, let i=rowIndex">
 *       <detail-row [row]="rowItem"></detail-row>
 *     </div>
 * ...
 *
 * ```
 *
 * A diretiva **t-table-row-template**, possibilita também que determinada linha apresente ou não seu _template_. Para isto,
 * é necessário atribuir a referência da função que faz esta verificação, à propriedade `t-table-row-template-show`,
 * a mesma deve retornar um valor do tipo *boolean*. Veja o exemplo a seguir:
 *
 * ```
 * ...
 * \@Component({
 *    selector: 'app-root',
 *    templateUrl: `
 *      ...
 *      <thf-table
 *        [t-columns]="columns"
 *        [t-items]="items">
 *          <ng-template t-table-row-template let-rowItem let-i="rowIndex" [t-table-row-template-show]="isUndelivered">
 *            <detail-row [row]="rowItem"> </detail-row>
 *          </div>
 *      ...
 *    `
 * })
 * export class AppComponent {
 *    public dataTable = [{
 *      code: 1200,
 *      product: 'Rice',
 *      costumer: 'Supermarket 1',
 *      quantity: 3,
 *      status: 'delivered',
 *      license_plate: 'MDJD9191',
 *      batch_product: 18041822,
 *      driver: 'José Oliveira'
 *    }, {
 *      code: 1355,
 *      product: 'Bean',
 *      costumer: 'Supermarket 2',
 *      quantity: 1,
 *      status: 'transport',
 *      license_plate: 'XXA5454',
 *      batch_product: 18041821,
 *      driver: 'Francisco Pereira'
 *    }];
 *
 *    isUndelivered(row, index: number) {
 *      return row.status !== 'delivered';
 *    }
 * }
 * ```
 * > No exemplo acima, somente será disponibilizado os detalhes de informações nas linhas cujo o valor de `status`
 * não correspondam à *delivered*.
 */
class ThfTableRowTemplateDirective {
    // Necessário manter templateRef para o funcionamento do row template.
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ThfTableRowTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[t-table-row-template]'
            },] }
];
/** @nocollapse */
ThfTableRowTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
ThfTableRowTemplateDirective.propDecorators = {
    thfTableRowTemplateShow: [{ type: Input, args: ['t-table-row-template-show',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfTableBaseComponent
 *
 * \@example
 *
 * <example name="thf-table-basic" title="Totvs Table Basic">
 *  <file name="sample-thf-table-basic/sample-thf-table-basic.component.ts"> </file>
 *  <file name="sample-thf-table-basic/sample-thf-table-basic.component.html"> </file>
 * </example>
 *
 * <example name="thf-table-labs" title="Totvs Table Labs">
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.ts"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.html"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.po.ts"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.service.ts"> </file>
 * </example>
 *
 * <example name="thf-table-transport" title="Totvs Table - Transport">
 *  <file name="sample-thf-table-transport/sample-thf-table-transport.component.ts"> </file>
 *  <file name="sample-thf-table-transport/sample-thf-table-transport.component.html"> </file>
 *  <file name="sample-thf-table-transport/sample-thf-table-transport.service.ts"> </file>
 * </example>
 *
 * <example name="thf-table-airfare" title="Totvs Table - Airfare">
 *  <file name="sample-thf-table-airfare/sample-thf-table-airfare.component.ts"> </file>
 *  <file name="sample-thf-table-airfare/sample-thf-table-airfare.component.html"> </file>
 *  <file name="sample-thf-table-airfare/sample-thf-table-airfare.service.ts"> </file>
 * </example>
 *
 * <example name="thf-table-components" title="Totvs Table - Thf Field Components">
 *  <file name="sample-thf-table-components/sample-thf-table-components.component.ts"> </file>
 *  <file name="sample-thf-table-components/sample-thf-table-components.component.html"> </file>
 * </example>
 */
class ThfTableComponent extends ThfTableBaseComponent {
    /**
     * @param {?} thfDate
     * @param {?} differs
     * @param {?} viewRef
     * @param {?} renderer
     * @param {?} changeDetector
     * @param {?} decimalPipe
     * @param {?} router
     */
    constructor(thfDate, differs, viewRef, renderer, changeDetector, decimalPipe, router) {
        super(thfDate);
        this.changeDetector = changeDetector;
        this.decimalPipe = decimalPipe;
        this.router = router;
        this.tableOpacity = 0;
        this.initialized = false;
        this.visibleElement = false;
        this.parentRef = viewRef['_view']['component'];
        this.differ = differs.find([]).create(null);
        // TODO: #5550 ao remover este listener, no portal, quando as colunas forem fixas não sofrem
        // alteração de largura, pois o ngDoCheck não é executado.
        this.clickListener = renderer.listen('document', 'click', (/**
         * @return {?}
         */
        () => { }));
        this.resizeListener = renderer.listen('window', 'resize', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.debounceResize();
        }));
    }
    /**
     * @return {?}
     */
    get detailHideSelect() {
        /** @type {?} */
        const masterDetail = this.getColumnMasterDetail();
        return masterDetail && masterDetail.detail ? masterDetail.detail.hideSelect : false;
    }
    /**
     * @return {?}
     */
    get firstAction() {
        return this.visibleActions && this.visibleActions[0];
    }
    /**
     * @return {?}
     */
    get hasRowTemplate() {
        return !!this.tableRowTemplate;
    }
    /**
     * @return {?}
     */
    get visibleActions() {
        return this.actions && this.actions.filter((/**
         * @param {?} action
         * @return {?}
         */
        action => action.visible !== false));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initialized = true;
        if (!this.container) {
            this.hideContainer();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.checkChangesItems();
        this.verifyCalculateHeightTableContainer();
        // Permite que os cabeçalhos sejam calculados na primeira vez que o componente torna-se visível,
        // evitando com isso, problemas com Tabs ou Divs que iniciem escondidas.
        if (this.tableWrapperElement.nativeElement.offsetWidth && !this.visibleElement && this.initialized) {
            this.debounceResize();
            this.visibleElement = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    checkDisabled(row, column) {
        return column.disabled ? column.disabled(row) : false;
    }
    /**
     * @param {?} row
     * @param {?} tableAction
     * @return {?}
     */
    executeTableAction(row, tableAction) {
        if (!row.disabled && !this.validateTableAction(row, tableAction)) {
            tableAction.action.call(this.parentRef, row);
            this.toggleRowAction(row);
        }
    }
    /**
     * @return {?}
     */
    columnCountForMasterDetail() {
        return (this.getMainColumns().length + 1) + (this.actions.length > 0 ? 1 : 0) + (this.checkbox ? 1 : 0);
    }
    /**
     * @return {?}
     */
    columnCount() {
        return (this.getMainColumns().length +
            (this.actions.length > 0 ? 1 : 0) +
            (this.checkbox ? 1 : 0) +
            (!this.hideDetail && this.getColumnMasterDetail() !== undefined ? 1 : 0));
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    formatNumber(value, format) {
        if (!format) {
            return value;
        }
        return this.decimalPipe.transform(value, format);
    }
    /**
     * @param {?} row
     * @param {?} subtitleColumn
     * @return {?}
     */
    getSubtitleColumn(row, subtitleColumn) {
        return subtitleColumn.subtitles.find((/**
         * @param {?} subtitleItem
         * @return {?}
         */
        subtitleItem => row[subtitleColumn.property] === subtitleItem.value));
    }
    /**
     * @param {?} rowValue
     * @param {?} columnBoolean
     * @return {?}
     */
    getBooleanLabel(rowValue, columnBoolean) {
        if (rowValue || rowValue === false || rowValue === 0) {
            rowValue = convertToBoolean(rowValue);
            if (columnBoolean.boolean) {
                return rowValue ? columnBoolean.boolean.trueLabel || 'Sim' : columnBoolean.boolean.falseLabel || 'Não';
            }
            else {
                return rowValue ? 'Sim' : 'Não';
            }
        }
        return rowValue;
    }
    /**
     * @param {?} row
     * @param {?} columnIcon
     * @return {?}
     */
    getColumnIcons(row, columnIcon) {
        /** @type {?} */
        const columnValues = row[columnIcon.property];
        if (columnIcon.icons) {
            if (columnValues instanceof Array) {
                return this.mergeCustomIcons(columnValues, columnIcon.icons);
            }
            if (typeof columnValues === 'string') {
                /** @type {?} */
                const customIcon = columnIcon.icons.find((/**
                 * @param {?} icon
                 * @return {?}
                 */
                icon => columnValues === icon.value));
                if (customIcon) {
                    return [customIcon];
                }
            }
        }
        return columnValues;
    }
    /**
     * @param {?} row
     * @param {?} columnLabel
     * @return {?}
     */
    getColumnLabel(row, columnLabel) {
        return columnLabel.labels.find((/**
         * @param {?} labelItem
         * @return {?}
         */
        labelItem => row[columnLabel.property] === labelItem.value));
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getColumnTitleLabel(column) {
        return column.label || capitalizeFirstLetter(column.property);
    }
    /**
     * @return {?}
     */
    verifyWidthColumnsPixels() {
        /** @type {?} */
        const columns = this.getMainColumns();
        return columns.length ? columns.every((/**
         * @param {?} column
         * @return {?}
         */
        column => column.width && column.width.includes('px'))) : false;
    }
    /**
     * @return {?}
     */
    calculateWidthHeaders() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.height) {
                this.headersTable.forEach((/**
                 * @param {?} header
                 * @return {?}
                 */
                header => {
                    /** @type {?} */
                    const divHeader = header.nativeElement.querySelector('.thf-table-header-fixed-inner');
                    if (divHeader) {
                        divHeader.style.width = `${header.nativeElement.offsetWidth}px`;
                    }
                }));
            }
        }));
    }
    /**
     * @param {?} row
     * @return {?}
     */
    containsMasterDetail(row) {
        return row[this.getNameColumnDetail()] && row[this.getNameColumnDetail()].length;
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    isShowRowTemplate(row, index) {
        if (this.tableRowTemplate && this.tableRowTemplate.thfTableRowTemplateShow) {
            return this.tableRowTemplate.thfTableRowTemplateShow(row, index);
        }
        return true;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    isShowMasterDetail(row) {
        return !this.hideDetail &&
            this.getNameColumnDetail() &&
            row.$showDetail &&
            this.containsMasterDetail(row) &&
            !this.hasRowTemplate;
    }
    /**
     * @param {?} event
     * @param {?=} column
     * @param {?=} row
     * @return {?}
     */
    tooltipMouseEnter(event, column, row) {
        this.tooltipText = undefined;
        if (this.hideTextOverflow &&
            event.target.offsetWidth < event.target.scrollWidth &&
            event.target.innerText.trim()) {
            return this.tooltipText = event.target.innerText;
        }
        if (column) {
            this.checkingIfColumnHasTooltip(column, row);
        }
    }
    /**
     * @return {?}
     */
    tooltipMouseLeave() {
        this.tooltipText = undefined;
    }
    /**
     * @return {?}
     */
    verifyChangeHeightInFooter() {
        return this.footerHeight !== this.getHeightTableFooter();
    }
    /**
     * @return {?}
     */
    verifyCalculateHeightTableContainer() {
        if (this.height && this.verifyChangeHeightInFooter()) {
            this.footerHeight = this.getHeightTableFooter();
            this.calculateHeightTableContainer(this.height);
        }
    }
    /**
     * @param {?} height
     * @return {?}
     */
    calculateHeightTableContainer(height) {
        /** @type {?} */
        const value = parseFloat(height);
        this.heightTableContainer = value ? (value - this.getHeightTableFooter()) : undefined;
        this.setTableOpacity(1);
        this.changeDetector.detectChanges();
    }
    /**
     * @param {?} row
     * @param {?} targetRef
     * @return {?}
     */
    togglePopup(row, targetRef) {
        this.popupTarget = targetRef;
        this.changeDetector.detectChanges();
        this.thfPopupComponent.toggle(row);
    }
    /**
     * @protected
     * @param {?} container
     * @return {?}
     */
    showContainer(container) {
        /** @type {?} */
        const containerClassList = this.tableContainerElement.nativeElement.firstChild.classList;
        containerClassList.add('thf-container');
        container === 'border' ? containerClassList.add('thf-container-no-shadow') : containerClassList.remove('thf-container-no-shadow');
    }
    /**
     * @private
     * @return {?}
     */
    checkChangesItems() {
        /** @type {?} */
        const changesItems = this.differ.diff(this.items);
        if (changesItems && this.selectAll) {
            this.selectAll = null;
        }
        if (changesItems && !this.hasColumns() && this.hasItems()) {
            this.columns = this.getDefaultColumns(this.items[0]);
        }
    }
    /**
     * @private
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    checkingIfColumnHasTooltip(column, row) {
        if (column.type === 'link' && column.tooltip && !this.checkDisabled(row, column)) {
            return this.tooltipText = column.tooltip;
        }
        if (column.type === 'label') {
            /** @type {?} */
            const columnLabel = this.getColumnLabel(row, column);
            return this.tooltipText = columnLabel.tooltip;
        }
    }
    /**
     * @private
     * @return {?}
     */
    getHeightTableFooter() {
        return this.tableFooterElement ? this.tableFooterElement.nativeElement.offsetHeight : 0;
    }
    /**
     * @private
     * @return {?}
     */
    hideContainer() {
        /** @type {?} */
        const containerClassList = this.tableContainerElement.nativeElement.firstChild.classList;
        containerClassList.remove('thf-container');
    }
    /**
     * @private
     * @param {?} columnValues
     * @param {?} customIcons
     * @return {?}
     */
    mergeCustomIcons(columnValues, customIcons) {
        /** @type {?} */
        const icons = [];
        columnValues.forEach((/**
         * @param {?} columnValue
         * @return {?}
         */
        columnValue => {
            /** @type {?} */
            const foundCustomIcon = customIcons.find((/**
             * @param {?} customIcon
             * @return {?}
             */
            customIcon => columnValue === customIcon.icon || columnValue === customIcon.value));
            foundCustomIcon ? icons.push(foundCustomIcon) : icons.push(columnValue);
        }));
        return icons;
    }
    /**
     * @private
     * @param {?} row
     * @param {?} tableAction
     * @return {?}
     */
    validateTableAction(row, tableAction) {
        if (typeof tableAction.disabled === 'function') {
            return tableAction.disabled.call(this.parentRef, row);
        }
        else {
            return tableAction.disabled;
        }
    }
    /**
     * @private
     * @return {?}
     */
    debounceResize() {
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout((/**
         * @return {?}
         */
        () => {
            this.calculateWidthHeaders();
            // show the table
            this.setTableOpacity(1);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.resizeListener) {
            this.resizeListener();
        }
        if (this.clickListener) {
            this.clickListener();
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setTableOpacity(value) {
        this.tableOpacity = value;
    }
}
ThfTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table',
                template: "<thf-container #tableContainer t-no-padding>\n  <div [class.thf-table-container-relative]=\"loading\">\n    <div *ngIf=\"loading\" class=\"thf-table-overlay\">\n      <thf-loading class=\"thf-table-overlay-content\" [t-text]=\"literals.loadingData\"></thf-loading>\n    </div>\n\n    <div class=\"thf-table-main-container\">\n      <div #tableWrapper\n        class=\"thf-table-wrapper\"\n        [class.thf-table-header-fixed-columns-pixels]=\"verifyWidthColumnsPixels()\"\n        [style.opacity]=\"tableOpacity\">\n\n        <div class=\"thf-table-container\" *ngIf=\"height\" [style.height.px]=\"heightTableContainer\">\n          <div class=\"thf-table-header-fixed thf-table-header\"></div>\n          <div class=\"thf-table-container-fixed-inner\">\n            <ng-container *ngTemplateOutlet=\"tableTemplate\"></ng-container>\n          </div>\n        </div>\n\n        <div *ngIf=\"!height\">\n          <ng-container *ngTemplateOutlet=\"tableTemplate\"></ng-container>\n        </div>\n\n      </div>\n    </div>\n  </div>\n\n  <div class=\"thf-table-footer\" *ngIf=\"hasItems() && getSubtitleColumns().length\">\n    <div *ngFor=\"let column of getSubtitleColumns()\">\n      <thf-table-subtitle-footer [t-literals]=\"literals\" [t-subtitles]=\"column.subtitles\"></thf-table-subtitle-footer>\n    </div>\n  </div>\n</thf-container>\n\n<div class=\"thf-row thf-table-footer-show-more\" [class.thf-invisible]=\"showMore.observers.length === 0\" #tableFooter>\n  <thf-button\n    class=\"thf-offset-xl-4 thf-offset-lg-4 thf-offset-md-3 thf-lg-4 thf-md-6\"\n    [t-disabled]=\"showMoreDisabled\"\n    [t-label]=\"literals.loadMoreData\"\n    (t-click)=\"onShowMore()\">\n  </thf-button>\n</div>\n\n<ng-template #tableTemplate>\n  <table class=\"thf-table\"\n    [class.thf-table-striped]=\"striped\"\n    [class.thf-table-layout-fixed]=\"hideTextOverflow\">\n    <thead>\n      <tr [class.thf-table-header]=\"!height\">\n        <th *ngIf=\"checkbox && hasItems()\" class=\"thf-table-column-checkbox\">\n          <div [class.thf-table-header-fixed-inner]=\"height\">\n            <input *ngIf=\"!hideSelectAll\" type=\"checkbox\" class=\"thf-table-checkbox\"\n            [class.thf-table-checkbox-checked]=\"selectAll\"\n            [class.thf-table-checkbox-indeterminate]=\"selectAll === null\">\n            <label *ngIf=\"!hideSelectAll\" class=\"thf-table-checkbox-label thf-clickable\" (click)=\"selectAllRows()\"></label>\n          </div>\n        </th>\n        <th *ngIf=\"hasItems() && !hideDetail && getColumnMasterDetail() !== undefined || hasRowTemplate\"\n          class=\"thf-table-header-column thf-table-header-master-detail\">\n        </th>\n        <th *ngIf=\"!hasColumns()\" class=\"thf-table-header-column thf-text-center\">{{ literals.noColumns }}</th>\n        <th *ngFor=\"let column of getMainColumns(); let i = index\" #headersTable\n          class=\"thf-table-header-ellipsis\"\n          [style.width]=\"column.width\" [style.max-width]=\"column.width\" [style.min-width]=\"column.width\"\n          [class.thf-clickable]=\"sort\"\n          [class.thf-table-column-right]= \"column.type === 'currency' || column.type === 'number'\"\n          [class.thf-table-header-subtitle]=\"column.type === 'subtitle'\"\n          (click)=\"sortColumn(column)\">\n            <div *ngIf=\"height\" class=\"thf-table-header-fixed-inner\">\n              <ng-container *ngTemplateOutlet=\"contentHeaderTemplate\"></ng-container>\n            </div>\n            <div *ngIf=\"!height\">\n              <ng-container *ngTemplateOutlet=\"contentHeaderTemplate\"></ng-container>\n            </div>\n            <ng-template #contentHeaderTemplate>\n              <span *ngIf=\"sort\"\n                [class.thf-table-header-icon-unselected]= \"sortedColumn?.property !== column\"\n                [class.thf-table-header-icon-descending]= \"sortedColumn?.property === column && sortedColumn.ascending\"\n                [class.thf-table-header-icon-ascending]= \"sortedColumn?.property === column && !sortedColumn.ascending\">\n              </span>\n              <span\n                class=\"thf-table-header-ellipsis thf-table-header-block\"\n                [t-tooltip]=\"tooltipText\"\n                (mouseenter)=\"tooltipMouseEnter($event)\"\n                (mouseleave)=\"tooltipMouseLeave()\">\n                {{ getColumnTitleLabel(column) }}\n              </span>\n            </ng-template>\n        </th>\n        <th *ngIf=\"visibleActions.length > 1 && hasItems()\" class=\"thf-table-header-action\"></th>\n        <th *ngIf=\"visibleActions.length === 1 && hasItems()\" class=\"thf-table-header-single-action\"></th>\n      </tr>\n    </thead>\n\n    <tbody class=\"thf-table-group-row\" *ngIf=\"!hasItems()\">\n      <tr class=\"thf-table-row\">\n        <td [colSpan]=\"columnCount()\" class=\"thf-table-no-data thf-text-center\">\n          <span> {{ literals.noData }} </span>\n        </td>\n      </tr>\n    </tbody>\n\n    <tbody class=\"thf-table-group-row\" *ngFor=\"let row of items, let rowIndex = index;\">\n      <tr class=\"thf-table-row\" [class.thf-table-row-active]=\"row.$selected || row.$selected === null && checkbox\">\n        <td *ngIf=\"checkbox\" class=\"thf-table-column thf-table-column-checkbox\">\n          <ng-container *ngIf=\"singleSelect; then inputRadio; else inputCheckbox\"> </ng-container>\n\n          <ng-template #inputRadio>\n            <input type=\"radio\" class=\"thf-radio-group-input\" [class.thf-radio-group-input-checked]=\"row.$selected\">\n            <label class=\"thf-radio-group-label thf-clickable\" (click)=\"checkbox ? selectRow(row) : 'javascript:;'\"></label>\n          </ng-template>\n\n          <ng-template #inputCheckbox>\n            <input type=\"checkbox\" class=\"thf-table-checkbox\" [class.thf-table-checkbox-checked]=\"row.$selected\">\n            <label class=\"thf-table-checkbox-label thf-clickable\" (click)=\"checkbox ? selectRow(row) : 'javascript:;'\"></label>\n          </ng-template>\n\n        </td>\n        <td\n          *ngIf=\"(getColumnMasterDetail() !== undefined) && !hideDetail || hasRowTemplate\"\n          (click)=\"row.$showDetail = !row.$showDetail\"\n          class=\"thf-table-column-detail-toggle\">\n          <span\n            *ngIf=\"(containsMasterDetail(row) && !hasRowTemplate) || isShowRowTemplate(row, rowIndex) && hasRowTemplate\"\n            [class.thf-icon-arrow-up]=\"row.$showDetail\"\n            [class.thf-icon-arrow-down]=\"!row.$showDetail\"\n            class=\"thf-icon thf-clickable\">\n          </span>\n        </td>\n\n        <td *ngFor=\"let column of getMainColumns(), let columnIndex = index;\"\n          [style.width]=\"column.width\" [style.max-width]=\"column.width\" [style.min-width]=\"column.width\"\n          [class.thf-table-column]=\"column.type !== 'icon'\"\n          [class.thf-table-column-right]=\"column.type == 'currency' || column.type == 'number'\"\n          [class.thf-table-column-center]=\"column.type === 'subtitle'\"\n          [class.thf-table-column-icons]=\"column.type === 'icon'\"\n          [ngClass]=\"getClassColor(row, column)\"\n          (click)=\"checkbox ? selectRow(row) : 'javascript:;'\">\n          <div \n            class=\"thf-table-column-cell\"\n            [class.thf-table-body-ellipsis]=\"hideTextOverflow\"\n            [ngSwitch]=\"column.type\"\n            [t-tooltip]=\"tooltipText\"\n            (mouseenter)=\"tooltipMouseEnter($event, column, row)\"\n            (mouseleave)=\"tooltipMouseLeave()\">\n            <span *ngSwitchCase=\"'boolean'\">{{ getBooleanLabel(row[column.property], column) }}</span>\n            <span *ngSwitchCase=\"'currency'\">{{ row[column.property] | currency:column.format:'symbol':'1.2-2' }}</span>\n            <span *ngSwitchCase=\"'date'\" >{{ row[column.property] | date: column.format || 'dd/MM/yyyy' }}</span>\n            <span *ngSwitchCase=\"'time'\" >{{ row[column.property] | thf_time: column.format || 'HH:mm:ss.ffffff' }}</span>\n            <span *ngSwitchCase=\"'dateTime'\" >{{ row[column.property] | date: column.format || 'dd/MM/yyyy HH:mm:ss' }}</span>\n            <span *ngSwitchCase=\"'number'\">{{ formatNumber(row[column.property], column.format) }}</span>\n            <thf-table-column-link *ngSwitchCase=\"'link'\"\n              [t-action]=\"column.action\"\n              [t-disabled]=\"checkDisabled(row, column)\"\n              [t-link]=\"row[column.link]\"\n              [t-row]=\"row\"\n              [t-value]=\"row[column.property]\">\n            </thf-table-column-link>\n            <span *ngSwitchCase=\"'icon'\">\n              <thf-table-column-icon\n                [t-icons]=\"getColumnIcons(row, column)\"\n                [t-column]=\"column\"\n                [t-row]=\"row\">\n              </thf-table-column-icon>\n            </span>\n            <span *ngSwitchCase=\"'subtitle'\">\n              <thf-table-subtitle-circle [t-subtitle]=\"getSubtitleColumn(row, column)\"></thf-table-subtitle-circle>\n            </span>\n            <span *ngSwitchCase=\"'label'\">\n              <thf-table-column-label [t-value]=\"getColumnLabel(row, column)\"></thf-table-column-label>\n            </span>\n            <span *ngSwitchDefault>{{ row[column.property] }}</span>\n          </div>\n        </td>\n        <td *ngIf=\"visibleActions.length === 1\" class=\"thf-table-column thf-table-column-single-action\">\n          <div *ngIf=\"firstAction.visible !== false\"\n            class=\"thf-table-single-action thf-clickable\"\n            [class.thf-table-action-disabled]= \"firstAction.disabled ? validateTableAction(row, firstAction) : false\"\n            (click)=\"executeTableAction(row, firstAction)\">\n\n            <span *ngIf=\"firstAction.icon\" class=\"thf-icon {{ firstAction.icon }}\"></span>\n            {{ firstAction.label }}\n          </div>\n        </td>\n        <td *ngIf=\"visibleActions.length > 1\" class=\"thf-table-column-actions\">\n          <span #popupTarget class=\"thf-icon thf-icon-more thf-clickable\" (click)=\"togglePopup(row, popupTarget)\">\n          </span>\n        </td>\n      </tr>\n\n      <tr *ngIf=\"hasRowTemplate && row.$showDetail && isShowRowTemplate(row, rowIndex)\">\n        <td class=\"thf-table-row-template-container\" [colSpan]=\"columnCountForMasterDetail()\">\n\n          <ng-template\n            [ngTemplateOutlet]=\"tableRowTemplate.templateRef\"\n            [ngTemplateOutletContext]=\"{ $implicit: row, rowIndex: rowIndex }\">\n          </ng-template>\n\n        </td>\n      </tr>\n\n      <tr *ngIf=\"isShowMasterDetail(row)\">\n        <td class=\"thf-table-column-detail\" [colSpan]=\"columnCountForMasterDetail()\">\n\n          <thf-table-detail\n            [t-checkbox]=\"checkbox && !detailHideSelect\"\n            [t-detail]=\"getColumnMasterDetail().detail\"\n            [t-items]=\"row[getNameColumnDetail()]\"\n            (t-select-row)=\"selectDetailRow($event)\">\n          </thf-table-detail>\n\n        </td>\n      </tr>\n    </tbody>\n  </table>\n\n  <thf-popup #popup\n    [t-actions]=\"actions\"\n    [t-target]=\"popupTarget\">\n  </thf-popup>\n\n</ng-template>\n",
                providers: [ThfDateService]
            }] }
];
/** @nocollapse */
ThfTableComponent.ctorParameters = () => [
    { type: ThfDateService },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: DecimalPipe },
    { type: Router }
];
ThfTableComponent.propDecorators = {
    tableRowTemplate: [{ type: ContentChild, args: [ThfTableRowTemplateDirective, { static: true },] }],
    thfPopupComponent: [{ type: ViewChild, args: ['popup', { static: false },] }],
    tableContainerElement: [{ type: ViewChild, args: ['tableContainer', { read: ElementRef, static: true },] }],
    tableFooterElement: [{ type: ViewChild, args: ['tableFooter', { read: ElementRef, static: true },] }],
    tableWrapperElement: [{ type: ViewChild, args: ['tableWrapper', { read: ElementRef, static: true },] }],
    actionsIconElement: [{ type: ViewChildren, args: ['actionsIconElement', { read: ElementRef },] }],
    actionsElement: [{ type: ViewChildren, args: ['actionsElement', { read: ElementRef },] }],
    headersTable: [{ type: ViewChildren, args: ['headersTable',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por apresentar o detalhe de cada linha da tabela.
 */
class ThfTableDetailComponent {
    /**
     * @param {?} decimalPipe
     */
    constructor(decimalPipe) {
        this.decimalPipe = decimalPipe;
        /**
         * Define se a tabela possui a opção de `checkbox` habilitada.
         */
        this.hasCheckbox = false;
        /**
         * Ação executada ao selecionar ou desmarcar a seleção de uma linha de detalhe do `thf-table`.
         */
        this.selectRow = new EventEmitter();
    }
    /**
     * Configuração da linha de detalhes.
     * @param {?} value
     * @return {?}
     */
    set detail(value) {
        this._detail = this.returnThfTableDetailObject(value);
    }
    /**
     * @return {?}
     */
    get detail() {
        return this._detail;
    }
    /**
     * @return {?}
     */
    get detailColumns() {
        return this.detail && this.detail.columns || [];
    }
    /**
     * @return {?}
     */
    get typeHeaderInline() {
        return this.detail && !this.detail['typeHeader'] || this.detail['typeHeader'] === 'inline';
    }
    /**
     * @return {?}
     */
    get typeHeaderTop() {
        return this.detail && this.detail['typeHeader'] === 'top';
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    formatNumberDetail(value, format) {
        if (!format) {
            return value;
        }
        return this.decimalPipe.transform(value, format);
    }
    /**
     * @param {?} detail
     * @return {?}
     */
    getColumnTitleLabel(detail) {
        return detail.label || capitalizeFirstLetter(detail.property);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onSelectRow(item) {
        item.$selected = !item.$selected;
        this.selectRow.emit(item);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    returnThfTableDetailObject(value) {
        if (value && isTypeof(value, 'object')) {
            if (value.columns) {
                value.columns.forEach((/**
                 * @param {?} column
                 * @return {?}
                 */
                column => column.property = column.property || column.column));
            }
            if (Array.isArray(value)) {
                return { columns: value };
            }
            if (value.columns) {
                return value;
            }
        }
    }
}
ThfTableDetailComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table-detail',
                template: "<table class=\"thf-table-master-detail\">\n  <thead *ngIf=\"typeHeaderTop\">\n    <tr>\n      <th class=\"thf-table-header thf-table-column-checkbox\" *ngIf=\"hasCheckbox\"></th>\n      <th class=\"thf-table-header thf-table-header-column thf-table-header-master-detail\"></th>\n      <th class=\"thf-table-header thf-table-header-ellipsis\" *ngFor=\"let detail of detail.columns\">\n        {{ getColumnTitleLabel(detail) }}\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class=\"thf-table-detail-row\"\n        [class.thf-table-row-active]=\"item.$selected && hasCheckbox\"\n        *ngFor=\"let item of items\">\n\n      <ng-container *ngIf=\"hasCheckbox; else masterDetailSpace\">\n\n        <td class=\"thf-table-column-master-detail-space-checkbox\"></td>\n        <td class=\"thf-table-column thf-table-column-checkbox\">\n          <input\n            class=\"thf-table-checkbox\"\n            type=\"checkbox\"\n            [class.thf-table-checkbox-checked]=\"item.$selected\">\n          <label class=\"thf-table-checkbox-label thf-clickable\" (click)=\"onSelectRow(item)\">\n          </label>\n        </td>\n\n      </ng-container>\n\n      <ng-template #masterDetailSpace>\n        <td class=\"thf-table-column-master-detail-space\"></td>\n      </ng-template>\n\n      <td class=\"thf-table-column-master-detail thf-table-master-detail-label\"\n        (click)=\"hasCheckbox ? onSelectRow(item) : 'javascript:;'\"\n        *ngFor=\"let detail of detailColumns\">\n        <strong *ngIf=\"typeHeaderInline\"> {{ getColumnTitleLabel(detail) }}: </strong>\n\n        <ng-container [ngSwitch]=\"detail.type\">\n          <span *ngSwitchCase=\"'currency'\">{{ item[detail.property] | currency: detail.format:'symbol':'1.2-2' }}</span>\n          <span *ngSwitchCase=\"'date'\">{{ item[detail.property] | date: detail.format || 'dd/MM/yyyy' }}</span>\n          <span *ngSwitchCase=\"'time'\">{{ item[detail.property] | thf_time: detail.format || 'HH:mm:ss.ffffff' }}</span>\n          <span *ngSwitchCase=\"'dateTime'\">{{ item[detail.property] | date: detail.format || 'dd/MM/yyyy HH:mm:ss' }}</span>\n          <span *ngSwitchCase=\"'number'\">{{ formatNumberDetail(item[detail.property], detail.format) }}</span>\n          <span *ngSwitchDefault>{{ item[detail.property] }}</span>\n        </ng-container>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"
            }] }
];
/** @nocollapse */
ThfTableDetailComponent.ctorParameters = () => [
    { type: DecimalPipe }
];
ThfTableDetailComponent.propDecorators = {
    hasCheckbox: [{ type: Input, args: ['t-checkbox',] }],
    detail: [{ type: Input, args: ['t-detail',] }],
    items: [{ type: Input, args: ['t-items',] }],
    selectRow: [{ type: Output, args: ['t-select-row',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação de um botão e modal para visualização de todas as legendas.
 */
class ThfTableShowSubtitleComponent {
}
ThfTableShowSubtitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table-show-subtitle',
                template: "<div class=\"thf-table-footer-show-subtitle\" (click)=\"modal.open()\">\n  <div class=\"thf-table-footer-show-subtitle-container\">\n    <span class=\"thf-table-show-subtitle\">{{ literals.seeCompleteSubtitle }}</span>\n  </div>\n</div>\n\n<thf-modal #modal\n  t-size=\"sm\"\n  [t-title]=\"literals.completeSubtitle\">\n\n  <div *ngFor=\"let subtitle of subtitles\" class=\"thf-table-subtitle-footer-modal thf-row\">\n    <thf-table-subtitle-circle\n      t-hide-title=\"true\"\n      [t-subtitle]=\"subtitle\">\n    </thf-table-subtitle-circle>\n    <span class=\"thf-table-subtitle-text\">{{ subtitle.label }}</span>\n  </div>\n</thf-modal>\n"
            }] }
];
ThfTableShowSubtitleComponent.propDecorators = {
    subtitles: [{ type: Input, args: ['t-subtitles',] }],
    literals: [{ type: Input, args: ['t-literals',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação da representação da legenda, em formato de círculo.
 */
class ThfTableSubtitleCircleComponent {
    /**
     * @param {?} thfColorPaletteService
     */
    constructor(thfColorPaletteService) {
        this.thfColorPaletteService = thfColorPaletteService;
        /**
         * Esconde a tooltip.
         */
        this.hideTitle = false;
    }
    /**
     * Objeto com os dados da legenda.
     * @param {?} subtitle
     * @return {?}
     */
    set subtitle(subtitle) {
        if (subtitle) {
            subtitle.color = this.thfColorPaletteService.getColor(subtitle);
        }
        this._subtitle = subtitle;
    }
    /**
     * @return {?}
     */
    get subtitle() {
        return this._subtitle;
    }
}
ThfTableSubtitleCircleComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table-subtitle-circle',
                template: "<span\n  [title]=\"hideTitle ? '' : subtitle?.label\"\n  class=\"thf-table-subtitle-circle thf-{{ subtitle?.color }}\">\n  {{ subtitle?.content }}\n</span>\n"
            }] }
];
/** @nocollapse */
ThfTableSubtitleCircleComponent.ctorParameters = () => [
    { type: ThfColorPaletteService }
];
ThfTableSubtitleCircleComponent.propDecorators = {
    subtitle: [{ type: Input, args: ['t-subtitle',] }],
    hideTitle: [{ type: Input, args: ['t-hide-title',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação de um conjunto de legendas.
 */
class ThfTableSubtitleFooterComponent {
    /**
     * @param {?} element
     * @param {?} renderer
     */
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initializeResizeListener();
        this.debounceResize();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeResizeListener();
    }
    /**
     * @private
     * @return {?}
     */
    debounceResize() {
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout((/**
         * @return {?}
         */
        () => {
            this.toggleShowCompleteSubtitle();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    getContainerSize() {
        return this.element.nativeElement.querySelector('.thf-table-subtitle-footer-container').offsetWidth;
    }
    /**
     * @private
     * @return {?}
     */
    getItemsSize() {
        /** @type {?} */
        const items = this.element.nativeElement.querySelectorAll('.thf-table-subtitle-footer');
        return Array.from(items).map((/**
         * @param {?} item
         * @return {?}
         */
        item => item['offsetWidth'])).reduce((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => a + b), 16);
    }
    /**
     * @private
     * @return {?}
     */
    initializeResizeListener() {
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.debounceResize();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    removeResizeListener() {
        this.resizeListener();
    }
    /**
     * @private
     * @return {?}
     */
    toggleShowCompleteSubtitle() {
        /** @type {?} */
        const containerSize = this.getContainerSize();
        /** @type {?} */
        const itemsSize = this.getItemsSize();
        this.showSubtitle = itemsSize > containerSize;
    }
}
ThfTableSubtitleFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-table-subtitle-footer',
                template: "<div class=\"thf-table-subtitle-footer-container\">\n  <div *ngFor=\"let subtitle of subtitles\" class=\"thf-table-subtitle-footer\">\n    <thf-table-subtitle-circle\n      t-hide-title=\"true\"\n      [t-subtitle]=\"subtitle\">\n    </thf-table-subtitle-circle>\n    <span class=\"thf-table-subtitle-text\">{{ subtitle.label }}</span>\n  </div>\n  <thf-table-show-subtitle *ngIf=\"showSubtitle\"\n    [t-literals]=\"literals\"\n    [t-subtitles]=\"subtitles\">\n  </thf-table-show-subtitle>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfTableSubtitleFooterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
ThfTableSubtitleFooterComponent.propDecorators = {
    literals: [{ type: Input, args: ['t-literals',] }],
    subtitles: [{ type: Input, args: ['t-subtitles',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-table
 */
class ThfTableModule {
}
ThfTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    ThfButtonModule,
                    ThfContainerModule,
                    ThfLoadingModule,
                    ThfModalModule,
                    ThfPopupModule,
                    ThfTimeModule,
                    ThfTooltipModule
                ],
                declarations: [
                    ThfTableComponent,
                    ThfTableColumnIconComponent,
                    ThfTableColumnLabelComponent,
                    ThfTableColumnLinkComponent,
                    ThfTableDetailComponent,
                    ThfTableRowTemplateDirective,
                    ThfTableShowSubtitleComponent,
                    ThfTableSubtitleCircleComponent,
                    ThfTableSubtitleFooterComponent
                ],
                exports: [
                    ThfTableComponent,
                    ThfTableRowTemplateDirective
                ],
                providers: [DecimalPipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfCalendarLangService$1 {
    constructor() {
        this.months = [
            {
                pt: 'Janeiro',
                en: 'January',
                es: 'Enero'
            },
            {
                pt: 'Fevereiro',
                en: 'February',
                es: 'Febrero'
            },
            {
                pt: 'Março',
                en: 'March',
                es: 'Marzo'
            },
            {
                pt: 'Abril',
                en: 'April',
                es: 'Abril'
            },
            {
                pt: 'Maio',
                en: 'May',
                es: 'Mayo'
            },
            {
                pt: 'Junho',
                en: 'June',
                es: 'Junio'
            },
            {
                pt: 'Julho',
                en: 'July',
                es: 'Julio'
            },
            {
                pt: 'Agosto',
                en: 'August',
                es: 'Agosto'
            },
            {
                pt: 'Setembro',
                en: 'September',
                es: 'Setiembre'
            },
            {
                pt: 'Outubro',
                en: 'October',
                es: 'Octubre'
            },
            {
                pt: 'Novembro',
                en: 'November',
                es: 'Noviembre'
            },
            {
                pt: 'Dezembro',
                en: 'December',
                es: 'Diciembre'
            }
        ];
        this.shortWeekDays = [
            {
                pt: 'Dom',
                en: 'Sun',
                es: 'Dom'
            },
            {
                pt: 'Seg',
                en: 'Mon',
                es: 'Lun'
            },
            {
                pt: 'Ter',
                en: 'Tue',
                es: 'Mar'
            },
            {
                pt: 'Qua',
                en: 'Wed',
                es: 'Mié'
            },
            {
                pt: 'Qui',
                en: 'Thu',
                es: 'Jue'
            },
            {
                pt: 'Sex',
                en: 'Fri',
                es: 'Vie'
            },
            {
                pt: 'Sáb',
                en: 'Sat',
                es: 'Sáb'
            }
        ];
        this.wordMonth = {
            pt: 'Mês',
            en: 'Month',
            es: 'Mes'
        };
        this.wordYear = {
            pt: 'Ano',
            en: 'Year',
            es: 'Año'
        };
        this.lang = 'pt';
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    setLanguage(lang) {
        if (lang && lang.length >= 2) {
            lang = lang.toLowerCase().slice(0, 2);
            this.lang = (lang === 'pt' || lang === 'en' || lang === 'es') ? lang : 'pt';
        }
    }
    /**
     * @return {?}
     */
    getWordMonth() {
        return this.wordMonth[this.lang];
    }
    /**
     * @return {?}
     */
    getWordYear() {
        return this.wordYear[this.lang];
    }
    /**
     * @param {?} month
     * @return {?}
     */
    getMonth(month) {
        return this.months[month][this.lang];
    }
    /**
     * @return {?}
     */
    getArrayMonths() {
        /** @type {?} */
        const arrMonths = Array();
        for (let i = 0; i < this.months.length; i++) {
            arrMonths.push(this.months[i][this.lang]);
        }
        return arrMonths;
    }
    /**
     * @param {?} day
     * @return {?}
     */
    getWeedDays(day) {
        return this.shortWeekDays[day][this.lang];
    }
    /**
     * @return {?}
     */
    getArrayWeekDays() {
        /** @type {?} */
        const arrWeekDays = Array();
        for (let i = 0; i < this.shortWeekDays.length; i++) {
            arrWeekDays.push(this.shortWeekDays[i][this.lang]);
        }
        return arrWeekDays;
    }
}
ThfCalendarLangService$1.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfCalendarLangService$1.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfCalendarService$1 {
    constructor() {
        this.firstWeekDay = 0; // 0 = sunday
    }
    /**
     * @param {?} date
     * @return {?}
     */
    weekStartDate(date) {
        /** @type {?} */
        const startDate = new Date(date.getTime());
        while (startDate.getDay() !== this.firstWeekDay) {
            startDate.setDate(startDate.getDate() - 1);
        }
        return startDate;
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?=} dayFormatter
     * @param {?=} weekFormatter
     * @return {?}
     */
    monthDates(year, month, dayFormatter = null, weekFormatter = null) {
        if ((typeof month !== 'number') || (month < 0) || (month > 11)) {
            throw Error(('month must be a number (Jan is 0)'));
        }
        /** @type {?} */
        const weeks = [];
        /** @type {?} */
        let week = [];
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let date = new Date(year, month, 1);
        setYearFrom0To100(date, year);
        date = this.weekStartDate(date);
        do {
            for (i = 0; i < 7; i++) {
                week.push(dayFormatter ? dayFormatter(date) : date);
                date = new Date(date.getTime());
                date.setDate(date.getDate() + 1);
            }
            weeks.push(weekFormatter ? weekFormatter(week) : week);
            week = [];
        } while ((date.getMonth() <= month) && (date.getFullYear() === year));
        return weeks;
    }
    /**
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    monthDays(year, month) {
        /** @type {?} */
        const getDayOrZero = (/**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            return date.getMonth() === month ? date : 0;
        });
        return this.monthDates(year, month, getDayOrZero);
    }
}
ThfCalendarService$1.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfCalendarService$1.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfCalendarLocaleDefault$1 = 'pt';
/** @type {?} */
const thfCalendarLocales$1 = ['pt', 'en', 'es'];
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente de calendário de uso interno
 */
class ThfCalendarComponent$1 {
    /**
     * @param {?} thfCalendarService
     * @param {?} thfCalendarLangService
     */
    constructor(thfCalendarService, thfCalendarLangService) {
        this.thfCalendarService = thfCalendarService;
        this.thfCalendarLangService = thfCalendarLangService;
        this.dayVisible = false;
        this.displayMonths = Array();
        this.displayWeedDays = Array();
        this.monthVisible = false;
        this.overlayInvisible = true;
        this.visible = false;
        this.yearVisible = false;
        this.isMobile = isMobile;
        this.today = new Date();
        this.selectedDateChange = new EventEmitter();
        this.submit = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data máxima possível de ser selecionada no calendário.
     * @param {?} val
     * @return {?}
     */
    set dateEnd(val) {
        if (val && val instanceof Date) {
            /** @type {?} */
            const year = val.getFullYear();
            /** @type {?} */
            const month = val.getMonth();
            /** @type {?} */
            const day = val.getDate();
            /** @type {?} */
            const date = new Date(year, month, day, 23, 59, 59);
            setYearFrom0To100(date, year);
            this._dateEnd = date;
        }
        else {
            this._dateEnd = undefined;
        }
    }
    /**
     * @return {?}
     */
    get dateEnd() {
        return this._dateEnd;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Idioma do calendário.
     *
     * Valores válidos:
     *  - `pt`
     *  - `en`
     *  - `es`
     * @param {?} locale
     * @return {?}
     */
    set locale(locale) {
        this._locale = thfCalendarLocales$1.includes(locale) ? locale : thfCalendarLocaleDefault$1;
        this.initializeLanguage();
    }
    /**
     * @return {?}
     */
    get locale() {
        return this._locale;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data selecionada no calendário.
     * @param {?} selectedDate
     * @return {?}
     */
    set selectedDate(selectedDate) {
        this._selectedDate = selectedDate && selectedDate instanceof Date ? selectedDate : undefined;
    }
    /**
     * @return {?}
     */
    get selectedDate() {
        return this._selectedDate;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data mínima possível de ser selecionada no calendário.
     * @param {?} val
     * @return {?}
     */
    set dateStart(val) {
        if (val && val instanceof Date) {
            /** @type {?} */
            const year = val.getFullYear();
            /** @type {?} */
            const month = val.getMonth();
            /** @type {?} */
            const day = val.getDate();
            /** @type {?} */
            const date = new Date(year, month, day, 0, 0, 0);
            setYearFrom0To100(date, year);
            this._dateStart = date;
        }
        else {
            this._dateStart = undefined;
        }
    }
    /**
     * @return {?}
     */
    get dateStart() {
        return this._dateStart;
    }
    /**
     * @return {?}
     */
    close() {
        this.overlayInvisible = true;
        this.visible = false;
    }
    // Obtém um array de todos os anos desta década
    /**
     * @param {?} year
     * @return {?}
     */
    getArrayDecade(year) {
        this.displayDecade = Array();
        if (year % 10 !== 0) {
            while (year % 10 !== 0) {
                year--;
            }
        }
        this.updateDecade(year);
    }
    /**
     * @param {?} displayValue
     * @param {?} propertyValue
     * @return {?}
     */
    getBackgroundColor(displayValue, propertyValue) {
        return (displayValue === propertyValue) ? 'thf-calendar-box-background-selected' : 'thf-calendar-box-background';
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayBackgroundColor(date) {
        if (this.equalsDate(date, this.selectedDate)) {
            return 'thf-calendar-box-background-selected';
        }
        else if (this.equalsDate(date, this.today)) {
            return 'thf-calendar-box-background-today';
        }
        else if (date) {
            if (validateDateRange(date, this.dateStart, this.dateEnd)) {
                return 'thf-calendar-box-background';
            }
            else {
                return 'thf-calendar-box-background-disabled';
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayForegroundColor(date) {
        if (this.equalsDate(date, this.selectedDate)) {
            return 'thf-calendar-box-foreground-selected';
        }
        else if (this.equalsDate(date, this.today)) {
            return 'thf-calendar-box-foreground-today';
        }
        else {
            if (validateDateRange(date, this.dateStart, this.dateEnd)) {
                return 'thf-calendar-box-foreground';
            }
            else {
                return 'thf-calendar-box-foreground-disabled';
            }
        }
    }
    /**
     * @param {?} displayValue
     * @param {?} propertyValue
     * @return {?}
     */
    getForegroundColor(displayValue, propertyValue) {
        return (displayValue === propertyValue) ? 'thf-calendar-box-foreground-selected' : 'thf-calendar-box-foreground';
    }
    /**
     * @return {?}
     */
    getWordMonth() {
        return this.thfCalendarLangService.getWordMonth();
    }
    /**
     * @return {?}
     */
    getWordYear() {
        return this.thfCalendarLangService.getWordYear();
    }
    /**
     * @return {?}
     */
    init() {
        this.selectedDate ? this.updateDate(this.selectedDate) : this.updateDate(this.today);
        this.initializeLanguage();
        this.selectDay();
        if (this.isMobile()) {
            this.overlayInvisible = false;
        }
        this.visible = true;
    }
    /**
     * @return {?}
     */
    initializeLanguage() {
        this.thfCalendarLangService.setLanguage(this.locale);
        this.displayWeedDays = this.thfCalendarLangService.getArrayWeekDays();
        this.displayMonths = this.thfCalendarLangService.getArrayMonths();
    }
    /**
     * @return {?}
     */
    onNextMonth() {
        if (this.displayMonthNumber < 11) {
            this.updateDisplay(this.displayYear, this.displayMonthNumber + 1);
        }
        else {
            this.updateDisplay(this.displayYear + 1, 0);
        }
    }
    /**
     * @return {?}
     */
    onPrevMonth() {
        if (this.displayMonthNumber > 0) {
            this.updateDisplay(this.displayYear, this.displayMonthNumber - 1);
        }
        else {
            this.updateDisplay(this.displayYear - 1, 11);
        }
    }
    // Ao selecionar uma data
    /**
     * @param {?} date
     * @return {?}
     */
    onSelectDate(date) {
        if (validateDateRange(date, this.dateStart, this.dateEnd)) {
            this.selectedDate = date;
            this.selectedDateChange.emit(date);
            this.submit.emit(date);
        }
    }
    // Ao selecionar um mês
    /**
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    onSelectMonth(year, month) {
        this.selectDay();
        this.updateDisplay(year, month);
    }
    // Ao selecionar um ano
    /**
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    onSelectYear(year, month) {
        // Se veio da tela de seleção de mês
        this.lastDisplay === 'month' ? this.selectMonth() : this.selectDay();
        this.currentYear = year;
        this.updateDisplay(year, month);
    }
    /**
     * @return {?}
     */
    selectDay() {
        this.dayVisible = true;
        this.monthVisible = false;
        this.yearVisible = false;
        this.lastDisplay = 'day';
    }
    /**
     * @return {?}
     */
    selectMonth() {
        this.dayVisible = false;
        this.monthVisible = true;
        this.yearVisible = false;
        this.lastDisplay = 'month';
    }
    /**
     * @return {?}
     */
    selectYear() {
        this.dayVisible = false;
        this.monthVisible = false;
        this.yearVisible = true;
    }
    /**
     * @return {?}
     */
    setMobileVisualization() {
        return this.isMobile() ? 'thf-calendar thf-calendar-mobile' : 'thf-calendar';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateYear(value) {
        this.updateDisplay(this.displayYear + value, this.displayMonthNumber);
    }
    /**
     * @private
     * @param {?} year
     * @return {?}
     */
    addAllYearsInDecade(year) {
        /** @type {?} */
        let i;
        for (i = year; i < year + 10; i++) {
            this.displayDecade.push(i);
        }
    }
    /**
     * @private
     * @param {?} date1
     * @param {?} date2
     * @return {?}
     */
    equalsDate(date1, date2) {
        try {
            return date1.getFullYear() === date2.getFullYear() &&
                date1.getMonth() === date2.getMonth() &&
                date1.getDate() === date2.getDate();
        }
        catch (error) {
            return false;
        }
    }
    /**
     * @private
     * @param {?} date
     * @return {?}
     */
    updateDate(date) {
        this.currentMonthNumber = date.getMonth();
        this.currentYear = date.getFullYear();
        this.updateDisplay(this.currentYear, this.currentMonthNumber);
    }
    /**
     * @private
     * @param {?} year
     * @return {?}
     */
    updateDecade(year) {
        this.addAllYearsInDecade(year);
        this.displayStartDecade = year;
        this.displayFinalDecade = year + 9;
    }
    /**
     * @private
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    updateDisplay(year, month) {
        /** @type {?} */
        const calendarArray = this.thfCalendarService.monthDays(year, month);
        this.displayDays = [].concat.apply([], calendarArray);
        this.displayMonthNumber = month;
        this.displayMonth = this.displayMonths[month];
        this.displayYear = year;
        this.getArrayDecade(year);
    }
}
ThfCalendarComponent$1.decorators = [
    { type: Component, args: [{
                selector: 'thf-calendar',
                template: "<div class=\"thf-calendar-overlay\" [class.thf-invisible]=\"overlayInvisible\"></div>\n<div *ngIf=\"visible\" [ngClass]=\"setMobileVisualization()\">\n  <div *ngIf=\"dayVisible\" #days>\n    <div class=\"thf-calendar-nav\">\n      <span (click)=\"onPrevMonth()\" class=\"thf-calendar-nav-left thf-icon thf-icon-arrow-left\"></span>\n      <div class=\"thf-calendar-nav-title\" attr-calendar>\n        <span class=\"thf-clickable thf-mr-1\" (click)=\"selectMonth()\">{{ displayMonth }}</span>\n        <span class=\"thf-clickable\" (click)=\"selectYear()\">{{ displayYear }}</span>\n      </div>\n      <span (click)=\"onNextMonth()\" class=\"thf-calendar-nav-right thf-icon thf-icon-arrow-right\"></span>\n    </div>\n    <div class=\"thf-calendar-content\">\n      <div class=\"thf-calendar-labels\">\n        <div class=\"thf-calendar-label\" *ngFor=\"let day of displayWeedDays\">\n            {{ day.toLowerCase() }}\n        </div>\n      </div>\n      <div class=\"thf-calendar-content-list-day\">\n        <div *ngFor=\"let day of displayDays\" class=\"thf-calendar-day thf-calendar-box-background\" (click)=\"onSelectDate(day)\"\n          [ngClass]=\"getDayBackgroundColor(day)\">\n          <span *ngIf=\"day != 0\" [ngClass]=\"getDayForegroundColor(day)\">\n            {{ day.getDate() }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"monthVisible\" #months>\n    <div class=\"thf-calendar-nav\">\n      <span (click)=\"updateYear(-1)\" class=\"thf-calendar-nav-left thf-icon thf-icon-arrow-left\"></span>\n      <div class=\"thf-calendar-nav-title\" attr-calendar>\n        <span class=\"thf-clickable\" (click)=\"selectYear()\">{{ displayYear }}</span>\n      </div>\n      <span (click)=\"updateYear(1)\" class=\"thf-calendar-nav-right thf-icon thf-icon-arrow-right\"></span>\n    </div>\n    <div class=\"thf-calendar-content\">\n      <div class=\"thf-calendar-labels\">\n        <div class=\"thf-calendar-label\">\n          {{ getWordMonth() }}\n        </div>\n      </div>\n      <div class=\"thf-calendar-content-list-month\">\n        <div *ngFor=\"let month of displayMonths; let i = index;\" class=\"thf-calendar-month\"\n        (click)=\"onSelectMonth(displayYear, i)\"\n        [ngClass]=\"getBackgroundColor(i, displayMonthNumber)\" attr-calendar>\n          <span [ngClass]=\"getForegroundColor(i, displayMonthNumber)\">\n            {{ month }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"yearVisible\" #years>\n    <div class=\"thf-calendar-nav\">\n      <span (click)=\"updateYear(-10)\" class=\"thf-calendar-nav-left thf-icon thf-icon-arrow-left\"></span>\n      <div class=\"thf-calendar-nav-title\">\n        {{ displayStartDecade }} - {{ displayFinalDecade }}\n      </div>\n      <span (click)=\"updateYear(10)\" class=\"thf-calendar-nav-right thf-icon thf-icon-arrow-right\"></span>\n    </div>\n    <div class=\"thf-calendar-content\">\n      <div class=\"thf-calendar-labels\">\n        <div class=\"thf-calendar-label\">\n          {{ getWordYear() }}\n        </div>\n      </div>\n      <div class=\"thf-calendar-content-list-year\">\n        <div *ngFor=\"let year of displayDecade; let i = index;\" class=\"thf-calendar-year\"\n        (click)=\"onSelectYear(year, displayMonthNumber)\"\n        [ngClass]=\"getBackgroundColor(year, currentYear)\" attr-calendar>\n          <span [ngClass]=\"getForegroundColor(year, currentYear)\">\n            {{ year }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n",
                providers: [ThfCalendarService$1, ThfCalendarLangService$1]
            }] }
];
/** @nocollapse */
ThfCalendarComponent$1.ctorParameters = () => [
    { type: ThfCalendarService$1 },
    { type: ThfCalendarLangService$1 }
];
ThfCalendarComponent$1.propDecorators = {
    elDays: [{ type: ViewChild, args: ['days', { read: ElementRef, static: true },] }],
    elMonths: [{ type: ViewChild, args: ['months', { read: ElementRef, static: true },] }],
    elYears: [{ type: ViewChild, args: ['years', { read: ElementRef, static: true },] }],
    dateEnd: [{ type: Input, args: ['t-date-end',] }],
    locale: [{ type: Input, args: ['t-locale',] }],
    selectedDate: [{ type: Input, args: ['t-selected-date',] }],
    dateStart: [{ type: Input, args: ['t-date-start',] }],
    selectedDateChange: [{ type: Output, args: ['t-selected-dateChange',] }],
    submit: [{ type: Output, args: ['t-submit',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} required
 * @param {?} disabled
 * @param {?} value
 * @return {?}
 */
function requiredFailed(required, disabled, value) {
    /** @type {?} */
    const valid = ((typeof value === 'string' && value) || (typeof value === 'object' && value && value.length)
        || (typeof value === 'number' && (value || value === 0)) || (typeof value === 'boolean' && value));
    return (required && !disabled && !valid);
}
/**
 * @param {?} maxlength
 * @param {?} value
 * @return {?}
 */
function maxlengthFailed(maxlength, value) {
    /** @type {?} */
    const validMaxlength = maxlength || maxlength === 0;
    /** @type {?} */
    const validValue = (value || value === 0) && value.toString();
    return validMaxlength && validValue && validValue.length > Number(maxlength);
}
/**
 * @param {?} minlength
 * @param {?} value
 * @return {?}
 */
function minlengthFailed(minlength, value) {
    /** @type {?} */
    const validMinlength = minlength || minlength === 0;
    /** @type {?} */
    const validValue = (value || value === 0) && value.toString();
    return validMinlength && validValue && validValue.length < Number(minlength);
}
/**
 * @param {?} pattern
 * @param {?} value
 * @return {?}
 */
function patternFailed(pattern, value) {
    /** @type {?} */
    let reg;
    try {
        reg = new RegExp(pattern);
    }
    catch (e) {
        return true;
    }
    return (pattern && value && !reg.test(value));
}
/**
 * @param {?} min
 * @param {?} value
 * @return {?}
 */
function minFailed(min, value) {
    /** @type {?} */
    const validValue = value || value === 0;
    /** @type {?} */
    const validMin = min || min === 0;
    return validValue && validMin && value < min;
}
/**
 * @param {?} max
 * @param {?} value
 * @return {?}
 */
function maxFailed(max, value) {
    /** @type {?} */
    const validValue = value || value === 0;
    /** @type {?} */
    const validMax = max || max === 0;
    return validValue && validMax && value > max;
}
/**
 * @param {?} value
 * @return {?}
 */
function dateFailed(value) {
    return (value && isNaN(Date.parse(value)));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfCheckboxGroupColumnsDefaultLength = 6;
/** @type {?} */
const thfCheckboxGroupColumnsTotalLength = 12;
/**
 * \@description
 *
 * O componente `thf-checkbox-group` exibe uma lista de múltipla escolha onde o usuário pode marcar e desmarcar,
 * utilizando a tecla de espaço ou o clique do mouse, várias opções.
 *
 * > Para seleção única, utilize o [**Totvs Radio Group**](/documentation/thf-radio-group).
 *
 * Por padrão, o thf-checkbox-group retorna um array com os valores dos itens selecionados para o model.
 *
 * ```
 * favorites = ['THF', 'Angular'];
 * ```
 *
 * Na maioria das situações, o array com os objetos setados já atende as necessidades mas, caso o desenvolvedor
 * tenha necessidade de usar um valor indeterminado (`null`), ou seja, nem marcado (`true`) e nem desmarcado (`false`),
 * deve setar a propriedade `t-indeterminate` como `true`.
 *
 * Nesse caso, o thf-checkbox-group vai retornar um objeto com todas as opções disponíveis e seus valores.
 *
 * ```
 * favorites = {
 *  THF: true,
 *  Angular: true,
 *  VueJS: false,
 *  React: null // indeterminado
 * };
 * ```
 */
class ThfCheckboxGroupBaseComponent {
    constructor() {
        this.checkedOptions = {};
        this.checkedOptionsList = [];
        this.mdColumns = thfCheckboxGroupColumnsDefaultLength;
        this._columns = thfCheckboxGroupColumnsDefaultLength;
        this._disabled = false;
        this._indeterminate = false;
        this._required = false;
        // Função para atualizar o `ngModel` do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new EventEmitter();
        /**
         * Evento disparado ao alterar valor do campo
         */
        this.change = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Possibilita definir a quantidade de colunas para exibição dos itens do *checkbox*.
     * - É possível exibir as opções entre `1` e `4` colunas.
     * - Para resolução `sm` a colunagem invariavelmente passa para `1` coluna.
     * - Quando se trata de resolução `md` e o valor estabelecido para colunas for superior a `2`,
     * o *grid system* será composto por `2` colunas.
     *
     * \@default `2`
     *
     * @param {?} value
     * @return {?}
     */
    set columns(value) {
        /** @type {?} */
        const columns = convertToInt(value, thfCheckboxGroupColumnsDefaultLength);
        this._columns = this.getGridSystemColumns(columns, 4);
        this.mdColumns = this.getGridSystemColumns(columns, 2);
    }
    /**
     * @return {?}
     */
    get columns() {
        return this._columns;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita todos os itens do checkbox.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
        this.validateModel(this.checkIndeterminate());
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Caso exista a necessidade de usar o valor indeterminado (`null`) dentro da lista de opções, é necessário setar
     * a propriedade `t-indeterminate` como `true`, por padrão essa propriedade vem desabilitada (`false`).
     *
     * Quando essa propriedade é setada como `true`, o *thf-checkbox-group* passa a devolver um objeto completo para o
     * `ngModel`, diferente do array que contém apenas os valores selecionados.
     *
     * \@default `false`
     * @param {?} indeterminate
     * @return {?}
     */
    set indeterminate(indeterminate) {
        this._indeterminate = convertToBoolean(indeterminate);
    }
    /**
     * @return {?}
     */
    get indeterminate() {
        return this._indeterminate;
    }
    /**
     * \@optional
     *
     * \@description
     * Lista de opções que serão exibidas
     * Nesta propriedade deve ser definido um array de objetos que implementam a interface ThfCheckboxGroupOption
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = Array.isArray(value) ? value : [];
        this.removeDuplicatedOptions();
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.checkIndeterminate());
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @return {?}
     */
    changeValue() {
        /** @type {?} */
        const value = this.checkIndeterminate();
        if (this.propagateChange) {
            this.propagateChange(value);
        }
        else {
            this.ngModelChange.emit(value);
        }
        this.change.emit(value);
    }
    /**
     * @return {?}
     */
    checkIndeterminate() {
        return this.indeterminate ? this.checkedOptions : this.checkedOptionsList;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    checkOption(value) {
        if (!this._disabled && !value.disabled) {
            this.checkOptionModel(value);
            this.changeValue();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @param {?} optionsModel
     * @return {?}
     */
    writeValue(optionsModel) {
        if (optionsModel && this.checkedOptions !== optionsModel) {
            this.generateCheckOptions(optionsModel);
        }
        else {
            this.checkedOptionsList = [];
            this.checkedOptions = {};
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if ((!this.indeterminate && requiredFailed(this.required, this.disabled, abstractControl.value)) || this.isInvalidIndeterminate()) {
            return {
                required: {
                    valid: false,
                }
            };
        }
    }
    /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    validateModel(model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    /**
     * @private
     * @param {?} columns
     * @param {?} maxColumns
     * @return {?}
     */
    checkColumnsRange(columns, maxColumns) {
        /** @type {?} */
        const minColumns = 1;
        return columns >= minColumns && columns <= maxColumns;
    }
    /**
     * @private
     * @param {?} optionChecked
     * @return {?}
     */
    checkOptionModel(optionChecked) {
        this.checkedOptions[optionChecked.value] = !this.checkedOptions[optionChecked.value];
        if (!this.indeterminate && this.checkedOptionsList.includes(optionChecked.value)) {
            this.checkedOptionsList.splice(this.checkedOptionsList.indexOf(optionChecked.value), 1);
        }
        else if (!this.indeterminate) {
            this.checkedOptionsList.push(optionChecked.value);
        }
    }
    /**
     * @private
     * @param {?} optionsModel
     * @return {?}
     */
    generateCheckOptions(optionsModel) {
        this.checkedOptions = {};
        if (optionsModel instanceof Array) {
            this.checkedOptionsList = optionsModel;
            this.options.forEach((/**
             * @param {?} option
             * @return {?}
             */
            (option) => {
                this.checkedOptions[option.value] = optionsModel.includes(option.value);
            }));
        }
        else {
            this.options.forEach((/**
             * @param {?} option
             * @return {?}
             */
            (option) => {
                optionsModel[option.value] = optionsModel[option.value] === undefined ? false : optionsModel[option.value];
                this.checkedOptions = optionsModel;
            }));
        }
    }
    /**
     * @private
     * @param {?} columns
     * @param {?} maxColumns
     * @return {?}
     */
    getGridSystemColumns(columns, maxColumns) {
        /** @type {?} */
        const gridSystemColumns = thfCheckboxGroupColumnsTotalLength / columns;
        return this.checkColumnsRange(columns, maxColumns) ? gridSystemColumns : thfCheckboxGroupColumnsDefaultLength;
    }
    /**
     * @private
     * @return {?}
     */
    isInvalidIndeterminate() {
        if (this.indeterminate && this.required && this.checkedOptions) {
            return ((/** @type {?} */ (Object))).values(this.checkedOptions).every((/**
             * @param {?} value
             * @return {?}
             */
            value => value === false));
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    removeDuplicatedOptions() {
        this.options.forEach((/**
         * @param {?} option
         * @param {?} index
         * @return {?}
         */
        (option, index) => {
            /** @type {?} */
            const duplicatedIndex = this.options.findIndex((/**
             * @param {?} optionFind
             * @return {?}
             */
            (optionFind) => optionFind.value === option.value)) === index;
            if (!duplicatedIndex) {
                this.options.splice(this.options.indexOf(option), 1);
            }
        }));
    }
}
ThfCheckboxGroupBaseComponent.propDecorators = {
    name: [{ type: Input, args: ['name',] }],
    columns: [{ type: Input, args: ['t-columns',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    help: [{ type: Input, args: ['t-help',] }],
    indeterminate: [{ type: Input, args: ['t-indeterminate',] }],
    label: [{ type: Input, args: ['t-label',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    options: [{ type: Input, args: ['t-options',] }],
    required: [{ type: Input, args: ['t-required',] }],
    ngModelChange: [{ type: Output, args: ['ngModelChange',] }],
    change: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfCheckboxGroupBaseComponent
 *
 * \@example
 *
 * <example name="thf-checkbox-group-basic" title="Totvs Checkbox Group Basic">
 *  <file name="sample-thf-checkbox-group-basic/sample-thf-checkbox-group-basic.component.html"> </file>
 *  <file name="sample-thf-checkbox-group-basic/sample-thf-checkbox-group-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-checkbox-group-labs" title="Totvs Checkbox Group Labs">
 *  <file name="sample-thf-checkbox-group-labs/sample-thf-checkbox-group-labs.component.html"> </file>
 *  <file name="sample-thf-checkbox-group-labs/sample-thf-checkbox-group-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-checkbox-group-password-policy" title="Totvs Checkbox Group – Security policy">
 *  <file name="sample-thf-checkbox-group-password-policy/sample-thf-checkbox-group-password-policy.component.html"> </file>
 *  <file name="sample-thf-checkbox-group-password-policy/sample-thf-checkbox-group-password-policy.component.ts"> </file>
 * </example>
 */
class ThfCheckboxGroupComponent extends ThfCheckboxGroupBaseComponent {
    /**
     * @param {?} changeDetector
     */
    constructor(changeDetector) {
        super();
        this.changeDetector = changeDetector;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.changeDetector.detectChanges();
    }
    /**
     * @param {?} event
     * @param {?} option
     * @return {?}
     */
    onKeyDown(event, option) {
        /** @type {?} */
        const spaceBar = 32;
        if (event.which === spaceBar || event.keyCode === spaceBar) {
            this.checkOption(option);
            event.preventDefault();
        }
    }
}
ThfCheckboxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-checkbox-group',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content thf-checkbox-group-content\">\n    <div class=\"thf-row thf-pt-1 thf-pb-1\">\n\n      <div *ngFor=\"let option of options; let i = index\"\n        class=\"thf-checkbox-group-item thf-md-{{ mdColumns }} thf-lg-{{ columns }}\"\n        [class.thf-checkbox-group-item-disabled]=\"option.disabled || disabled\">\n\n        <input\n          class=\"thf-input thf-checkbox-group-input\"\n          type=\"checkbox\"\n          [class.thf-checkbox-group-input-checked]=\"checkedOptions[option.value]\"\n          [class.thf-checkbox-group-input-indeterminate]=\"checkedOptions[option.value] === null\"\n          [checked]=\"option.value\"\n          [disabled]=\"option.disabled || disabled\"\n          [id]=\"'checkbox_' + i\"\n          [required]=\"required\"\n          [value]=\"option.value\">\n\n        <label #checkboxLabel\n          class=\"thf-checkbox-group-label\"\n          [class.thf-clickable]=\"checkboxLabel.tabIndex === 0\"\n          [for]=\"'checkbox_' + i\"\n          [tabindex]=\"option.disabled || disabled ? -1 : 0\"\n          (click)=\"checkOption(option)\"\n          (keydown)=\"onKeyDown($event, option)\">\n            {{option.label}}\n        </label>\n      </div>\n\n    </div>\n  </div>\n\n  <thf-field-container-bottom></thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfCheckboxGroupComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfCheckboxGroupComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfCheckboxGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * Este componente é de uso interno utilizado por componentes de entrada de dados com o objetivo de resetar as informações do model.
 *
 * Por padrão limpa o valor do campo e executa o método onChangePropagate, caso tenha a necessidade de tratar a função de limpar o campo,
 * deve implementar a interface ThfClean.
 * @abstract
 */
class ThfCleanBaseComponent {
    constructor() {
        /**
         * Valor que será atribuído ao campo quando for clicado no thf-clean.
         */
        this.defaultValue = '';
        /**
         * Evento disparado quando executada ação do thf-clean.
         * Este evento deve ser usado para avisar para o componente que está usando o thf-clean, que o botão foi disparado,
         * e provavelmente será preciso emitir o evento para atualizar o model.
         */
        this.changeEvent = new EventEmitter();
    }
    /**
     * @return {?}
     */
    clear() {
        this.setInputValue(this.defaultValue);
        this.changeEvent.emit(this.defaultValue);
    }
    /**
     * @return {?}
     */
    showIcon() {
        return this.defaultValue !== this.getInputValue() && this.hasCleanAttr() && !this.isDisabled() && !this.isReadonly();
    }
    // Este método verifica se o componente pai possui a propriedade clean diferente de vazio,
    // ou seja, se o thf-clean deve ser usado.
    /**
     * @private
     * @return {?}
     */
    hasCleanAttr() {
        return this.parentComponent.clean;
    }
    // Este método verifica se o componente pai está desabilitado.
    /**
     * @private
     * @return {?}
     */
    isDisabled() {
        return this.parentComponent.disabled;
    }
    // Este método verifica se o componente pai está somente leitura.
    /**
     * @private
     * @return {?}
     */
    isReadonly() {
        return this.parentComponent.readonly;
    }
}
ThfCleanBaseComponent.propDecorators = {
    inputRef: [{ type: Input, args: ['t-element-ref',] }],
    defaultValue: [{ type: Input, args: ['t-default-value',] }],
    changeEvent: [{ type: Output, args: ['t-change-event',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfCleanBaseComponent
 *
 * \@examplePrivate
 *
 * <example-private name="thf-clean-labs" title="Totvs Clean Labs">
 *   <file name="sample-thf-clean-labs.component.html"> </file>
 *   <file name="sample-thf-clean-labs.component.ts"> </file>
 * </example-private>
 */
class ThfCleanComponent extends ThfCleanBaseComponent {
    /**
     * @param {?} viewRef
     */
    constructor(viewRef) {
        super();
        this.viewRef = viewRef;
        this.parentComponent = this.viewRef['_view']['component'];
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    setInputValue(value) {
        if (this.inputRef && this.inputRef.nativeElement) {
            this.inputRef.nativeElement.value = value;
        }
    }
    /**
     * @return {?}
     */
    getInputValue() {
        if (this.inputRef && this.inputRef.nativeElement) {
            return this.inputRef.nativeElement.value;
        }
    }
}
ThfCleanComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-clean',
                template: "<span *ngIf=\"showIcon()\"\n  class=\"thf-icon thf-field-icon thf-icon-close\"\n  (click)=\"clear()\">\n</span>\n"
            }] }
];
/** @nocollapse */
ThfCleanComponent.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfKeyCodeEnum = {
    /** Seta para baixo */
    arrowDown: 40,
    /** Seta para cima */
    arrowUp: 38,
    /** Backspace */
    backspace: 8,
    /** Delete */
    delete: 46,
    /** Enter */
    enter: 13,
    /** Esc */
    esc: 27,
    /** Espaço */
    space: 32,
    /** Tab */
    tab: 9,
};
ThfKeyCodeEnum[ThfKeyCodeEnum.arrowDown] = 'arrowDown';
ThfKeyCodeEnum[ThfKeyCodeEnum.arrowUp] = 'arrowUp';
ThfKeyCodeEnum[ThfKeyCodeEnum.backspace] = 'backspace';
ThfKeyCodeEnum[ThfKeyCodeEnum.delete] = 'delete';
ThfKeyCodeEnum[ThfKeyCodeEnum.enter] = 'enter';
ThfKeyCodeEnum[ThfKeyCodeEnum.esc] = 'esc';
ThfKeyCodeEnum[ThfKeyCodeEnum.space] = 'space';
ThfKeyCodeEnum[ThfKeyCodeEnum.tab] = 'tab';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfComboFilterMode = {
    /** Verifica se o texto *inicia* com o valor pesquisado. Caso não seja especificado um tipo, será esse o utilizado. */
    startsWith: 0,
    /** Verifica se o texto *contém* o valor pesquisado. */
    contains: 1,
    /** Verifica se o texto *finaliza* com o valor pesquisado. */
    endsWith: 2,
};
ThfComboFilterMode[ThfComboFilterMode.startsWith] = 'startsWith';
ThfComboFilterMode[ThfComboFilterMode.contains] = 'contains';
ThfComboFilterMode[ThfComboFilterMode.endsWith] = 'endsWith';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_COMBO_DEBOUNCE_TIME_DEFAULT = 400;
/** @type {?} */
const THF_COMBO_FIELD_LABEL_DEFAULT = 'label';
/** @type {?} */
const THF_COMBO_FIELD_VALUE_DEFAULT = 'value';
/** @type {?} */
const thfComboLiteralsDefault = {
    en: (/** @type {?} */ ({
        noData: 'No data found'
    })),
    es: (/** @type {?} */ ({
        noData: 'Datos no encontrados'
    })),
    pt: (/** @type {?} */ ({
        noData: 'Nenhum dado encontrado'
    }))
};
/**
 * \@description
 *
 * O thf-combo, semelhante ao thf-select, exibe uma lista de valores e permite ao usuário fazer a seleção de um desses valores,
 * mas no caso do thf-combo, o usuário ainda consegue filtrar os valores disponibilizados para seleção.
 *
 * Também há a possibilidade de usar serviço no thf-combo, através da propriedade t-filter-service.
 *
 * O comportamento do thf-combo permite ao usuário:
 *  - selecionar um item através do mouse;
 *  - navegar pelos itens utilizando as setas do teclado confirmando a seleção com "Enter";
 *  - pesquisar os itens da lista de seleção e em seguida navegar com as setas ou com o mouse;
 *  - digitar a descrição completa.
 *
 * O thf-combo guarda o último valor caso o usuário desista de uma busca, deixando o campo ou teclando "ESC".
 * Caso seja digitado no campo de busca a descrição completa de um item, então a seleção será automaticamente efetuada
 * ao deixar o campo ou pressionando "Enter".
 *
 * É necessário que os itens da lista de selecão contenham sempre valor (value) e descrição (label) para que os itens apareçam corretamente
 * no thf-combo, itens que não estejam implementando corretamenta a interface ThfComboOption, serão descartados.
 *
 * O thf-combo ainda permite definir o modo que será feito o filtro, através da propriedade t-filter-mode.
 * @abstract
 */
class ThfComboBaseComponent {
    constructor() {
        this._changeOnEnter = false;
        this._debounceTime = 400;
        this._disabled = false;
        this._disabledInitFilter = false;
        this._fieldLabel = 'label';
        this._fieldValue = 'value';
        this._filterMinlength = 0;
        this._filterMode = ThfComboFilterMode.startsWith;
        this._options = [];
        this._required = false;
        this.cacheOptions = [];
        this.cacheStaticOptions = [];
        this.firstInWriteValue = true;
        this.isFirstFilter = true;
        this.isFiltering = false;
        this.previousSearchValue = '';
        this.visibleOptions = [];
        /**
         * Mensagem apresentada enquanto o campo estiver vazio.
         */
        this.placeholder = '';
        /**
         * Indica que a lista definida na propriedade t-options será ordenada pela descrição.
         */
        this.sort = false;
        /**
         * Deve ser informada uma função que será disparada quando houver alterações no ngModel.
         */
        this.change = new EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     * Nesta propriedade deve ser informada a URL do serviço em que será realizado o filtro para carregamento da lista de
     * itens no componente.
     * Caso haja a necessidade de customização, então pode ser informado um serviço implementando a interface ThfComboFilter.
     *
     * Caso utilizado uma URL, o serviço deve ser retornado no padrão API TOTVS e utiliza as propriedades
     * `t-field-label` e `t-field-value` para a construção da lista de itens.
     *
     * Quando utilizada uma URL de serviço, então será concateanada nesta URL o valor que deseja-se filtrar da seguinte forma:
     * ```
     * url + ?filter=Peter
     * ```
     * @param {?} service
     * @return {?}
     */
    set filterService(service) {
        this._filterService = service;
        this.configAfterSetFilterService(service);
    }
    /**
     * @return {?}
     */
    get filterService() {
        return this._filterService;
    }
    /**
     * \@optional
     *
     * \@description
     * Esta propriedade define em quanto tempo (em milissegundos), aguarda para acionar o evento de filtro após cada pressionamento de tecla.
     * Será utilizada apenas quando houver serviço (`t-filter-service`).
     *
     * \@default `400`
     * @param {?} value
     * @return {?}
     */
    set debounceTime(value) {
        /** @type {?} */
        const parsedValue = parseInt((/** @type {?} */ (value)), 10);
        this._debounceTime = !isNaN(parsedValue) && parsedValue > 0 ? parsedValue : THF_COMBO_DEBOUNCE_TIME_DEFAULT;
        this.unsubscribeKeyupObservable();
        this.initInputObservable();
    }
    /**
     * @return {?}
     */
    get debounceTime() {
        return this._debounceTime;
    }
    /**
     * \@optional
     *
     * \@description
     * Desabilita o filtro inicial no serviço, que é executado no primeiro clique no campo.
     *
     * \@default `false`
     *
     * @param {?} value
     * @return {?}
     */
    set disabledInitFilter(value) {
        this._disabledInitFilter = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get disabledInitFilter() {
        return this._disabledInitFilter;
    }
    /**
     * \@optional
     *
     * \@description
     * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
     * (`t-options`), esta propriedade será responsável pelo valor de cada item da lista.
     *
     * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
     * ThfComboOption.
     *
     * \@default `value`
     * @param {?} value
     * @return {?}
     */
    set fieldValue(value) {
        this._fieldValue = value || THF_COMBO_FIELD_VALUE_DEFAULT;
        if (isTypeof(this.filterService, 'string') && this.service) {
            this.service.fieldValue = this._fieldValue;
        }
    }
    /**
     * @return {?}
     */
    get fieldValue() {
        return this._fieldValue;
    }
    /**
     * \@optional
     *
     * \@description
     * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
     * (`t-options`), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
     *
     * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
     * ThfComboOption.
     *
     * \@default `label`
     * @param {?} value
     * @return {?}
     */
    set fieldLabel(value) {
        this._fieldLabel = value || THF_COMBO_FIELD_LABEL_DEFAULT;
        if (isTypeof(this.filterService, 'string') && this.service) {
            this.service.fieldLabel = this._fieldLabel;
        }
    }
    /**
     * @return {?}
     */
    get fieldLabel() {
        return this._fieldLabel;
    }
    /**
     * \@optional
     *
     * \@description
     * Valor mínimo de caracteres para realizar o filtro no serviço.
     *
     * \@default `0`
     * @param {?} value
     * @return {?}
     */
    set filterMinlength(value) {
        /** @type {?} */
        const parseValue = (typeof value === 'string') ? parseInt(value, 10) : value;
        this._filterMinlength = Number.isInteger(parseValue) ? parseValue : 0;
    }
    /**
     * @return {?}
     */
    get filterMinlength() {
        return this._filterMinlength;
    }
    /**
     * \@optional
     *
     * \@description
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.selectedValue);
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * \@optional
     *
     * \@description
     * Indica que o evento `t-change` só será disparado ao clicar ou pressionar a tecla "Enter" sobre uma opção selecionada.
     *
     * \@default `false`
     * @param {?} changeOnEnter
     * @return {?}
     */
    set changeOnEnter(changeOnEnter) {
        this._changeOnEnter = convertToBoolean(changeOnEnter);
    }
    /**
     * @return {?}
     */
    get changeOnEnter() {
        return this._changeOnEnter;
    }
    /**
     * \@optional
     *
     * \@description
     * Indica que o campo será desabilitado.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = convertToBoolean(disabled);
        this.validateModel(this.selectedValue);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Nesta propriedade deve ser definida uma lista de objetos que implementam a interface ThfComboOption.
     * Esta lista conterá os valores e as descrições que serão apresentados na tela.
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        this._options = Array.isArray(options) ? options : [];
        this.cacheStaticOptions = this.options;
        this.validAndSortOptions();
        removeDuplicatedOptions(this.options);
        this.updateComboList();
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * @param {?} sort
     * @return {?}
     */
    set setSort(sort) {
        this.sort = sort === '' ? true : convertToBoolean(sort);
        this.validAndSortOptions();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define o modo de pesquisa utilizado no filtro da lista de seleção: `startsWith`, `contains` ou `endsWith`.
     *
     * > Quando utilizar a propriedade `t-filter-service` esta propriedade será ignorada.
     *
     * \@default `startsWith`
     * @param {?} filterMode
     * @return {?}
     */
    set filterMode(filterMode) {
        this._filterMode = (filterMode in ThfComboFilterMode) ? filterMode : ThfComboFilterMode.startsWith;
        switch (this._filterMode.toString()) {
            case 'startsWith':
                this._filterMode = ThfComboFilterMode.startsWith;
                break;
            case 'contains':
                this._filterMode = ThfComboFilterMode.contains;
                break;
            case 'endsWith':
                this._filterMode = ThfComboFilterMode.endsWith;
                break;
        }
    }
    /**
     * @return {?}
     */
    get filterMode() {
        return this._filterMode;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Valor que será repassado como parâmetro aos métodos do serviço que implementam a interface *ThfComboFilter*.
     * @param {?} filterParams
     * @return {?}
     */
    set filterParams(filterParams) {
        this._filterParams = (filterParams || filterParams === 0 || filterParams === false) ? filterParams : undefined;
    }
    /**
     * @return {?}
     */
    get filterParams() {
        return this._filterParams;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-combo`.
     *
     * Para utilizar basta passar a literal que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfComboLiterals = {
     *    noData: 'Nenhum valor'
     *  };
     * ```
     *
     * E para carregar a literal customizada, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-combo
     *   [t-literals]="customLiterals">
     * </thf-combo>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfComboLiteralsDefault[thfLocaleDefault], thfComboLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfComboLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfComboLiteralsDefault[browserLanguage()];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateComboList();
    }
    /**
     * @return {?}
     */
    onInitService() {
        if (this.filterService) {
            this.setService(this.filterService);
            this.initInputObservable();
        }
    }
    /**
     * @param {?} service
     * @return {?}
     */
    setService(service) {
        if (service) {
            if (isTypeof(service, 'object')) {
                this.service = (/** @type {?} */ (service));
            }
            else {
                this.service = this.defaultService;
                this.service.configProperties((/** @type {?} */ (service)), this.fieldLabel, this.fieldValue);
            }
        }
    }
    /**
     * @return {?}
     */
    validAndSortOptions() {
        if (this.options && this.options.length > 0) {
            // Remove os objetos que não contém valor e atribui o valor ao label caso este esteja vazio
            for (let i = 0; i < this.options.length; i++) {
                if (!validValue(this.options[i]['value'])) {
                    this.options.splice(i, 1);
                }
                else if (!this.options[i]['label']) {
                    this.options[i]['label'] = this.options[i]['value'].toString();
                }
            }
        }
        this.sortOptions();
    }
    /**
     * @return {?}
     */
    sortOptions() {
        if (this.options && this.options.length > 0 && this.sort) {
            this.options.sort(this.compareOptions);
        }
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    compareOptions(a, b) {
        if (a.label.toString().toLowerCase() < b.label.toString().toLowerCase()) {
            return -1;
        }
        if (a.label.toString().toLowerCase() > b.label.toString().toLowerCase()) {
            return 1;
        }
        return 0;
    }
    /**
     * @param {?} search
     * @param {?} option
     * @param {?} filterMode
     * @return {?}
     */
    compareMethod(search, option, filterMode) {
        switch (filterMode) {
            case ThfComboFilterMode.startsWith:
                return this.startsWith(search, option);
            case ThfComboFilterMode.contains:
                return this.contains(search, option);
            case ThfComboFilterMode.endsWith:
                return this.endsWith(search, option);
        }
    }
    /**
     * @param {?} search
     * @param {?} option
     * @return {?}
     */
    startsWith(search, option) {
        return option.label.toLowerCase().startsWith(search.toLowerCase());
    }
    /**
     * @param {?} search
     * @param {?} option
     * @return {?}
     */
    contains(search, option) {
        return option.label.toLowerCase().indexOf(search.toLowerCase()) > -1;
    }
    /**
     * @param {?} search
     * @param {?} option
     * @return {?}
     */
    endsWith(search, option) {
        return option.label.toLowerCase().endsWith(search.toLowerCase());
    }
    /**
     * @param {?} value
     * @param {?} options
     * @return {?}
     */
    getOptionFromValue(value, options) {
        return (options) ? options.find((/**
         * @param {?} option
         * @return {?}
         */
        (option) => this.isEqual(option.value, value))) : null;
    }
    /**
     * @param {?} label
     * @param {?} options
     * @return {?}
     */
    getOptionFromLabel(label, options) {
        if (options) {
            return options.find((/**
             * @param {?} option
             * @return {?}
             */
            (option) => {
                return option.label.toString().toLowerCase() === label.toString().toLowerCase();
            }));
        }
        else {
            return null;
        }
    }
    /**
     * @param {?} option
     * @param {?=} isUpdateModel
     * @param {?=} isWriteValue
     * @return {?}
     */
    updateSelectedValue(option, isUpdateModel = true, isWriteValue = false) {
        /** @type {?} */
        const optionLabel = option && option.label || '';
        this.updateInternalVariables(option);
        // atualiza o valor do input quando for changeOnEnter apenas se for para atualizar o model.
        if (this.changeOnEnter && isUpdateModel) {
            this.setInputValue(optionLabel);
        }
        else if (!this.changeOnEnter) {
            this.setInputValue(optionLabel);
        }
        if (isUpdateModel) {
            /** @type {?} */
            const optionValue = option && option.value || undefined;
            this.updateModel(optionValue, isWriteValue);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    callModelChange(value) {
        // Caso o componente estiver dentro de um form, terá acesso ao método onModelChange.
        return (this.onModelChange) ? this.onModelChange(value) : this.ngModelChange.emit(value);
    }
    /**
     * @param {?} value
     * @param {?} inputValue
     * @return {?}
     */
    isEqual(value, inputValue) {
        if ((value || value === 0) && inputValue) {
            return value.toString() === inputValue.toString();
        }
        if ((value === null && inputValue !== null) ||
            (value === undefined && inputValue !== undefined)) {
            value = `${value}`; // Transformando em string
        }
        return value === inputValue;
    }
    /**
     * @param {?} search
     * @param {?} options
     * @param {?} filterMode
     * @return {?}
     */
    searchForLabel(search, options, filterMode) {
        if (search && options && options.length) {
            /** @type {?} */
            const newOptions = [];
            options.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => {
                if (option.label && (this.compareMethod(search, option, filterMode) || this.service)) {
                    newOptions.push(option);
                }
            }));
            this.selectedView = newOptions[0];
            this.updateComboList(newOptions);
        }
        else {
            this.updateComboList();
        }
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    updateComboList(options) {
        /** @type {?} */
        const copyOptions = options || [...this.options];
        /** @type {?} */
        const newOptions = !options && this.selectedValue ? [Object.assign({}, this.selectedOption)] : copyOptions;
        if (newOptions) {
            this.visibleOptions = newOptions;
            if (!this.selectedView && this.visibleOptions.length) {
                this.selectedView = this.visibleOptions[0];
            }
        }
    }
    /**
     * @param {?} value
     * @param {?} options
     * @param {?=} reverse
     * @return {?}
     */
    getNextOption(value, options, reverse = false) {
        /** @type {?} */
        const newOptions = [].concat(options);
        /** @type {?} */
        let optionFound = null;
        /** @type {?} */
        let found = false;
        if (reverse) {
            newOptions.reverse();
        }
        for (let i = 0; i < newOptions.length; i++) {
            /** @type {?} */
            const option = newOptions[i];
            if (!optionFound) {
                optionFound = option;
            }
            if (found) {
                return option;
            }
            if (this.isEqual(option.value, value)) {
                found = true;
            }
        }
        return optionFound;
    }
    /**
     * @return {?}
     */
    getIndexSelectedView() {
        for (let i = 0; i < this.visibleOptions.length; i++) {
            if (this.compareObjects(this.visibleOptions[i], this.selectedView)) {
                return i;
            }
        }
        return null;
    }
    /**
     * @param {?} obj1
     * @param {?} obj2
     * @return {?}
     */
    compareObjects(obj1, obj2) {
        return JSON.stringify(obj1) === JSON.stringify(obj2);
    }
    /**
     * @return {?}
     */
    verifyValidOption() {
        /** @type {?} */
        const inputValue = this.getInputValue();
        /** @type {?} */
        const optionFound = this.getOptionFromLabel(inputValue, this.options);
        if (optionFound && optionFound.value !== this.selectedValue) {
            this.updateSelectedValue(optionFound);
            this.previousSearchValue = optionFound.label;
            return;
        }
        else if (this.selectedValue && this.selectedOption && this.selectedOption.label !== inputValue) {
            this.updateSelectedValueWithOldOption();
            this.previousSearchValue = this.selectedOption.label;
            return;
        }
        else if (inputValue && !optionFound) {
            /** @type {?} */
            const isInputValueDiffSelectedLabel = !!(this.selectedOption && this.selectedOption.label !== inputValue);
            this.updateSelectedValue(null, isInputValueDiffSelectedLabel || this.changeOnEnter);
            this.previousSearchValue = '';
            return;
        }
    }
    // Recebe as alterações do model
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (validValue(value) && !this.service && this.options && this.options.length) {
            /** @type {?} */
            const option = this.getOptionFromValue(value, this.options);
            this.updateSelectedValue(option);
            this.updateComboList();
            return;
        }
        // Se houver serviço busca pelo model.
        if (value && this.service) {
            return this.getObjectByValue(value);
        }
        if (!validValue(value)) {
            this.updateSelectedValue(null, true, true);
            this.updateComboList();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if ((requiredFailed(this.required, this.disabled, abstractControl.value))) {
            return {
                required: {
                    valid: false,
                }
            };
        }
    }
    /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    validateModel(model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    /**
     * @private
     * @param {?} service
     * @return {?}
     */
    configAfterSetFilterService(service) {
        if (service) {
            this.options = [];
            this.unsubscribeKeyupObservable();
            this.onInitService();
        }
        else {
            this.service = undefined;
            this.options = this.cacheStaticOptions;
        }
        this.visibleOptions = [];
        this.isFirstFilter = true;
    }
    /**
     * @private
     * @return {?}
     */
    unsubscribeKeyupObservable() {
        if (this.keyupSubscribe) {
            this.keyupSubscribe.unsubscribe();
        }
    }
    /**
     * @private
     * @param {?} option
     * @return {?}
     */
    updateInternalVariables(option) {
        if (option) {
            this.selectedView = option;
            this.selectedOption = option;
        }
        else {
            this.selectedView = undefined;
            this.selectedOption = undefined;
        }
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} fromWriteValue
     * @return {?}
     */
    updateModel(value, fromWriteValue = false) {
        if (value !== this.selectedValue) {
            if (!fromWriteValue) {
                this.callModelChange(value);
            }
            this.change.emit(value);
        }
        this.selectedValue = value;
    }
    /**
     * @private
     * @return {?}
     */
    updateSelectedValueWithOldOption() {
        /** @type {?} */
        const oldOption = this.getOptionFromValue(this.selectedValue, this.options);
        if (oldOption && oldOption.label) {
            return this.updateSelectedValue(oldOption);
        }
    }
}
ThfComboBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    name: [{ type: Input, args: ['name',] }],
    filterService: [{ type: Input, args: ['t-filter-service',] }],
    debounceTime: [{ type: Input, args: ['t-debounce-time',] }],
    disabledInitFilter: [{ type: Input, args: ['t-disabled-init-filter',] }],
    fieldValue: [{ type: Input, args: ['t-field-value',] }],
    fieldLabel: [{ type: Input, args: ['t-field-label',] }],
    filterMinlength: [{ type: Input, args: ['t-filter-minlength',] }],
    required: [{ type: Input, args: ['t-required',] }],
    changeOnEnter: [{ type: Input, args: ['t-change-on-enter',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    icon: [{ type: Input, args: ['t-icon',] }],
    options: [{ type: Input, args: ['t-options',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    setSort: [{ type: Input, args: ['t-sort',] }],
    filterMode: [{ type: Input, args: ['t-filter-mode',] }],
    filterParams: [{ type: Input, args: ['t-filter-params',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    change: [{ type: Output, args: ['t-change',] }],
    ngModelChange: [{ type: Output, args: ['ngModelChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço padrão utilizado para filtrar os dados do componente thf-combo.
 */
class ThfComboFilterService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.fieldLabel = 'label';
        this.fieldValue = 'value';
    }
    /**
     * @return {?}
     */
    get url() { return this._url; }
    /**
     * @param {?} param
     * @param {?=} filterParams
     * @return {?}
     */
    getFilteredData(param, filterParams) {
        /** @type {?} */
        const value = param.value;
        /** @type {?} */
        const params = new HttpParams({
            fromString: `filter=${value}`
        });
        return this.http.get(`${this.url}`, { responseType: 'json', params: params })
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => this.parseToArrayComboOption(response.items))));
    }
    /**
     * @param {?} value
     * @param {?=} filterParams
     * @return {?}
     */
    getObjectByValue(value, filterParams) {
        return this.http.get(`${this.url}/${value}`).pipe(map((/**
         * @param {?} item
         * @return {?}
         */
        item => this.parseToComboOption(item))));
    }
    /**
     * @param {?} url
     * @param {?} fieldLabel
     * @param {?} fieldValue
     * @return {?}
     */
    configProperties(url, fieldLabel, fieldValue) {
        this._url = url;
        this.fieldLabel = fieldLabel;
        this.fieldValue = fieldValue;
    }
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    parseToArrayComboOption(items) {
        if (items && items.length > 0) {
            return items.map((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return this.parseToComboOption(item);
            }));
        }
        return [];
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    parseToComboOption(item) {
        if (item && item[this.fieldValue]) {
            /** @type {?} */
            const label = item[this.fieldLabel];
            /** @type {?} */
            const value = item[this.fieldValue];
            return { label, value };
        }
    }
}
ThfComboFilterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfComboFilterService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfComboContainerOffset = 8;
/** @type {?} */
const thfComboContainerPositionDefault = 'bottom';
/**
 * \@docsExtends ThfComboBaseComponent
 *
 * \@description
 * Utilizando thf-combo com serviço, é possivel digitar um valor no campo de entrada e pressionar a tecla 'tab' para que o componente
 * faça uma requisição à URL informada passando o valor digitado no campo. Se encontrado o valor, então o mesmo será selecionado, caso
 * não seja encontrado, então a lista de itens voltará para o estado inicial.
 *
 * \@example
 *
 * <example name="thf-combo-basic" title="Totvs Combo Basic">
 *   <file name="sample-thf-combo-basic/sample-thf-combo-basic.component.html"> </file>
 *   <file name="sample-thf-combo-basic/sample-thf-combo-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-combo-labs" title="Totvs Combo Labs">
 *   <file name="sample-thf-combo-labs/sample-thf-combo-labs.component.html"> </file>
 *   <file name="sample-thf-combo-labs/sample-thf-combo-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-combo-scheduling" title="Totvs Combo - Scheduling">
 *   <file name="sample-thf-combo-scheduling/sample-thf-combo-scheduling.component.html"> </file>
 *   <file name="sample-thf-combo-scheduling/sample-thf-combo-scheduling.component.ts"> </file>
 * </example>
 *
 * <example name="thf-combo-transfer" title="Totvs Combo - Banking Transfer">
 *   <file name="sample-thf-combo-transfer/sample-thf-combo-transfer.component.html"> </file>
 *   <file name="sample-thf-combo-transfer/sample-thf-combo-transfer.component.ts"> </file>
 * </example>
 *
 * <example name="thf-combo-heroes" title="Totvs Combo - Heroes">
 *   <file name="sample-thf-combo-heroes/sample-thf-combo-heroes.component.html"> </file>
 *   <file name="sample-thf-combo-heroes/sample-thf-combo-heroes.component.ts"> </file>
 * </example>
 *
 * <example name="thf-combo-heroes-reactive-form" title="Totvs Combo - Heroes Reactive Form">
 *   <file name="sample-thf-combo-heroes-reactive-form/sample-thf-combo-heroes-reactive-form.component.html"> </file>
 *   <file name="sample-thf-combo-heroes-reactive-form/sample-thf-combo-heroes-reactive-form.component.ts"> </file>
 * </example>
 *
 * <example name="thf-combo-hotels" title="Totvs Combo - Booking Hotel">
 *   <file name="sample-thf-combo-hotels/sample-thf-combo-hotels.component.html"> </file>
 *   <file name="sample-thf-combo-hotels/sample-thf-combo-hotels.component.ts"> </file>
 *   <file name="sample-thf-combo-hotels/sample-thf-combo-hotels.service.ts"> </file>
 * </example>
 */
class ThfComboComponent extends ThfComboBaseComponent {
    /**
     * @param {?} element
     * @param {?} differs
     * @param {?} defaultService
     * @param {?} renderer
     * @param {?} changeDetector
     * @param {?} controlPosition
     * @param {?} sanitized
     */
    constructor(element, differs, defaultService, renderer, changeDetector, controlPosition, sanitized) {
        super();
        this.element = element;
        this.differs = differs;
        this.defaultService = defaultService;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        this.controlPosition = controlPosition;
        this.sanitized = sanitized;
        this._isServerSearching = false;
        this.comboIcon = 'thf-icon-arrow-down';
        this.comboOpen = false;
        this.isProcessingGetObjectByValue = false;
        this.scrollTop = 0;
        this.shouldMarkLetters = true;
        this.onScroll = (/**
         * @return {?}
         */
        () => {
            this.adjustContainerPosition();
        });
        this.differ = differs.find([]).create(null);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isServerSearching(value) {
        if (value) {
            this._isServerSearching = value;
            this.changeDetector.detectChanges();
            this.setContainerPosition();
            this.initializeListeners();
        }
        else {
            this._isServerSearching = value;
            this.removeListeners();
        }
    }
    /**
     * @return {?}
     */
    get isServerSearching() {
        return this._isServerSearching;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const change = this.differ.diff(this.options);
        if (change) {
            this.validAndSortOptions();
            removeDuplicatedOptions(this.options);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
        if (this.filterSubscription) {
            this.filterSubscription.unsubscribe();
        }
        if (this.getSubscription) {
            this.getSubscription.unsubscribe();
        }
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onKeyDown(event) {
        /** @type {?} */
        const key = event.keyCode;
        /** @type {?} */
        const inputValue = event.target.value;
        // busca um registro quando acionar o tab
        if (this.service && key === ThfKeyCodeEnum.tab && inputValue) {
            this.controlComboVisibility(false);
            return this.getObjectByValue(inputValue);
        }
        // Teclas "up" e "down"
        if (key === ThfKeyCodeEnum.arrowUp || key === ThfKeyCodeEnum.arrowDown) {
            event.preventDefault();
            if (this.comboOpen) {
                if (key === ThfKeyCodeEnum.arrowUp) {
                    this.selectPreviousOption();
                }
                else {
                    this.selectNextOption();
                }
            }
            this.controlComboVisibility(true);
            this.isFiltering = this.changeOnEnter ? this.isFiltering : false;
            this.shouldMarkLetters = this.changeOnEnter ? this.shouldMarkLetters : false;
            return;
        }
        // Teclas "tab" ou "esc"
        if (key === ThfKeyCodeEnum.tab || key === ThfKeyCodeEnum.esc) {
            if (key === ThfKeyCodeEnum.esc && this.comboOpen) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.controlComboVisibility(false);
            this.verifyValidOption();
            if (!this.service) {
                // caso for changeOnEnter e nao ter selectedValue deve limpar o selectedView para reinicia-lo.
                this.selectedView = this.changeOnEnter && !this.selectedValue ? undefined : this.selectedView;
                this.updateComboList();
            }
            return;
        }
        // Tecla "enter"
        if (key === ThfKeyCodeEnum.enter && this.selectedView && this.comboOpen) {
            /** @type {?} */
            const isUpdateModel = (this.selectedView.value !== this.selectedValue) || (inputValue !== this.selectedView.label);
            this.controlComboVisibility(false);
            this.updateSelectedValue(this.selectedView, isUpdateModel);
            this.isFiltering = false;
            this.updateComboList();
            return;
        }
        if (key === ThfKeyCodeEnum.enter) {
            this.controlComboVisibility(true);
        }
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onKeyUp(event) {
        /** @type {?} */
        const key = event.keyCode || event.which;
        /** @type {?} */
        const inputValue = event.target.value;
        /** @type {?} */
        const isValidKey = (key !== ThfKeyCodeEnum.arrowUp && key !== ThfKeyCodeEnum.arrowDown && key !== ThfKeyCodeEnum.enter);
        if (isValidKey) {
            if (inputValue) {
                if (!this.service && this.previousSearchValue !== inputValue) {
                    this.shouldMarkLetters = true;
                    this.isFiltering = true;
                    this.searchForLabel(inputValue, this.options, this.filterMode);
                }
            }
            else {
                // quando apagar rapido o campo e conter serviço, valor, não disparava o keyup observable
                // necessario este tratamento para retornar a lista 'default'.
                /** @type {?} */
                const useDefaultOptionsService = this.service && this.selectedValue && this.selectedOption.label === this.previousSearchValue;
                this.updateSelectedValue(null);
                if (!this.service) {
                    this.updateComboList();
                }
                else if (useDefaultOptionsService) {
                    this.updateComboList([...this.cacheOptions]);
                }
                this.isFiltering = false;
            }
            // caso o valor pesquisado for diferente do anterior deve abrir o combo
            if (this.previousSearchValue !== inputValue) {
                this.changeDetector.detectChanges();
                this.controlComboVisibility(true);
            }
        }
        this.previousSearchValue = inputValue;
    }
    /**
     * @return {?}
     */
    initInputObservable() {
        if (this.service) {
            /** @type {?} */
            const keyupObservable = fromEvent(this.inputElement.nativeElement, 'keyup')
                .pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            (e) => this.isValidCharacterToSearch(e.keyCode))), map((/**
             * @param {?} e
             * @return {?}
             */
            (e) => e.currentTarget.value)), distinctUntilChanged(), tap((/**
             * @return {?}
             */
            () => {
                this.shouldMarkLetters = false;
            })), debounceTime(this.debounceTime));
            this.keyupSubscribe = keyupObservable.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                if (value.length >= this.filterMinlength || !value) {
                    this.controlApplyFilter(value);
                }
            }));
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    controlApplyFilter(value) {
        if (!this.isProcessingGetObjectByValue && (!this.selectedOption || value !== this.selectedOption.label)) {
            this.applyFilter(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    applyFilter(value) {
        this.controlComboVisibility(false);
        this.isServerSearching = true;
        /** @type {?} */
        const param = { property: this.fieldLabel, value };
        this.filterSubscription = this.service.getFilteredData(param, this.filterParams)
            .subscribe((/**
         * @param {?} items
         * @return {?}
         */
        items => this.setOptionsByApplyFilter(value, items)));
    }
    /**
     * @param {?} value
     * @param {?} items
     * @return {?}
     */
    setOptionsByApplyFilter(value, items) {
        this.shouldMarkLetters = true;
        this.isServerSearching = false;
        this.options = items;
        this.searchForLabel(value, items, this.filterMode);
        this.changeDetector.detectChanges();
        this.controlComboVisibility(true);
        if (this.isFirstFilter) {
            this.isFirstFilter = !this.isFirstFilter;
            this.cacheOptions = this.options;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getObjectByValue(value) {
        if (!this.selectedValue) {
            this.isProcessingGetObjectByValue = true;
            this.getSubscription = this.service.getObjectByValue(value, this.filterParams)
                .subscribe((/**
             * @param {?} item
             * @return {?}
             */
            item => this.updateOptionByFilteredValue(item)));
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    updateOptionByFilteredValue(item) {
        if (item) {
            this.options = [item];
            this.onOptionClick(item);
        }
        else {
            this.updateSelectedValue(null);
        }
        setTimeout((/**
         * @return {?}
         */
        () => { this.isProcessingGetObjectByValue = false; }), this.debounceTime);
    }
    /**
     * @return {?}
     */
    selectPreviousOption() {
        /** @type {?} */
        const currentViewValue = this.selectedView && this.selectedView.value;
        if (currentViewValue) {
            /** @type {?} */
            const nextOption = this.getNextOption(currentViewValue, this.visibleOptions, true);
            this.updateSelectedValue(nextOption, nextOption && nextOption.value !== currentViewValue && !this.changeOnEnter);
        }
        else if (this.visibleOptions.length) {
            /** @type {?} */
            const visibleOption = this.visibleOptions[this.visibleOptions.length - 1];
            this.updateSelectedValue(visibleOption, visibleOption.value !== currentViewValue && !this.changeOnEnter);
        }
    }
    /**
     * @return {?}
     */
    selectNextOption() {
        /** @type {?} */
        const currentViewValue = this.selectedView && this.selectedView.value;
        if (currentViewValue) {
            /** @type {?} */
            const nextOption = this.getNextOption(currentViewValue, this.visibleOptions);
            this.updateSelectedValue(nextOption, nextOption && nextOption.value !== currentViewValue && !this.changeOnEnter);
        }
        else if (this.visibleOptions.length) {
            /** @type {?} */
            const index = this.changeOnEnter ? 1 : 0;
            /** @type {?} */
            const visibleOption = this.visibleOptions[index];
            this.updateSelectedValue(visibleOption, visibleOption.value !== currentViewValue && !this.changeOnEnter);
        }
    }
    /**
     * @return {?}
     */
    toggleComboVisibility() {
        if (this.disabled) {
            return;
        }
        if (this.service && !this.disabledInitFilter) {
            this.applyFilterInFirstClick();
        }
        this.controlComboVisibility(!this.comboOpen);
    }
    /**
     * @return {?}
     */
    applyFilterInFirstClick() {
        if (this.isFirstFilter && !this.selectedValue) {
            this.applyFilter('');
        }
    }
    /**
     * @param {?} toOpen
     * @return {?}
     */
    controlComboVisibility(toOpen) {
        toOpen ? this.open() : this.close();
    }
    /**
     * @param {?} option
     * @return {?}
     */
    onOptionClick(option) {
        /** @type {?} */
        const inputValue = this.getInputValue();
        /** @type {?} */
        const isUpdateModel = (option.value !== this.selectedValue) || !!(this.selectedView && inputValue !== this.selectedView.label);
        this.updateSelectedValue(option, isUpdateModel);
        this.controlComboVisibility(false);
        this.updateComboList([Object.assign({}, this.selectedView)]);
        this.previousSearchValue = this.selectedView.label;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    scrollTo(index) {
        /** @type {?} */
        const scrollTop = (index <= 2) ? 0 : (index * 44) - 88;
        this.setScrollTop(scrollTop);
    }
    /**
     * @return {?}
     */
    getInputValue() {
        return this.inputElement.nativeElement.value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setInputValue(value) {
        this.inputElement.nativeElement.value = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    wasClickedOnToggle(event) {
        if (this.comboOpen &&
            !this.inputElement.nativeElement.contains(event.target) &&
            !this.iconElement.nativeElement.contains(event.target) &&
            (!this.contentElement || !this.contentElement.nativeElement.contains(event.target))) {
            // Esconde Content do Combo quando for clicado fora
            this.controlComboVisibility(false);
            this.verifyValidOption();
            // caso for changeOnEnter deve limpar o selectedView para reinicia-lo
            this.selectedView = this.changeOnEnter && !this.selectedValue ? undefined : this.selectedView;
            this.updateComboList();
        }
        else {
            if (this.service && !this.getInputValue() && !this.isFirstFilter) {
                this.applyFilter('');
            }
        }
    }
    /**
     * @param {?} label
     * @return {?}
     */
    getLabelFormatted(label) {
        /** @type {?} */
        let format = label;
        if (this.isFiltering ||
            (this.service && this.getInputValue() && !this.compareObjects(this.cacheOptions, this.visibleOptions) && this.shouldMarkLetters)) {
            /** @type {?} */
            const labelInput = this.getInputValue().toString().toLowerCase();
            /** @type {?} */
            const labelLowerCase = label.toLowerCase();
            /** @type {?} */
            const openTagBold = '<span class="thf-font-text-large-bold">';
            /** @type {?} */
            const closeTagBold = '</span>';
            /** @type {?} */
            let startString;
            /** @type {?} */
            let middleString;
            /** @type {?} */
            let endString;
            switch (this.filterMode) {
                case ThfComboFilterMode.startsWith:
                case ThfComboFilterMode.contains:
                    startString = label.substring(0, labelLowerCase.indexOf(labelInput));
                    middleString = label.substring(labelLowerCase.indexOf(labelInput), labelLowerCase.indexOf(labelInput) + labelInput.length);
                    endString = label.substring(labelLowerCase.indexOf(labelInput) + labelInput.length);
                    format = startString + openTagBold + middleString + closeTagBold + endString;
                    break;
                case ThfComboFilterMode.endsWith:
                    startString = label.substring(0, labelLowerCase.lastIndexOf(labelInput));
                    middleString = label.substring(labelLowerCase.lastIndexOf(labelInput));
                    format = startString + openTagBold + middleString + closeTagBold;
                    break;
            }
        }
        return this.safeHtml(format);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    safeHtml(value) {
        return this.sanitized.bypassSecurityTrustHtml(value);
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    isValidCharacterToSearch(keyCode) {
        return (keyCode !== 9 && // tab
            keyCode !== 13 && // entet
            keyCode !== 16 && // shift
            keyCode !== 17 && // ctrl
            keyCode !== 18 && // alt
            keyCode !== 20 && // capslock
            keyCode !== 27 && // esc
            keyCode !== 37 && // seta
            keyCode !== 38 && // seta
            keyCode !== 39 && // seta
            keyCode !== 40 && // seta
            keyCode !== 93); // windows menu
    }
    /**
     * @param {?} value
     * @return {?}
     */
    searchOnEnter(value) {
        if (this.service && !this.selectedView && value.length >= this.filterMinlength) {
            this.controlApplyFilter(value);
        }
    }
    /**
     * @private
     * @return {?}
     */
    adjustContainerPosition() {
        this.controlPosition.adjustPosition(thfComboContainerPositionDefault);
    }
    /**
     * @private
     * @return {?}
     */
    close() {
        this.comboOpen = false;
        this.changeDetector.detectChanges();
        this.comboIcon = 'thf-icon-arrow-down';
        this.removeListeners();
        this.isFiltering = false;
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.removeListeners();
        this.clickoutListener = this.renderer.listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.wasClickedOnToggle(event);
        }));
        this.eventResizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            // timeout necessario pois a animação do thf-menu impacta no ajuste da posição do container.
            setTimeout((/**
             * @return {?}
             */
            () => this.adjustContainerPosition()), 250);
        }));
        window.addEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    open() {
        this.comboOpen = true;
        this.changeDetector.detectChanges();
        this.comboIcon = 'thf-icon-arrow-up';
        this.initializeListeners();
        this.inputElement.nativeElement.focus();
        this.scrollTo(this.getIndexSelectedView());
        this.setContainerPosition();
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.clickoutListener) {
            this.clickoutListener();
        }
        if (this.eventResizeListener) {
            this.eventResizeListener();
        }
        window.removeEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    setContainerPosition() {
        this.controlPosition.setElements(this.containerElement.nativeElement, thfComboContainerOffset, this.inputElement, ['top', 'bottom'], true);
        this.adjustContainerPosition();
    }
    /**
     * @private
     * @param {?} scrollTop
     * @return {?}
     */
    setScrollTop(scrollTop) {
        if (this.contentElement) {
            this.contentElement.nativeElement.scrollTop = scrollTop;
        }
    }
}
ThfComboComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-combo',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <div *ngIf=\"icon\" class=\"thf-field-icon-container-left\">\n      <span class=\"thf-icon thf-field-icon {{icon}}\" [class.thf-field-icon-disabled]=\"disabled\"></span>\n    </div>\n\n    <input #inputElement\n      class=\"thf-input thf-combo-input\"\n      [class.thf-input-icon-left]=\"icon\"\n      autocomplete=\"off\"\n      type=\"text\"\n      [attr.name]=\"name\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [required]=\"required\"\n      (click)=\"toggleComboVisibility()\"\n      (keyup)=\"onKeyUp($event)\"\n      (keyup.enter)=\"searchOnEnter($event.target.value)\"\n      (keydown)=\"onKeyDown($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <span #iconArrow\n        class=\"thf-icon thf-field-icon {{ comboIcon }}\"\n        [class.thf-field-icon-disabled]=\"disabled\"\n        [class.thf-field-icon]=\"!disabled\"\n        (click)=\"toggleComboVisibility()\">\n      </span>\n    </div>\n  </div>\n\n  <div #containerElement class=\"thf-combo-container\" [hidden]=\"!comboOpen && !isServerSearching\">\n\n    <ng-container *ngIf=\"isServerSearching; then loadingTemplate; else optionsTemplate\">\n    </ng-container>\n\n  </div>\n\n  <thf-field-container-bottom></thf-field-container-bottom>\n\n</thf-field-container>\n\n<ng-template #loadingTemplate>\n  <div class=\"thf-combo-container-loading\">\n    <thf-loading></thf-loading>\n  </div>\n</ng-template>\n\n<ng-template #optionsTemplate>\n  <ng-container *ngIf=\"visibleOptions.length; then visibleOptionsTemplate ; else noDataTemplate\">\n  </ng-container>\n</ng-template>\n\n<ng-template #visibleOptionsTemplate>\n  <ul #contentElement class=\"thf-combo-container-content\">\n    <li *ngFor=\"let option of visibleOptions\"\n      [class.thf-combo-item-selected]=\"compareObjects(selectedView, option)\"\n      (click)=\"onOptionClick(option)\">\n      <a class=\"thf-combo-item\" [innerHTML]=\"getLabelFormatted(option?.label)\"></a>\n    </li>\n  </ul>\n</ng-template>\n\n<ng-template #noDataTemplate>\n  <div class=\"thf-combo-container-no-data\">\n    <div class=\"thf-combo-no-data thf-text-center\">\n      <span>\n        {{ literals.noData }}\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
                providers: [
                    ThfComboFilterService,
                    ThfControlPositionService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfComboComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfComboComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfComboComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers },
    { type: ThfComboFilterService },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: ThfControlPositionService },
    { type: DomSanitizer }
];
ThfComboComponent.propDecorators = {
    containerElement: [{ type: ViewChild, args: ['containerElement', { read: ElementRef, static: false },] }],
    contentElement: [{ type: ViewChild, args: ['contentElement', { read: ElementRef, static: false },] }],
    iconElement: [{ type: ViewChild, args: ['iconArrow', { read: ElementRef, static: true },] }],
    inputElement: [{ type: ViewChild, args: ['inputElement', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Para usar o thf-mask é preciso instanciar esta classe passando a máscara como
 * primeiro parâmetro, e no segundo parâmetro, deve se informado true, caso queira
 * que o model seja formatado ou false para o que o model seja limpo.
 */
class ThfMask {
    /**
     * @param {?} mask
     * @param {?} formatModel
     */
    constructor(mask, formatModel) {
        this.mask = '';
        this.formatModel = false;
        // controle de posição
        this.initialPosition = 0;
        this.finalPosition = 0;
        this.pattern = '';
        this.mask = mask;
        this.formatModel = formatModel;
        this.pattern = this.getRegexFromMask(mask);
    }
    /**
     * @return {?}
     */
    get getPattern() {
        return this.pattern;
    }
    /**
     * @return {?}
     */
    get getValueToInput() {
        return this.valueToInput;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set setValueToInput(value) {
        this.valueToInput = value;
    }
    /**
     * @return {?}
     */
    get getValueToModel() {
        return this.valueToModel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set setValueToModel(value) {
        this.valueToModel = value;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    keyup($event) {
        if (this.mask) {
            /** @type {?} */
            const value = $event.target.value;
            // formata o valor quando for colado com control + v e reposiciona o cursor
            if ($event.keyCode === 17 || $event.keyCode === 91) {
                $event.target.value = this.controlFormatting(value);
                this.resetPositions($event);
            }
            $event.preventDefault();
            switch ($event.keyCode) {
                case 37: // seta esquerda
                    if (this.initialPosition > 0) {
                        this.initialPosition--;
                    }
                    this.setPositionNotShiftKey($event);
                    this.setSelectionRange($event);
                    break;
                case 39: // seta direita
                    if (this.initialPosition < value.toString().length) {
                        this.initialPosition++;
                    }
                    this.setPositionNotShiftKey($event);
                    this.setSelectionRange($event);
                    break;
                case 35: // end
                    this.finalPosition = value.toString().length;
                    if ($event.shiftKey) {
                        this.setPositions($event);
                    }
                    else {
                        this.initialPosition = this.finalPosition;
                        this.setPositions($event);
                    }
                    break;
                case 36: // HOME
                    if ($event.shiftKey) {
                        this.finalPosition = this.initialPosition;
                        this.initialPosition = 0;
                        this.setPositions($event);
                    }
                    else {
                        this.initialPosition = 0;
                        this.finalPosition = 0;
                        this.setPositions($event);
                    }
                    break;
            }
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    setPositionNotShiftKey($event) {
        if (!$event.shiftKey) {
            this.finalPosition = this.initialPosition;
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    setSelectionRange($event) {
        if (this.initialPosition > this.finalPosition) {
            $event.target.setSelectionRange(this.finalPosition, this.initialPosition);
        }
        else {
            $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    keydown($event) {
        if (this.mask) {
            /** @type {?} */
            let value = $event.target.value;
            if ($event.keyCode === 9) {
                return;
            }
            if (!$event.ctrlKey && !$event.metaKey) {
                $event.preventDefault();
            }
            // Não faz nada quando for digitado CTRL ou COMMAND e V
            // Já está sendo tratado no evento keyup
            if ($event.ctrlKey || $event.metaKey && ($event.keyCode !== 86) ||
                ($event.keyCode >= 37 && $event.keyCode <= 40) || $event.keyCode === 16 || $event.keyCode === 9) {
                return;
            }
            // Valida a tecla digitada
            if (this.isKeyValid($event.keyCode)) {
                if (this.finalPosition === null) {
                    this.finalPosition = this.initialPosition;
                }
                this.revertPositions(this.initialPosition, this.finalPosition);
                switch ($event.keyCode) {
                    case 8: // backspace
                        this.getPosition($event);
                        if (this.initialPosition < 0) {
                            this.initialPosition = 0;
                            this.setPositions($event);
                        }
                        if (this.initialPosition === this.finalPosition) {
                            this.checkMaskBefore($event, -1);
                            if (this.initialPosition !== 0) {
                                value = value.slice(0, this.initialPosition - 1) + value.slice(this.finalPosition);
                                value = this.controlFormatting(value);
                                $event.target.value = value;
                                this.changePosition($event, -1);
                                this.checkMaskBefore($event, -1);
                                this.setPositions($event);
                                this.resetPositions($event);
                            }
                        }
                        else {
                            this.clearRangeSelection(value, $event, true);
                        }
                        this.setPositions($event);
                        break;
                    case 46: // delete
                        this.getPosition($event);
                        if (this.initialPosition === this.finalPosition) {
                            this.checkMaskAfter($event, 1);
                            value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition + 1);
                            value = this.controlFormatting(value);
                            $event.target.value = value;
                            this.setPositions($event);
                            this.resetPositions($event);
                        }
                        else {
                            this.clearRangeSelection(value, $event, false);
                        }
                        this.setPositions($event);
                        break;
                    default: // qualquer outra tecla válida
                        value = value.slice(0, this.initialPosition) + $event.key + value.slice(this.finalPosition);
                        value = this.controlFormatting(value);
                        $event.target.value = value;
                        this.changePosition($event, 1);
                        this.checkMaskBefore($event, 1);
                        this.setPositions($event);
                        this.resetPositions($event);
                        this.setPositions($event);
                }
            }
        }
    }
    /**
     * @param {?} value
     * @param {?} $event
     * @param {?} isBackspace
     * @return {?}
     */
    clearRangeSelection(value, $event, isBackspace) {
        value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition);
        value = this.controlFormatting(value);
        $event.target.value = value;
        if (isBackspace) {
            this.checkMaskBefore($event, -1);
        }
        this.setPositions($event);
        this.resetPositions($event);
    }
    // passa a posição do click para o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    click($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = $event.target.selectionEnd;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    blur($event) {
        // Se houver algum valor definido na máscara
        if (this.mask) {
            // pega o valor do campo, formata e passa para o model
            /** @type {?} */
            let value = $event.target.value;
            value = this.controlFormatting(value);
            $event.target.value = value;
        }
    }
    /**
     * @param {?} initialPosition
     * @param {?} finalPosition
     * @return {?}
     */
    revertPositions(initialPosition, finalPosition) {
        if (initialPosition > finalPosition) {
            // inverte o controle de posição caso o inicial esteja maior que o final
            /** @type {?} */
            let tempPosition;
            tempPosition = initialPosition;
            this.initialPosition = finalPosition;
            this.finalPosition = tempPosition;
        }
    }
    // reseta o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    resetPositions($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = this.initialPosition;
    }
    // posiciona o cursor de acordo com o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    setPositions($event) {
        $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
    }
    // muda a posição do cursor e atualiza o controle de posição
    /**
     * @param {?} $event
     * @param {?} value
     * @return {?}
     */
    changePosition($event, value) {
        this.initialPosition = this.initialPosition + value;
        this.finalPosition = this.finalPosition + value;
        this.setPositions($event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    getPosition($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = $event.target.selectionEnd;
        this.setPositions($event);
    }
    // Método responsável por controlar a formatação e aplicar todas as máscara possíveis
    // quando houver valores opcionais (?)
    /**
     * @param {?} value
     * @return {?}
     */
    controlFormatting(value) {
        // Se o valor for vazio, retorna vazio
        if (!value) {
            this.valueToInput = '';
            this.valueToModel = '';
            return '';
        }
        /** @type {?} */
        let valueProcessed;
        /** @type {?} */
        let maskTmp = this.mask;
        // Array que será usado para armazenar todas as máscaras possíveis para
        // quando houver um valor opcional (?)
        /** @type {?} */
        const arrMasks = [];
        /** @type {?} */
        let contMasks = 0;
        // Enquanto houver algum 9? na máscara
        while (this.hasOptionalNumber(maskTmp)) {
            arrMasks.push(maskTmp);
            maskTmp = this.replaceOptionalNumber(maskTmp);
        }
        arrMasks.push(maskTmp);
        // Inverte o array
        arrMasks.reverse();
        // Informa que a formatação ainda não chegou ao fim
        this.formattingEnds = false;
        while (!this.formattingEnds) {
            // Seta a formatação como terminada
            // Então o método formatValue irá setar como não terminado caso haja
            this.formattingEnds = true;
            // Se não existe mais nenhuma máscara possível, então encerra a formatação
            if (!arrMasks[contMasks]) {
                break;
            }
            // Chama a formatação passando a máscara e o valor
            valueProcessed = this.formatValue(value, arrMasks[contMasks]);
            contMasks++;
        }
        return valueProcessed;
    }
    // Função que formata a máscara com o valor passado
    /**
     * @param {?} value
     * @param {?} mask
     * @return {?}
     */
    formatValue(value, mask) {
        // Remove as marcas de valor opciona (?)
        mask = mask.replace(/\?/g, '');
        // Substitui todos os caracteres que não são fixos da máscara por _
        /** @type {?} */
        const guide = mask.replace(this.listValidKeys(), '_');
        // Contador usado para percorrer o guide
        /** @type {?} */
        let contGuide = 0;
        // String final formatada
        /** @type {?} */
        let valueProcessed = '';
        // Remove do valor todos os caracteres fixos como ()/-+
        value = this.removeFormattingValue(value);
        // Percorre todo o valor e coloca a formatação de acordo com a máscara
        for (let i = 0; i < value.length; i++) {
            /** @type {?} */
            const charValue = value[i];
            // Se o guide acabou, seta a formatação como não terminada para que o método controlFormatting
            // tente formatar com outra possível máscara
            if (!guide[contGuide]) {
                this.formattingEnds = false;
                break;
            }
            // Percorre o Guide enquanto tem caracteres fixos
            while (this.isFixedCharacterGuide(guide[contGuide]) && guide[contGuide]) {
                valueProcessed += guide[contGuide];
                contGuide++;
            }
            // É um caracter válido de acordo com a máscara
            if (this.isKeyValidMask(charValue, mask[contGuide])) {
                valueProcessed += charValue;
                contGuide++;
            }
            else {
                // Se não é um caracter válido, deve interromper.
                break;
            }
        }
        if (this.formatModel) {
            this.valueToInput = valueProcessed;
            this.valueToModel = valueProcessed;
        }
        else {
            this.valueToInput = valueProcessed;
            this.valueToModel = this.removeFormattingValue(valueProcessed);
        }
        return valueProcessed;
    }
    // verifica se tem algum caracter de mascara antes do cursor
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    checkMaskBefore($event, position) {
        if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition - 1))) {
            this.changePosition($event, position);
            this.checkMaskBefore($event, position);
        }
    }
    // verifica se tem algum caracter de mascara depois do cursor
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    checkMaskAfter($event, position) {
        if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition))) {
            this.changePosition($event, position);
            this.checkMaskAfter($event, position);
        }
    }
    // Retorna a máscara sem um valor opcional
    /**
     * @param {?} mask
     * @return {?}
     */
    replaceOptionalNumber(mask) {
        /** @type {?} */
        let i = 9;
        while (i >= 0) {
            if (mask.indexOf(i + '?') > -1) {
                return mask.replace(i + '?', '');
            }
            i--;
        }
        return mask;
    }
    // Verifica se contém caracteres permitidos somente na máscara \/() +-
    /**
     * @param {?} key
     * @return {?}
     */
    isFixedCharacterGuide(key) {
        return this.testRegex(key, this.getFixedCharacterGuide());
    }
    // Retorna caracteres permitidos somente na máscara \/() +-
    /**
     * @return {?}
     */
    getFixedCharacterGuide() {
        return /[\\\/() +-.\:]/g;
    }
    // Caracteres permitidos de serem digitados
    /**
     * @return {?}
     */
    listValidKeys() {
        return /[a-zA-Z0-9]/g;
    }
    // Se é um dígito válido
    /**
     * @param {?} keyCode
     * @return {?}
     */
    isKeyValid(keyCode) {
        return this.isKeyCodeValid(keyCode);
    }
    // Verifica se a tecla digitada é permitida
    // Permite apenas números, letras, backspace e del
    /**
     * @param {?} keyCode
     * @return {?}
     */
    isKeyCodeValid(keyCode) {
        return ((keyCode >= 48 && keyCode <= 57) ||
            (keyCode >= 65 && keyCode <= 90) ||
            (keyCode >= 96 && keyCode <= 105) ||
            (keyCode === 8) || keyCode === 9 ||
            (keyCode === 46));
    }
    // Se está de acordo com a máscara
    /**
     * @param {?} key
     * @param {?} keyMask
     * @return {?}
     */
    isKeyValidMask(key, keyMask) {
        return this.testRegex(key, this.replaceMask(keyMask));
    }
    // Retorna se a chave foi aprovada pela expressão regular
    /**
     * @param {?} key
     * @param {?} regex
     * @return {?}
     */
    testRegex(key, regex) {
        return regex.test(key);
    }
    // Remove a formatacão do valor
    // É possível ser melhorado para remover pontualmente os caracteres fixos de acordo com a máscara
    /**
     * @param {?} value
     * @return {?}
     */
    removeFormattingValue(value) {
        return value.replace(this.getFixedCharacterGuide(), '');
    }
    // Verifica se contém valor opcional na máscara 0-9?
    /**
     * @param {?} mask
     * @return {?}
     */
    hasOptionalNumber(mask) {
        return mask.match(/\d\?/g);
    }
    // Retorna a expressão regular correspondente ao comando passado
    /**
     * @param {?} char
     * @return {?}
     */
    replaceMask(char) {
        /** @type {?} */
        let regex = /./;
        switch (char) {
            case '0':
                regex = /[0]/;
                break;
            case '1':
                regex = /[0-1]/;
                break;
            case '2':
                regex = /[0-2]/;
                break;
            case '3':
                regex = /[0-3]/;
                break;
            case '4':
                regex = /[0-4]/;
                break;
            case '5':
                regex = /[0-5]/;
                break;
            case '6':
                regex = /[0-6]/;
                break;
            case '7':
                regex = /[0-7]/;
                break;
            case '8':
                regex = /[0-8]/;
                break;
            case '9':
                regex = /[0-9]/;
                break;
            case ' ':
                regex = /\s/;
                break;
            case '@':
                regex = /[a-zA-Z]/;
                break;
            case 'w':
                regex = /[a-zA-Z0-9]/;
                break;
        }
        return regex;
    }
    /**
     * @param {?} mask
     * @return {?}
     */
    getRegexFromMask(mask) {
        if (mask) {
            /** @type {?} */
            let pattern;
            if (this.formatModel) {
                pattern = mask.replace(/\\/g, '\\\\');
                pattern = pattern.replace(/\+/g, '\\+');
                pattern = pattern.replace(/\./g, '\\.');
                pattern = pattern.replace(/-/g, '-');
                pattern = pattern.replace(/\(/g, '\\(');
                pattern = pattern.replace(/\)/g, '\\)');
                pattern = pattern.replace(/\//g, '\\/');
                pattern = pattern.replace(/\s/g, '\\s');
                pattern = pattern.replace(/:/g, '\\:');
                pattern = pattern.replace(/\@(?!\s)/g, '\\w');
                pattern = pattern.replace(/\d/g, '\\w');
            }
            else {
                pattern = mask.replace(/\\/g, '');
                pattern = pattern.replace(/\+/g, '');
                pattern = pattern.replace(/\./g, '');
                pattern = pattern.replace(/-/g, '');
                pattern = pattern.replace(/\(/g, '');
                pattern = pattern.replace(/\)/g, '');
                pattern = pattern.replace(/\//g, '');
                pattern = pattern.replace(/\s/g, '');
                pattern = pattern.replace(/:/g, '');
                pattern = pattern.replace(/\@/g, '\\w');
                pattern = pattern.replace(/\d/g, '\\w');
            }
            return pattern;
        }
        else {
            return null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfDatepickerFormatDefault = 'dd/mm/yyyy';
/**
 * \@description
 *
 * O `thf-datepicker` é um componente específico para manipulação de datas permitindo a digitação e / ou seleção.
 *
 * O formato de exibição da data, ou seja, o formato que é apresentado ao usuário é o dd/mm/yyyy,
 * mas podem ser definidos outros padrões (veja mais na propriedade `t-format`).
 *
 * O idioma padrão do calendário será exibido de acordo com o navegador, caso tenha necessidade de alterar
 * use a propriedade `t-locale`.
 *
 * O datepicker aceita três formatos de data: o E8601DZw (yyyy-mm-ddThh:mm:ss+|-hh:mm), o E8601DAw (yyyy-mm-dd) e o
 * Date padrão do Javascript.
 *
 * > O formato de saída do *model* se ajusta conforme o formato de entrada, veja abaixo:
 *
 * - Formato de entrada e saída (E8601DZw) - `'2017-11-28T00:00:00-02:00'`;
 *
 * - Formato de entrada e saída (E8601DAw) - `'2017-11-28'`;
 *
 * - Formato de entrada (Date) - `new Date(2017, 10, 28)` e saída (E8601DAw) - `'2017-11-28'`;
 *
 * **Importante:**
 *
 * - Para utilizar datas com ano inferior a 100, verificar o comportamento do [`new Date`](https://www.w3schools.com/js/js_dates.asp)
 * e utilizar o método [`setFullYear`](https://www.w3schools.com/jsref/jsref_setfullyear.asp).
 * - Caso a data esteja inválida, o `model` receberá **'Data inválida'**.
 * - Caso o `input` esteja passando um `[(ngModel)]`, mas não tenha um `name`, então irá ocorrer um erro
 * do próprio Angular (`[ngModelOptions]="{standalone: true}"`).
 *
 * Exemplo:
 *
 * ```
 * <thf-datepicker
 *   [(ngModel)]="pessoa.nome"
 *   [ngModelOptions]="{standalone: true}"
 * </thf-datepicker>
 * ```
 *
 * > Não esqueça de importar o `FormsModule` em seu módulo, tal como para utilizar o `input default`.
 * @abstract
 */
class ThfDatepickerBaseComponent {
    constructor() {
        this._format = thfDatepickerFormatDefault;
        this._placeholder = '';
        this.firstStart = true;
        this.hour = 'T00:00:01-00:00';
        this.isExtendedISO = false;
        this.onChangeModel = null;
        this.onTouchedModel = null;
        /**
         * Desabilita o campo.
         */
        this.disabled = false;
        /**
         * Torna o elemento somente leitura.
         */
        this.readonly = false;
        /**
         * Faz com que o campo seja obrigatório.
         */
        this.required = false;
        /**
         * Aplica foco ao elemento ao ser iniciado.
         */
        this.focus = false;
        /**
         * Habilita ação para limpar o campo.
         */
        this.clean = false;
        /**
         * Mensagem apresentada quando a data for inválida ou fora do período.
         *
         * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja obrigatório.
         */
        this.errorPattern = '';
        /**
         * Evento disparado ao sair do campo.
         */
        this.onblur = new EventEmitter();
        /**
         * Evento disparado ao alterar valor do campo.
         */
        this.onchange = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Mensagem que aparecerá enquanto o campo não estiver preenchido.
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = isTypeof(placeholder, 'string') ? placeholder : '';
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    set setDisabled(disabled) {
        this.disabled = disabled === '' ? true : convertToBoolean(disabled);
        this.validateModel(convertDateToISOExtended(this.date, this.hour));
    }
    /**
     * @param {?} readonly
     * @return {?}
     */
    set setReadonly(readonly) {
        this.readonly = readonly === '' ? true : convertToBoolean(readonly);
    }
    /**
     * @param {?} required
     * @return {?}
     */
    set setRequired(required) {
        this.required = required === '' ? true : convertToBoolean(required);
        this.validateModel(convertDateToISOExtended(this.date, this.hour));
    }
    /**
     * @param {?} focus
     * @return {?}
     */
    set setFocus(focus) {
        this.focus = focus === '' ? true : convertToBoolean(focus);
    }
    /**
     * @param {?} clean
     * @return {?}
     */
    set setClean(clean) {
        this.clean = clean === '' ? true : convertToBoolean(clean);
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define uma data mínima para o `thf-datepicker`.
     * @param {?} value
     * @return {?}
     */
    set minDate(value) {
        if (value instanceof Date) {
            /** @type {?} */
            const year = value.getFullYear();
            /** @type {?} */
            const date = new Date(year, value.getMonth(), value.getDate(), 0, 0, 0);
            setYearFrom0To100(date, year);
            this._minDate = date;
        }
        else {
            this._minDate = convertIsoToDate(value, true, false);
        }
        this.validateModel(convertDateToISOExtended(this.date, this.hour));
    }
    /**
     * @return {?}
     */
    get minDate() {
        return this._minDate;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define uma data máxima para o `thf-datepicker`.
     * @param {?} value
     * @return {?}
     */
    set maxDate(value) {
        if (value instanceof Date) {
            /** @type {?} */
            const year = value.getFullYear();
            /** @type {?} */
            const date = new Date(year, value.getMonth(), value.getDate(), 23, 59, 59);
            setYearFrom0To100(date, year);
            this._maxDate = date;
        }
        else {
            this._maxDate = convertIsoToDate(value, false, true);
        }
        this.validateModel(convertDateToISOExtended(this.date, this.hour));
    }
    /**
     * @return {?}
     */
    get maxDate() {
        return this._maxDate;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Formato de exibição da data.
     *
     * Valores válidos:
     *  - `dd/mm/yyyy`
     *  - `mm/dd/yyyy`
     *  - `yyyy/mm/dd`
     *
     * \@default `dd/mm/yyyy`
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        if (value) {
            value = value.toLowerCase();
            if (value.match(/dd/) && value.match(/mm/) && value.match(/yyyy/)) {
                this._format = value;
                this.objMask = this.buildMask();
                this.refreshValue(this.date);
                return;
            }
        }
        this._format = thfDatepickerFormatDefault;
        this.objMask = this.buildMask();
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        if (value) {
            this._locale = value.length >= 2 ? value : 'pt';
        }
        else {
            this._locale = getShortBrowserLanguage();
        }
    }
    /**
     * @return {?}
     */
    get locale() {
        return this._locale || getShortBrowserLanguage();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Classe de máscara
        this.objMask = this.buildMask();
    }
    // Converte um objeto string em Date
    /**
     * @param {?} dateString
     * @return {?}
     */
    getDateFromString(dateString) {
        /** @type {?} */
        const day = parseInt(dateString.substring(this.format.indexOf('d'), this.format.indexOf('d') + 2), 10);
        /** @type {?} */
        const month = parseInt(dateString.substring(this.format.indexOf('m'), this.format.indexOf('m') + 2), 10) - 1;
        /** @type {?} */
        const year = parseInt(dateString.substring(this.format.indexOf('y'), this.format.indexOf('y') + 4), 10);
        /** @type {?} */
        const date = new Date(year, month, day);
        setYearFrom0To100(date, year);
        return (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) ? date : null;
    }
    // Formata a data.
    /**
     * @param {?} value
     * @return {?}
     */
    formatToDate(value) {
        /** @type {?} */
        let dateFormatted = this.format;
        dateFormatted = dateFormatted.replace('dd', ('0' + value.getDate()).slice(-2));
        dateFormatted = dateFormatted.replace('mm', ('0' + (value.getMonth() + 1)).slice(-2));
        dateFormatted = dateFormatted.replace('yyyy', formatYear(value.getFullYear()));
        return dateFormatted;
    }
    // Método responsável por controlar o modelo.
    /**
     * @param {?} date
     * @return {?}
     */
    controlModel(date) {
        this.date = date;
        if (date && this.isExtendedISO) {
            this.callOnChange(convertDateToISOExtended(this.date, this.hour));
        }
        else if (date && !this.isExtendedISO) {
            this.callOnChange(convertDateToISODate(this.date));
        }
        else {
            date === undefined ? this.callOnChange('') : this.callOnChange('Data inválida');
        }
    }
    // Executa a função onChange
    /**
     * @param {?} value
     * @param {?=} retry
     * @return {?}
     */
    callOnChange(value, retry = true) {
        if (this.onChangeModel) {
            this.onChangeModel(value);
        }
        else if (retry) {
            setTimeout((/**
             * @return {?}
             */
            () => this.callOnChange(value, false)));
        }
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangeModel = func;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouchedModel = func;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    validateModel(model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    /**
     * @protected
     * @return {?}
     */
    buildMask() {
        /** @type {?} */
        let mask = this.format.toUpperCase();
        mask = mask.replace(/DD/g, '99');
        mask = mask.replace(/MM/g, '99');
        mask = mask.replace(/YYYY/g, '9999');
        return new ThfMask(mask, true);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        // Verifica se já possui algum error pattern padrão.
        this.errorPattern = this.errorPattern !== 'Data inválida' && this.errorPattern !== 'Data fora do período' ? this.errorPattern : '';
        if (dateFailed(c.value)) {
            this.errorPattern = this.errorPattern || 'Data inválida';
            return { date: {
                    valid: false,
                } };
        }
        if (requiredFailed(this.required, this.disabled, c.value)) {
            return { required: {
                    valid: false,
                } };
        }
        if ((this.date && !validateDateRange(this.date, this._minDate, this._maxDate))) {
            this.errorPattern = this.errorPattern || 'Data fora do período';
            return { date: {
                    valid: false,
                } };
        }
        return null;
    }
}
ThfDatepickerBaseComponent.propDecorators = {
    name: [{ type: Input, args: ['name',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    setDisabled: [{ type: Input, args: ['t-disabled',] }],
    setReadonly: [{ type: Input, args: ['t-readonly',] }],
    setRequired: [{ type: Input, args: ['t-required',] }],
    setFocus: [{ type: Input, args: ['t-focus',] }],
    setClean: [{ type: Input, args: ['t-clean',] }],
    errorPattern: [{ type: Input, args: ['t-error-pattern',] }],
    minDate: [{ type: Input, args: ['t-min-date',] }],
    maxDate: [{ type: Input, args: ['t-max-date',] }],
    format: [{ type: Input, args: ['t-format',] }],
    locale: [{ type: Input, args: ['t-locale',] }],
    onblur: [{ type: Output, args: ['t-blur',] }],
    onchange: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfCalendarContentOffset = 8;
/** @type {?} */
const thfCalendarPositionDefault = 'bottom-left';
/**
 * \@docsExtends ThfDatepickerBaseComponent
 *
 * \@example
 *
 * <example name="thf-datepicker-basic" title="Totvs Datepicker Basic">
 *  <file name="sample-thf-datepicker-basic/sample-thf-datepicker-basic.component.html"> </file>
 *  <file name="sample-thf-datepicker-basic/sample-thf-datepicker-basic.component.ts"> </file>
 *  <file name="sample-thf-datepicker-basic/sample-thf-datepicker-basic.component.po.ts"> </file>
 *  <file name="sample-thf-datepicker-basic/sample-thf-datepicker-basic.component.e2e-spec.ts"> </file>
 * </example>
 *
 * <example name="thf-datepicker-labs" title="Totvs Datepicker Labs">
 *  <file name="sample-thf-datepicker-labs/sample-thf-datepicker-labs.component.html"> </file>
 *  <file name="sample-thf-datepicker-labs/sample-thf-datepicker-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-datepicker-airfare" title="Totvs Datepicker - Airfare">
 *  <file name="sample-thf-datepicker-airfare/sample-thf-datepicker-airfare.component.html"> </file>
 *  <file name="sample-thf-datepicker-airfare/sample-thf-datepicker-airfare.component.ts"> </file>
 * </example>
 *
 * <example name="thf-datepicker-airfare-reactive-form" title="Totvs Datepicker - Airfare Reactive Form">
 *  <file name="sample-thf-datepicker-airfare-reactive-form/sample-thf-datepicker-airfare-reactive-form.component.html"> </file>
 *  <file name="sample-thf-datepicker-airfare-reactive-form/sample-thf-datepicker-airfare-reactive-form.component.ts"> </file>
 * </example>
 */
class ThfDatepickerComponent extends ThfDatepickerBaseComponent {
    /**
     * @param {?} controlPosition
     * @param {?} renderer
     * @param {?} el
     */
    constructor(controlPosition, renderer, el) {
        super();
        this.controlPosition = controlPosition;
        this.renderer = renderer;
        this.dateRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])$');
        this.isoRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])' +
            'T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|' +
            '-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])' +
            '(?:|:?[0-5]\\d)$');
        this.onScroll = (/**
         * @return {?}
         */
        () => {
            this.controlPosition.adjustPosition(thfCalendarPositionDefault);
        });
        this.el = el;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setDialogPickerStyleDisplay('none');
        // Põe o foco no Input, setado pelo t-focus
        if (this.focus) {
            this.inputEl.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @return {?}
     */
    togglePicker() {
        if (this.disabled || this.readonly) {
            return;
        }
        if (!this.calendar.visible) {
            this.calendar.init();
            this.setCalendarPosition();
            this.initializeListeners();
        }
        else {
            this.inputEl.nativeElement.disabled = false;
            this.closeCalendar();
        }
    }
    /**
     * @return {?}
     */
    dateSelected() {
        this.inputEl.nativeElement.focus();
        this.inputEl.nativeElement.value = this.formatToDate(this.date);
        this.controlModel(this.date);
        this.closeCalendar();
    }
    // Esconde Picker quando for clicado fora
    /**
     * @param {?} event
     * @return {?}
     */
    wasClickedOnPicker(event) {
        if (!this.dialogPicker || !this.iconDatepicker) {
            return;
        }
        if ((!this.dialogPicker.nativeElement.contains(event.target) || this.hasOverlayClass(event.target)) &&
            !this.iconDatepicker.nativeElement.contains(event.target) && !this.hasAttrCalendar(event.target)) {
            this.closeCalendar();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onKeyup($event) {
        if (this.readonly) {
            return;
        }
        this.objMask.keyup($event);
        // Controla a atualização do model, verificando se a data é valida
        if (this.objMask.valueToModel || this.objMask.valueToModel === '') {
            if (this.objMask.valueToModel.length >= 10) {
                this.controlModel(this.getDateFromString(this.inputEl.nativeElement.value));
                this.date = this.getDateFromString(this.inputEl.nativeElement.value);
            }
            else {
                this.date = undefined;
                this.controlModel(this.date);
            }
        }
        else {
            this.date = undefined;
        }
    }
    /**
     * @param {?=} $event
     * @return {?}
     */
    onKeydown($event) {
        if (this.readonly) {
            return;
        }
        this.objMask.keydown($event);
    }
    /**
     * @return {?}
     */
    hasInvalidClass() {
        return (this.el.nativeElement.classList.contains('ng-invalid') &&
            this.el.nativeElement.classList.contains('ng-dirty') &&
            this.inputEl.nativeElement.value !== '');
    }
    /**
     * @return {?}
     */
    getErrorPattern() {
        return (this.errorPattern !== '' && this.hasInvalidClass()) ? this.errorPattern : '';
    }
    /**
     * @return {?}
     */
    clear() {
        this.valueBeforeChange = this.formatToDate(this.date);
        this.date = undefined;
        this.controlModel(this.date);
        this.controlChangeEmitter();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    eventOnBlur($event) {
        /** @type {?} */
        const date = this.inputEl.nativeElement.value;
        /** @type {?} */
        const newDate = date ? this.getDateFromString(date) : undefined;
        this.objMask.blur($event);
        this.onblur.emit();
        if (this.objMask.valueToModel) {
            if (this.objMask.valueToModel.length >= 10) {
                this.controlModel(newDate);
                this.date = newDate;
            }
            else {
                this.date = undefined;
                this.controlModel(this.date);
            }
        }
        else {
            this.date = undefined;
            this.callOnChange(this.date);
        }
        this.controlChangeEmitter();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    eventOnChange($event) {
        /** @type {?} */
        const elementValue = this.inputEl.nativeElement.value;
        if (this.verifyMobile()) {
            this.controlModel(elementValue);
            this.callOnChange(elementValue);
        }
        this.onchange.emit(elementValue);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    eventOnClick($event) {
        if (this.verifyMobile()) {
            $event.target.blur();
            // abre o calendar quando clicar no input somente no mobile
            setTimeout((/**
             * @return {?}
             */
            () => this.togglePicker()), 0);
        }
        else {
            // Atualiza a posição do cursor ao clicar
            this.objMask.click($event);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatToDate(value) {
        if (!value) {
            return undefined;
        }
        /** @type {?} */
        let dateFormatted = this.format;
        dateFormatted = dateFormatted.replace('dd', ('0' + value.getDate()).slice(-2));
        dateFormatted = dateFormatted.replace('mm', ('0' + (value.getMonth() + 1)).slice(-2));
        dateFormatted = dateFormatted.replace('yyyy', formatYear(value.getFullYear()));
        return dateFormatted;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    refreshValue(value) {
        if (value) {
            this.inputEl.nativeElement.value = this.formatToDate(value);
        }
    }
    // Função implementada do ControlValueAccessor
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.inputEl && value) {
            if (value instanceof Date) {
                /** @type {?} */
                const dateString = value.toString();
                this.hour = 'T' + dateString.substring(16, 24) + dateString.substring(28, 31) + ':' + dateString.substring(31, 33);
                this.date = value;
                this.inputEl.nativeElement.value = this.formatToDate(value);
            }
            else if (this.isValidDateIso(value) || this.isValidExtendedIso(value)) {
                if (this.isValidDateIso(value)) {
                    this.isExtendedISO = false;
                }
                else {
                    this.hour = value.substring(10, 25);
                    this.isExtendedISO = true;
                }
                /** @type {?} */
                const day = parseInt(value.substring(8, 10), 10);
                /** @type {?} */
                const month = parseInt(value.substring(5, 7), 10) - 1;
                /** @type {?} */
                const year = parseInt(value.substring(0, 4), 10);
                /** @type {?} */
                const dateTemp = new Date(year, month, day);
                setYearFrom0To100(dateTemp, year);
                this.date = dateTemp;
                this.inputEl.nativeElement.value = this.formatToDate(dateTemp);
            }
            else {
                this.inputEl.nativeElement.value = '';
                this.date = undefined;
            }
            this.controlModel(this.date);
        }
        else if (this.inputEl) {
            this.inputEl.nativeElement.value = '';
            this.date = undefined;
        }
        this.valueBeforeChange = this.formatToDate(this.date);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValidDateIso(value) {
        return this.dateRegex.test(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValidExtendedIso(value) {
        return this.isoRegex.test(value);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    hasOverlayClass(element) {
        return element.classList.contains('thf-calendar-overlay');
    }
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    verifyMobile() {
        return isMobile();
    }
    /**
     * @private
     * @return {?}
     */
    closeCalendar() {
        this.calendar.close();
        this.removeListeners();
        this.setDialogPickerStyleDisplay('none');
    }
    /**
     * @private
     * @return {?}
     */
    controlChangeEmitter() {
        /** @type {?} */
        const dateModelFormatted = this.formatToDate(this.date);
        if (dateModelFormatted !== this.valueBeforeChange) {
            this.valueBeforeChange = dateModelFormatted;
            clearTimeout(this.timeoutChange);
            this.timeoutChange = setTimeout((/**
             * @return {?}
             */
            () => {
                this.onchange.emit(dateModelFormatted);
            }), 200);
        }
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    hasAttrCalendar(element) {
        /** @type {?} */
        const attrCalendar = 'attr-calendar';
        return (element && element.hasAttribute(attrCalendar)) || (element.parentElement && element.parentElement.hasAttribute(attrCalendar));
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.clickListener = this.renderer.listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.wasClickedOnPicker(event);
        }));
        this.eventResizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.closeCalendar();
        }));
        window.addEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.clickListener) {
            this.clickListener();
        }
        if (this.eventResizeListener) {
            this.eventResizeListener();
        }
        window.removeEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setDialogPickerStyleDisplay(value) {
        this.dialogPicker.nativeElement.style.display = value;
    }
    /**
     * @private
     * @return {?}
     */
    setCalendarPosition() {
        this.setDialogPickerStyleDisplay('block');
        this.controlPosition.setElements(this.dialogPicker.nativeElement, thfCalendarContentOffset, this.inputEl, ['top-left', 'bottom-left'], false, true);
        this.controlPosition.adjustPosition(thfCalendarPositionDefault);
    }
}
ThfDatepickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-datepicker',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n\n    <input #inp\n      class=\"thf-input thf-datepicker\"\n      [ngClass]=\"clean && inp.value ? 'thf-input-double-icon-right' : 'thf-input-icon-right'\"\n      type=\"text\"\n      [attr.name]=\"name\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      (blur)=\"eventOnBlur($event)\"\n      (change)=\"eventOnChange($event)\"\n      (click)=\"eventOnClick($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean [t-element-ref]=\"inputEl\" (t-change-event)=\"clear()\"></thf-clean>\n\n      <span #iconDatepicker\n        class=\"thf-icon thf-field-icon thf-icon-calendar\"\n        [class.thf-field-icon]=\"!disabled && !readonly\"\n        [class.thf-field-icon-disabled]=\"disabled || readonly\"\n        (click)=\"togglePicker()\">\n      </span>\n    </div>\n  </div>\n\n  <div #dialogPicker [class.thf-datepicker-popup-calendar]=\"!verifyMobile()\">\n    <thf-calendar #calendar\n      [(t-selected-date)]=\"date\"\n      [t-date-end]=\"maxDate\"\n      [t-date-start]=\"minDate\"\n      [t-locale]=\"locale\"\n      (t-submit)=\"dateSelected()\">\n    </thf-calendar>\n  </div>\n\n  <thf-field-container-bottom [t-error-pattern]=\"getErrorPattern()\"></thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfDatepickerComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfDatepickerComponent)),
                        multi: true,
                    },
                    ThfControlPositionService
                ]
            }] }
];
/** @nocollapse */
ThfDatepickerComponent.ctorParameters = () => [
    { type: ThfControlPositionService },
    { type: Renderer2 },
    { type: ElementRef }
];
ThfDatepickerComponent.propDecorators = {
    calendar: [{ type: ViewChild, args: ['calendar', { static: true },] }],
    dialogPicker: [{ type: ViewChild, args: ['dialogPicker', { read: ElementRef, static: true },] }],
    iconDatepicker: [{ type: ViewChild, args: ['iconDatepicker', { read: ElementRef, static: true },] }],
    inputEl: [{ type: ViewChild, args: ['inp', { read: ElementRef, static: true },] }],
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    onKeyup: [{ type: HostListener, args: ['keyup', ['$event'],] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfDatepickerRangeLiteralsDefault = {
    en: (/** @type {?} */ ({
        invalidFormat: 'Date in invalid format',
        startDateGreaterThanEndDate: 'Start date greater than end date',
    })),
    es: (/** @type {?} */ ({
        invalidFormat: 'Fecha en formato no válido',
        startDateGreaterThanEndDate: 'Fecha de inicio mayor que fecha final',
    })),
    pt: (/** @type {?} */ ({
        invalidFormat: 'Data no formato inválido',
        startDateGreaterThanEndDate: 'Data inicial maior que data final',
    }))
};
/**
 * \@description
 *
 * O `thf-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `thf-datepicker-range` trabalha com um objeto que implementa a interface
 * `ThfDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `t-start-date` e `t-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 * @abstract
 */
class ThfDatepickerRangeBaseComponent {
    /**
     * @param {?} thfDateService
     */
    constructor(thfDateService) {
        this.thfDateService = thfDateService;
        this.errorMessage = '';
        this._clean = false;
        this._readonly = false;
        this._required = false;
        this.dateRange = { start: '', end: '' };
        this.format = 'dd/mm/yyyy';
        this.isDateRangeInputFormatValid = true;
        this.isStartDateRangeInputValid = true;
        /**
         * \@optional
         *
         * \@description
         *
         * Evento disparado ao alterar valor do campo.
         */
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isDateRangeInputValid() {
        return this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Habilita ação para limpar o campo.
     *
     * \@default `false`
     * @param {?} clean
     * @return {?}
     */
    set clean(clean) {
        this._clean = convertToBoolean(clean);
    }
    /**
     * @return {?}
     */
    get clean() {
        return this._clean;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita o campo.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data final.
     * @param {?} date
     * @return {?}
     */
    set endDate(date) {
        this._endDate = this.convertPatternDateFormat(date);
        this.dateRange.end = this.endDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get endDate() {
        return this._endDate;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-datepicker-range`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format',
     *    startDateGreaterThanEndDate: 'End date less than start date'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-datepicker-range
     *   [t-literals]="customLiterals">
     * </thf-datepicker-range>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfDatepickerRangeLiteralsDefault[thfLocaleDefault], thfDatepickerRangeLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfDatepickerRangeLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfDatepickerRangeLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será somente leitura.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data inicial.
     * @param {?} date
     * @return {?}
     */
    set startDate(date) {
        this._startDate = this.convertPatternDateFormat(date);
        this.dateRange.start = this.startDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get startDate() {
        return this._startDate;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangeModel = func;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouchedModel = func;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        const value = control.value || {};
        /** @type {?} */
        const startDate = value.start ? this.convertPatternDateFormat(value.start) : '';
        /** @type {?} */
        const endDate = value.end ? this.convertPatternDateFormat(value.end) : '';
        if (this.requiredDateRangeFailed(startDate, endDate)) {
            this.errorMessage = '';
            return { required: {
                    valid: false,
                } };
        }
        if (this.dateRangeObjectFailed(control.value) || this.dateRangeFormatFailed(startDate, endDate)) {
            this.errorMessage = this.literals.invalidFormat;
            return { date: {
                    valid: false,
                } };
        }
        if (this.dateRangeFailed(startDate, endDate)) {
            this.errorMessage = this.literals.startDateGreaterThanEndDate;
            return { date: {
                    valid: false,
                } };
        }
        return null;
    }
    /**
     * @param {?} dateRange
     * @return {?}
     */
    writeValue(dateRange) {
        this.resetDateRangeInputValidation();
        if (!dateRange || this.dateRangeObjectFailed(dateRange)) {
            this.dateRange = { start: '', end: '' };
        }
        if (!dateRange) {
            this.validateModel(this.dateRange);
        }
        if (this.dateRangeObjectFailed(dateRange)) {
            this.updateModel(dateRange);
        }
        if (this.isDateRangeObject(dateRange)) {
            this.dateRange = {
                start: this.convertPatternDateFormat(dateRange.start),
                end: this.convertPatternDateFormat(dateRange.end)
            };
            this.updateModel(this.dateRange);
        }
        this.updateScreenByModel(this.dateRange);
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    dateFormatFailed(value) {
        return value && !this.thfDateService.isValidIso(value);
    }
    // Executa a função onChange
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    updateModel(value) {
        /** @type {?} */
        const model = typeof (value) === 'object' ? Object.assign({}, value) : value;
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(model);
        }
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    validateModel(value) {
        /** @type {?} */
        const model = Object.assign({}, value);
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    convertPatternDateFormat(value) {
        if (value instanceof Date) {
            return this.thfDateService.convertDateToISO(value);
        }
        return value;
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    dateRangeFailed(startDate, endDate) {
        return !this.thfDateService.isDateRangeValid(endDate, startDate) || !this.isStartDateRangeInputValid;
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    dateRangeFormatFailed(startDate, endDate) {
        return this.dateFormatFailed(endDate) || this.dateFormatFailed(startDate) || !this.isDateRangeInputFormatValid;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    dateRangeObjectFailed(value) {
        return value && !this.isDateRangeObject(value);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isDateRangeObject(value) {
        return value && value.hasOwnProperty('start') && value.hasOwnProperty('end');
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    requiredDateRangeFailed(startDate, endDate) {
        return this.isDateRangeInputValid &&
            requiredFailed(this.required, this.disabled, startDate) &&
            requiredFailed(this.required, this.disabled, endDate);
    }
}
ThfDatepickerRangeBaseComponent.propDecorators = {
    clean: [{ type: Input, args: ['t-clean',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    endDate: [{ type: Input, args: ['t-end-date',] }],
    help: [{ type: Input, args: ['t-help',] }],
    label: [{ type: Input, args: ['t-label',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    required: [{ type: Input, args: ['t-required',] }],
    startDate: [{ type: Input, args: ['t-start-date',] }],
    onChange: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const arrowLeftKey = 37;
/** @type {?} */
const arrowRightKey = 39;
/** @type {?} */
const backspaceKey = 8;
/** @type {?} */
const thfDatepickerRangeDateLengthDefault = 10;
/**
 * \@docsExtends ThfDatepickerRangeBaseComponent
 *
 * \@example
 *
 * <example name="thf-datepicker-range-basic" title="Totvs Datepicker Range Basic">
 *  <file name="sample-thf-datepicker-range-basic/sample-thf-datepicker-range-basic.component.html"> </file>
 *  <file name="sample-thf-datepicker-range-basic/sample-thf-datepicker-range-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-datepicker-range-labs" title="Totvs Datepicker Range Labs">
 *  <file name="sample-thf-datepicker-range-labs/sample-thf-datepicker-range-labs.component.html"> </file>
 *  <file name="sample-thf-datepicker-range-labs/sample-thf-datepicker-range-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-datepicker-range-vacations" title="Totvs Datepicker Range - Vacations Suggestion">
 *  <file name="sample-thf-datepicker-range-vacations/sample-thf-datepicker-range-vacations.component.html"> </file>
 *  <file name="sample-thf-datepicker-range-vacations/sample-thf-datepicker-range-vacations.component.ts"> </file>
 * </example>
 *
 * <example name="thf-datepicker-range-vacations-reactive-form" title="Totvs Datepicker Range - Vacations Reactive Form">
 *  <file name="sample-thf-datepicker-range-vacations-reactive-form/sample-thf-datepicker-range-vacations-reactive-form.component.html">
 *  </file>
 *  <file name="sample-thf-datepicker-range-vacations-reactive-form/sample-thf-datepicker-range-vacations-reactive-form.component.ts">
 *  </file>
 * </example>
 */
class ThfDatepickerRangeComponent extends ThfDatepickerRangeBaseComponent {
    /**
     * @param {?} thfDateService
     * @param {?} thfDatepickerRangeElement
     */
    constructor(thfDateService, thfDatepickerRangeElement) {
        super(thfDateService);
        this.thfDatepickerRangeElement = thfDatepickerRangeElement;
    }
    /**
     * @return {?}
     */
    get enableCleaner() {
        return (this.startDateInputValue || this.endDateInputValue) && !this.disabled && !this.readonly;
    }
    /**
     * @return {?}
     */
    get endDateInputName() {
        return 'end-date';
    }
    /**
     * @return {?}
     */
    get endDateInputValue() {
        return this.endDateInput.nativeElement.value;
    }
    /**
     * @return {?}
     */
    get getErrorMessage() {
        return (this.errorMessage !== '' && this.hasInvalidClass()) ? this.errorMessage : '';
    }
    /**
     * @return {?}
     */
    get isDateRangeInputUncompleted() {
        return this.endDateInputValue.length < thfDatepickerRangeDateLengthDefault
            && this.startDateInputValue.length < thfDatepickerRangeDateLengthDefault;
    }
    /**
     * @return {?}
     */
    get isDirtyDateRangeInput() {
        return this.endDateInputValue.length > 0 || this.startDateInputValue.length > 0;
    }
    /**
     * @return {?}
     */
    get startDateInputName() {
        return 'start-date';
    }
    /**
     * @return {?}
     */
    get startDateInputValue() {
        return this.startDateInput.nativeElement.value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    static getKeyCode(event) {
        return event.keyCode || event.which;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    static getTargetElement(event) {
        return event.target || event.srcElement;
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    static isValidKey(keyCode) {
        /** @type {?} */
        const isNumericKey = keyCode >= 48 && keyCode <= 57;
        /** @type {?} */
        const isNumericNumpadKey = keyCode >= 96 && keyCode <= 105;
        return isNumericKey || isNumericNumpadKey;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Classe de máscara
        this.thfMaskObject = this.buildMask();
    }
    /**
     * @return {?}
     */
    clear() {
        this.resetDateRangeInputValidation();
        this.dateRange = { start: '', end: '' };
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.removeFocusFromDatePickerRangeField();
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.applyFocusOnDatePickerRangeField();
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onKeydown(event) {
        if (this.readonly) {
            return;
        }
        if (this.isSetFocusOnBackspace(event)) {
            event.preventDefault();
            this.setFocusOnBackspace();
        }
        else {
            this.thfMaskObject.keydown(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyup(event) {
        if (this.readonly) {
            return;
        }
        /** @type {?} */
        const isStartDateTargetEvent = event.target.name === this.startDateInputName;
        this.setFocus(event);
        this.thfMaskObject.keyup(event);
        this.updateModelByScreen(isStartDateTargetEvent);
    }
    /**
     * @return {?}
     */
    resetDateRangeInputValidation() {
        this.isStartDateRangeInputValid = true;
        this.isDateRangeInputFormatValid = true;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    updateScreenByModel(model) {
        /** @type {?} */
        const dateRange = { start: (/** @type {?} */ (model.start)), end: (/** @type {?} */ (model.end)) };
        /** @type {?} */
        const isStartDateValid = this.thfDateService.isDateRangeValid(dateRange.end, dateRange.start);
        /** @type {?} */
        const isDateValid = (/**
         * @param {?} date
         * @return {?}
         */
        date => !this.dateFormatFailed(date) && isStartDateValid);
        /** @type {?} */
        const endDateFormated = isDateValid(dateRange.end) ? this.formatModelToScreen(dateRange.end) : '';
        /** @type {?} */
        const startDateFormated = isDateValid(dateRange.start) ? this.formatModelToScreen(dateRange.start) : '';
        this.endDateInput.nativeElement.value = endDateFormated;
        this.startDateInput.nativeElement.value = startDateFormated;
    }
    /**
     * @private
     * @return {?}
     */
    applyFocusOnDatePickerRangeField() {
        this.dateRangeField.nativeElement.classList.add('thf-datepicker-range-field-focused');
    }
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    /**
     * @private
     * @return {?}
     */
    buildMask() {
        /** @type {?} */
        let mask = this.format.toUpperCase();
        mask = mask.replace(/DD/g, '99');
        mask = mask.replace(/MM/g, '99');
        mask = mask.replace(/YYYY/g, '9999');
        return new ThfMask(mask, true);
    }
    /**
     * @private
     * @param {?} format
     * @param {?=} day
     * @param {?=} month
     * @param {?=} year
     * @return {?}
     */
    formatDate(format, day = '', month = '', year = '') {
        /** @type {?} */
        let dateFormatted = format;
        day = day && day.includes('T') ? day.slice(0, 2) : day;
        dateFormatted = dateFormatted.replace('dd', ('0' + day).slice(-2));
        dateFormatted = dateFormatted.replace('mm', ('0' + (month)).slice(-2));
        dateFormatted = dateFormatted.replace('yyyy', String(year));
        return dateFormatted;
    }
    /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    formatScreenToModel(value = '') {
        const [day, month, year] = value.split('/');
        return value ? this.formatDate('yyyy-mm-dd', day, month, year) : '';
    }
    /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    formatModelToScreen(value = '') {
        const [year, month, day] = value.split('-');
        return value ? this.formatDate(this.format, day, month, year) : '';
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @param {?} isStartDateTargetEvent
     * @return {?}
     */
    getDateRangeFormatValidation(startDate, endDate, isStartDateTargetEvent) {
        this.setDateRangeInputValidation(startDate, endDate);
        return {
            isValid: this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid,
            dateRangeModel: this.getValidatedModel(startDate, endDate, isStartDateTargetEvent)
        };
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @param {?} isStartDateTargetEvent
     * @return {?}
     */
    getValidatedModel(startDate, endDate, isStartDateTargetEvent) {
        /** @type {?} */
        const dateRangeModel = { start: '', end: '' };
        dateRangeModel.end = (isStartDateTargetEvent || this.isStartDateRangeInputValid)
            && !this.dateFormatFailed(endDate) ? endDate : '';
        dateRangeModel.start = (!isStartDateTargetEvent || this.isStartDateRangeInputValid)
            && !this.dateFormatFailed(startDate) ? startDate : '';
        return dateRangeModel;
    }
    /**
     * @private
     * @return {?}
     */
    hasInvalidClass() {
        return (this.thfDatepickerRangeElement.nativeElement.classList.contains('ng-invalid') &&
            this.thfDatepickerRangeElement.nativeElement.classList.contains('ng-dirty'));
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    isEqualBeforeValue(startDate, endDate) {
        return this.isDateRangeInputFormatValid && endDate === this.dateRange.end && startDate === this.dateRange.start;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    isSetFocusOnBackspace(event) {
        return event.target.name === this.endDateInputName &&
            this.endDateInput.nativeElement.selectionStart === 0 && this.endDateInput.nativeElement.selectionEnd === 0 &&
            event.keyCode === backspaceKey;
    }
    /**
     * @private
     * @return {?}
     */
    removeFocusFromDatePickerRangeField() {
        this.dateRangeField.nativeElement.classList.remove('thf-datepicker-range-field-focused');
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    setDateRangeInputValidation(startDate, endDate) {
        this.isStartDateRangeInputValid = this.thfDateService.isDateRangeValid(endDate, startDate);
        this.isDateRangeInputFormatValid = !this.dateFormatFailed(startDate) && !this.dateFormatFailed(endDate);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    setFocus(event) {
        /** @type {?} */
        const inputElement = ThfDatepickerRangeComponent.getTargetElement(event);
        /** @type {?} */
        const keyCode = ThfDatepickerRangeComponent.getKeyCode(event);
        /** @type {?} */
        const inputName = inputElement['name'];
        this.setFocusOnArrowLeft(keyCode, inputName);
        this.setFocusOnArrowRight(keyCode, inputName, inputElement);
        this.setFocusOnStartDateCompleted(keyCode, inputName);
    }
    /**
     * @private
     * @param {?} position
     * @param {?} inputElement
     * @param {?} selectionRange
     * @return {?}
     */
    setFocusAndPosition(position, inputElement, selectionRange) {
        this.focusOnElement(inputElement);
        setTimeout((/**
         * @return {?}
         */
        () => {
            inputElement.nativeElement.setSelectionRange(selectionRange, selectionRange);
            this.thfMaskObject.initialPosition = position;
            this.thfMaskObject.finalPosition = position;
        }));
    }
    /**
     * @private
     * @param {?} inputElement
     * @return {?}
     */
    focusOnElement(inputElement) {
        inputElement.nativeElement.focus();
    }
    /**
     * @private
     * @param {?} keyCode
     * @param {?} inputName
     * @return {?}
     */
    setFocusOnArrowLeft(keyCode, inputName) {
        /** @type {?} */
        const isCursorAtStartOfInput = this.endDateInput.nativeElement.selectionStart === 0;
        if (inputName === this.endDateInputName && isCursorAtStartOfInput && keyCode === arrowLeftKey) {
            /** @type {?} */
            const inputLength = this.startDateInput.nativeElement.value.length;
            this.setFocusAndPosition(inputLength, this.startDateInput, inputLength);
        }
    }
    /**
     * @private
     * @param {?} keyCode
     * @param {?} inputName
     * @param {?} inputElement
     * @return {?}
     */
    setFocusOnArrowRight(keyCode, inputName, inputElement) {
        /** @type {?} */
        const isCursorAtEndOfInput = this.startDateInput.nativeElement.selectionStart === inputElement.value.length;
        if (inputName === this.startDateInputName && isCursorAtEndOfInput && keyCode === arrowRightKey) {
            this.setFocusAndPosition(0, this.endDateInput, 0);
        }
    }
    /**
     * @private
     * @return {?}
     */
    setFocusOnBackspace() {
        /** @type {?} */
        const inputLength = this.startDateInput.nativeElement.value.length;
        this.startDateInput.nativeElement.value = this.startDateInputValue.slice(0, -1);
        this.setFocusAndPosition(inputLength, this.startDateInput, inputLength);
    }
    /**
     * @private
     * @param {?} keyCode
     * @param {?} inputName
     * @return {?}
     */
    setFocusOnStartDateCompleted(keyCode, inputName) {
        /** @type {?} */
        const isLastKeyPressed = this.startDateInput.nativeElement.selectionStart === thfDatepickerRangeDateLengthDefault;
        /** @type {?} */
        const isNewDateCompleted = this.startDateInputValue.length === thfDatepickerRangeDateLengthDefault && isLastKeyPressed;
        /** @type {?} */
        const isValidKey = ThfDatepickerRangeComponent.isValidKey(keyCode);
        if (inputName === this.startDateInputName && isNewDateCompleted && isValidKey) {
            this.setFocusAndPosition(0, this.endDateInput, 0);
        }
    }
    /**
     * @private
     * @param {?} isStartDateTargetEvent
     * @return {?}
     */
    updateModelByScreen(isStartDateTargetEvent) {
        /** @type {?} */
        const endDateFormatted = this.formatScreenToModel(this.endDateInputValue);
        /** @type {?} */
        const startDateFormatted = this.formatScreenToModel(this.startDateInputValue);
        if (this.isDateRangeInputUncompleted && this.isDirtyDateRangeInput) {
            this.updateModel(this.dateRange);
            return;
        }
        if (this.isEqualBeforeValue(startDateFormatted, endDateFormatted)) {
            this.resetDateRangeInputValidation();
            this.validateModel(this.dateRange);
            return;
        }
        /** @type {?} */
        const dateFormatValidation = this.getDateRangeFormatValidation(startDateFormatted, endDateFormatted, isStartDateTargetEvent);
        if (dateFormatValidation.isValid) {
            this.dateRange = { start: startDateFormatted, end: endDateFormatted };
            this.updateModel(this.dateRange);
            this.onChange.emit(Object.assign({}, this.dateRange));
        }
        if (!dateFormatValidation.isValid) {
            this.dateRange = Object.assign({}, dateFormatValidation.dateRangeModel);
            this.updateModel(dateFormatValidation.dateRangeModel);
        }
    }
}
ThfDatepickerRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-datepicker-range',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div\n    #dateRangeField\n    class=\"thf-datepicker-range-field thf-input\"\n    [class.thf-datepicker-range-field-disabled]=\"disabled\">\n\n    <div class=\"thf-datepicker-range-start-date\">\n      <input\n        #startDateInput\n        class=\"thf-datepicker-range-input\"\n        maxlength=\"10\"\n        type=\"text\"\n        [disabled]=\"disabled\"\n        [name]=\"startDateInputName\"\n        [readonly]=\"readonly\"\n        (blur)=\"onBlur()\"\n        (focus)=\"onFocus()\"\n        (keydown)=\"onKeydown($event)\"\n        (keyup)=\"onKeyup($event)\">\n    </div>\n\n    <div class=\"thf-datepicker-range-separator\">-</div>\n\n    <div class=\"thf-datepicker-range-end-date\">\n      <input\n        #endDateInput\n        class=\"thf-datepicker-range-input\"\n        maxlength=\"10\"\n        type=\"text\"\n        [disabled]=\"disabled\"\n        [name]=\"endDateInputName\"\n        [readonly]=\"readonly\"\n        (blur)=\"onBlur()\"\n        (focus)=\"onFocus()\"\n        (keydown)=\"onKeydown($event)\"\n        (keyup)=\"onKeyup($event)\">\n    </div>\n\n    <div class=\"thf-datepicker-range-icon\">\n      <thf-clean *ngIf=\"enableCleaner\" (t-change-event)=\"clear($event)\"></thf-clean>\n    </div>\n\n    <div class=\"thf-datepicker-range-icon\">\n      <span\n        class=\"thf-icon thf-field-icon thf-icon-calendar\"\n        [class.thf-field-icon-disabled]=\"disabled || readonly\">\n      </span>\n    </div>\n\n  </div>\n\n  <thf-field-container-bottom [t-error-pattern]=\"getErrorMessage\"></thf-field-container-bottom>\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfDatepickerRangeComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfDatepickerRangeComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfDatepickerRangeComponent.ctorParameters = () => [
    { type: ThfDateService },
    { type: ElementRef }
];
ThfDatepickerRangeComponent.propDecorators = {
    dateRangeField: [{ type: ViewChild, args: ['dateRangeField', { read: ElementRef, static: true },] }],
    endDateInput: [{ type: ViewChild, args: ['endDateInput', { read: ElementRef, static: true },] }],
    startDateInput: [{ type: ViewChild, args: ['startDateInput', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Este é um componente baseado em input, com várias propriedades do input nativo e outras
 * propriedades extras como: máscara, pattern, mensagem de erro e etc.
 * Você deve informar a variável que contém o valor como [(ngModel)]="variavel", para que o
 * input receba o valor da variável e para que ela receba as alterações do valor (two-way-databinding).
 * A propriedade name é obrigatória para que o formulário e o model funcionem corretamente.
 *
 * Importante:
 *
 * - Caso o input tenha um [(ngModel)] sem o atributo name, ocorrerá um erro de angular.
 * Então você precisa informar o atributo name ou o atributo [ngModelOptions]="{standalone: true}".
 * Exemplo: [(ngModel)]="pessoa.nome" [ngModelOptions]="{standalone: true}"
 * @abstract
 */
class ThfInputBaseComponent {
    constructor() {
        this._placeholder = '';
        this.passedWriteValue = false;
        /**
         * \@description
         *
         * Se verdadeiro, desabilita o campo.
         *
         * \@default `false`
         */
        this.disabled = false;
        /**
         * Indica que o campo será somente leitura.
         */
        this.readonly = false;
        /**
         * \@description
         *
         * Indica que o campo será obrigatório.
         *
         * > Esta propriedade é desconsiderada quando o input está desabilitado `(t-disabled)`.
         *
         * \@default `false`
         */
        this.required = false;
        /**
         * Se verdadeiro, o campo iniciará com foco.
         */
        this.focus = false;
        /**
         * Se verdadeiro, o campo receberá um botão para ser limpo.
         */
        this.clean = false;
        /**
         * \@description
         *
         * Mensagem que será apresentada quando o `pattern` ou a máscara não for satisfeita.
         *
         * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido.
         */
        this.errorPattern = '';
        /**
         * \@description
         *
         * Indica uma máscara para o campo. Exemplos: (+99) (99) 99999?-9999, 99999-999, 999.999.999-99.
         * A máscara gera uma validação automática do campo, podendo esta ser substituída por um REGEX específico
         * através da propriedade t-pattern.
         * O campo será sinalizado e o formulário ficará inválido quando o valor informado estiver fora do padrão definido,
         * mesmo quando desabilitado.
         */
        this.mask = '';
        /**
         * \@description
         *
         * Indica se o `model` receberá o valor formatado pela máscara ou apenas o valor puro (sem formatação).
         *
         * \@default `false`
         */
        this.maskFormatModel = false;
        /**
         * Evento disparado ao sair do campo.
         */
        this.blur = new EventEmitter();
        /**
         * Evento disparado ao entrar do campo.
         */
        this.enter = new EventEmitter();
        /**
         * Evento disparado ao alterar valor e deixar o campo.
         */
        this.change = new EventEmitter();
        /**
         * Evento disparado ao alterar valor do model.
         */
        this.changeModel = new EventEmitter();
        this.onChangePropagate = null;
        this.onTouched = null;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Mensagem que aparecerá enquanto o campo não estiver preenchido.
     *
     * \@default ''
     * @param {?} value
     * @return {?}
     */
    set placeholder(value) {
        this._placeholder = value || '';
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    set setDisabled(disabled) {
        this.disabled = disabled === '' ? true : convertToBoolean(disabled);
        this.validateModel();
    }
    /**
     * @param {?} readonly
     * @return {?}
     */
    set setReadonly(readonly) {
        this.readonly = readonly === '' ? true : convertToBoolean(readonly);
    }
    /**
     * @param {?} required
     * @return {?}
     */
    set setRequired(required) {
        this.required = required === '' ? true : convertToBoolean(required);
        this.validateModel();
    }
    /**
     * @param {?} focus
     * @return {?}
     */
    set setFocus(focus) {
        this.focus = focus === '' ? true : convertToBoolean(focus);
    }
    /**
     * @param {?} clean
     * @return {?}
     */
    set setClean(clean) {
        this.clean = clean === '' ? true : convertToBoolean(clean);
    }
    /**
     * @param {?} pattern
     * @return {?}
     */
    set setPattern(pattern) {
        this.pattern = pattern;
        this.validateModel();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica a quantidade máxima de caracteres que o campo aceita.
     * @param {?} value
     * @return {?}
     */
    set maxlength(value) {
        if (!isNaN(parseInt((/** @type {?} */ (value)), 10))) {
            this._maxlength = parseInt((/** @type {?} */ (value)), 10);
            this.validateModel();
        }
        else if (!value) {
            this._maxlength = undefined;
            this.validateModel();
        }
    }
    /**
     * @return {?}
     */
    get maxlength() {
        return this._maxlength;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica a quantidade mínima de caracteres que o campo aceita.
     * @param {?} value
     * @return {?}
     */
    set minlength(value) {
        if (!isNaN(parseInt((/** @type {?} */ (value)), 10))) {
            this._minlength = parseInt((/** @type {?} */ (value)), 10);
            this.validateModel();
        }
        else if (!value) {
            this._minlength = undefined;
            this.validateModel();
        }
    }
    /**
     * @return {?}
     */
    get minlength() {
        return this._minlength;
    }
    /**
     * @param {?} mask
     * @return {?}
     */
    set setMask(mask) {
        this.mask = mask;
        // Atualiza Máscara do Campo
        this.objMask = new ThfMask(this.mask, this.maskFormatModel);
        this.validateModel();
    }
    /**
     * @param {?} maskFormatModel
     * @return {?}
     */
    set setMaskFormatModel(maskFormatModel) {
        this.maskFormatModel = maskFormatModel === '' ? true : convertToBoolean(maskFormatModel);
        if (this.objMask instanceof ThfMask) {
            this.objMask.formatModel = this.maskFormatModel;
            this.validateModel();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    callOnChange(value) {
        this.updateModel(value);
        this.controlChangeModelEmitter(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    callUpdateModelWithTimeout(value) {
        setTimeout((/**
         * @return {?}
         */
        () => this.updateModel(value)));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    controlChangeModelEmitter(value) {
        if (this.modelLastUpdate !== value) {
            this.changeModel.emit(value);
            this.modelLastUpdate = value;
        }
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangePropagate = func;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouched = func;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateModel(value) {
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangePropagate) {
            this.onChangePropagate(value);
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        if (requiredFailed(this.required, this.disabled, this.getScreenValue())) {
            return { required: {
                    valid: false,
                } };
        }
        if (maxlengthFailed(this.maxlength, this.getScreenValue())) {
            return { maxlength: {
                    valid: false,
                } };
        }
        if (minlengthFailed(this.minlength, this.getScreenValue())) {
            return { minlength: {
                    valid: false,
                } };
        }
        if (patternFailed(this.pattern, c.value)) {
            this.validatePatternOnWriteValue(c.value);
            return { pattern: {
                    valid: false,
                } };
        }
        return this.extraValidation(c);
    }
    // Função implementada do ControlValueAccessor
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.writeValueModel(value);
    }
    /**
     * @protected
     * @return {?}
     */
    validateModel() {
        if (this.validatorChange) {
            this.validatorChange();
        }
    }
    // utilizado para validar o pattern na inicializacao, fazendo dessa forma o campo fica sujo (dirty).
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    validatePatternOnWriteValue(value) {
        if (value && this.passedWriteValue) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.updateModel(value);
            }));
            this.passedWriteValue = false;
        }
    }
}
ThfInputBaseComponent.propDecorators = {
    icon: [{ type: Input, args: ['t-icon',] }],
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    name: [{ type: Input, args: ['name',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    setDisabled: [{ type: Input, args: ['t-disabled',] }],
    setReadonly: [{ type: Input, args: ['t-readonly',] }],
    setRequired: [{ type: Input, args: ['t-required',] }],
    setFocus: [{ type: Input, args: ['t-focus',] }],
    setClean: [{ type: Input, args: ['t-clean',] }],
    setPattern: [{ type: Input, args: ['t-pattern',] }],
    errorPattern: [{ type: Input, args: ['t-error-pattern',] }],
    maxlength: [{ type: Input, args: ['t-maxlength',] }],
    minlength: [{ type: Input, args: ['t-minlength',] }],
    setMask: [{ type: Input, args: ['t-mask',] }],
    setMaskFormatModel: [{ type: Input, args: ['t-mask-format-model',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    blur: [{ type: Output, args: ['t-blur',] }],
    enter: [{ type: Output, args: ['t-enter',] }],
    change: [{ type: Output, args: ['t-change',] }],
    changeModel: [{ type: Output, args: ['t-change-model',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_DECIMAL_DEFAULT_DECIMALS_LENGTH = 2;
/** @type {?} */
const THF_DECIMAL_DEFAULT_THOUSAND_MAXLENGTH = 13;
/**
 *
 * \@docsExtends ThfInputBaseComponent
 *
 * \@description
 *
 * thf-decimal é um input específico para receber apenas números decimais.
 * Quando utilizado, o componente terá comportamento de um campo de 'text' com algumas características:
 *
 * - Aceita apenas números;
 * - Utiliza ',' como separador de decimal;
 * - Utiliza '.' para separação de milhar;
 * - É possível configurar a quantidade de casas decimais e a quantidade de digitos do campo.
 *
 * \@example
 *
 * <example name="thf-decimal-basic" title="Totvs Decimal Basic">
 *  <file name="sample-thf-decimal-basic/sample-thf-decimal-basic.component.html"> </file>
 *  <file name="sample-thf-decimal-basic/sample-thf-decimal-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-decimal-labs" title="Totvs Decimal Labs">
 *  <file name="sample-thf-decimal-labs/sample-thf-decimal-labs.component.html"> </file>
 *  <file name="sample-thf-decimal-labs/sample-thf-decimal-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-decimal-hourly-wage" title="Totvs Decimal - Hourly Wage">
 *  <file name="sample-thf-decimal-hourly-wage/sample-thf-decimal-hourly-wage.component.html"> </file>
 *  <file name="sample-thf-decimal-hourly-wage/sample-thf-decimal-hourly-wage.component.ts"> </file>
 * </example>
 *
 * <example name="thf-decimal-hourly-wage-reactive-form" title="Totvs Decimal - Hourly Wage Reactive Form">
 *  <file name="sample-thf-decimal-hourly-wage-reactive-form/sample-thf-decimal-hourly-wage-reactive-form.component.html"> </file>
 *  <file name="sample-thf-decimal-hourly-wage-reactive-form/sample-thf-decimal-hourly-wage-reactive-form.component.ts"> </file>
 * </example>
 */
class ThfDecimalComponent extends ThfInputBaseComponent {
    /**
     * @param {?} el
     */
    constructor(el) {
        super();
        this.el = el;
        this._decimalsLength = THF_DECIMAL_DEFAULT_DECIMALS_LENGTH;
        this._thousandMaxlength = THF_DECIMAL_DEFAULT_THOUSAND_MAXLENGTH;
        this.decimalSeparator = ',';
        this.fireChange = false;
        this.isKeyboardAndroid = false;
        this.minusSign = '-';
        this.oldDotsLength = null;
        this.thousandSeparator = '.';
        this.regex = {
            thousand: new RegExp('\\' + '.', 'g'),
            decimal: new RegExp('\\' + ',', 'g')
        };
        this.isKeyboardAndroid = !!navigator.userAgent.match(/Android/i);
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Quantidade máxima de casas decimais.
     *
     * \@default `2`
     * @param {?} value
     * @return {?}
     */
    set decimalsLength(value) {
        this._decimalsLength = convertToInt(value, THF_DECIMAL_DEFAULT_DECIMALS_LENGTH);
    }
    /**
     * @return {?}
     */
    get decimalsLength() {
        return this._decimalsLength;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Número máximo de dígitos antes do separador de decimal. O valor máximo possível deve ser menor ou igual a 13.
     *
     * \@default `13`
     * @param {?} value
     * @return {?}
     */
    set thousandMaxlength(value) {
        /** @type {?} */
        const thousandMaxlength = convertToInt(value, THF_DECIMAL_DEFAULT_THOUSAND_MAXLENGTH);
        this._thousandMaxlength = thousandMaxlength <= THF_DECIMAL_DEFAULT_THOUSAND_MAXLENGTH ?
            thousandMaxlength : THF_DECIMAL_DEFAULT_THOUSAND_MAXLENGTH;
    }
    /**
     * @return {?}
     */
    get thousandMaxlength() {
        return this._thousandMaxlength;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.putFocus();
        this.setPaddingInput();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    clear(value) {
        this.callOnChange(value);
        this.controlChangeEmitter();
    }
    /**
     * @param {?} c
     * @return {?}
     */
    extraValidation(c) {
        return null;
    }
    /**
     * @return {?}
     */
    getScreenValue() {
        return (this.inputEl) ? this.inputEl.nativeElement.value : '';
    }
    /**
     * @return {?}
     */
    hasInvalidClass() {
        return (this.el.nativeElement.classList.contains('ng-invalid') &&
            this.el.nativeElement.classList.contains('ng-dirty') &&
            this.getScreenValue() !== '');
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    hasLetters(value = '') {
        return value.match(/[a-zA-Z:;+=_´^~"'@#$%¨&*()/\\|]+/);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isValidNumber(event) {
        // - event.key não existia em alguns browsers, como Samsung browser e Firefox.
        /** @type {?} */
        const keyValue = (/** @type {?} */ (String.fromCharCode(event.which)));
        /** @type {?} */
        const validKey = event.which !== 8 && event.which !== 0;
        return !this.hasLetters(keyValue) && validKey;
    }
    // função responsável por adicionar os zeroes com as casa decimais ao sair do campo.
    /**
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        /** @type {?} */
        const value = event.target.value;
        if (value) {
            if (this.hasLetters(value) || this.containsMoreThanOneComma(value)) {
                this.setViewValue('');
                this.callOnChange(undefined);
                return;
            }
            /** @type {?} */
            const valueWithoutThousandSeparator = this.formatValueWithoutThousandSeparator(value);
            this.setViewValue(this.formatToViewValue(valueWithoutThousandSeparator));
        }
        this.blur.emit();
        this.controlChangeEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        // Atualiza valor da variável que será usada para verificar se o campo teve alteração
        this.valueBeforeChange = this.getScreenValue();
        // Dispara evento quando o usuário entrar no campo
        // Este evento também é disparado quando o campo inicia com foco.
        this.enter.emit();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInput(event) {
        /** @type {?} */
        const selectionStart = event.target.selectionStart;
        /** @type {?} */
        const selectionEnd = event.target.selectionEnd;
        /** @type {?} */
        let modelValue;
        /** @type {?} */
        let viewValue;
        // - Browsers nativos do Android ex: Samsung Browser.
        if (this.isKeyboardAndroid) {
            this.onInputKeyboardAndroid(event);
        }
        modelValue = this.formatValueWithoutThousandSeparator(event.target.value);
        modelValue = this.addZeroBefore(modelValue);
        viewValue = this.formatMask(modelValue);
        // validação para não quebrar IE com placeholder definido e Input vazio
        if (viewValue) {
            this.setViewValue(viewValue);
            this.setCursorInput(event, selectionStart, selectionEnd);
        }
        this.callOnChange(this.formatToModelValue(modelValue));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputKeyboardAndroid(event) {
        /** @type {?} */
        const inputValue = event.target.value;
        /** @type {?} */
        const selectionStart = event.target.selectionStart;
        /** @type {?} */
        const hasLetters = this.hasLetters(inputValue);
        if (hasLetters) {
            this.setViewValue(inputValue.replace(hasLetters[0], ''));
            return event.preventDefault();
        }
        else {
            /** @type {?} */
            const position = selectionStart - 1;
            /** @type {?} */
            const key = inputValue.charAt(position);
            this.setPositionValue(event);
            if (this.isValidKey(event, key)) {
                this.setViewValue(inputValue);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyPress(event) {
        this.isValidKey(event);
    }
    /**
     * @return {?}
     */
    setPaddingInput() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const selectorIcons = '.thf-field-icon-container:not(.thf-field-icon-container-left) > .thf-icon';
            /** @type {?} */
            let icons = this.el.nativeElement.querySelectorAll(selectorIcons).length;
            if (this.clean) {
                icons++;
            }
            if (icons) {
                this.inputEl.nativeElement.style.paddingRight = `${icons * 36}px`;
            }
        }));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValueModel(value) {
        if (this.inputEl) {
            if (value || value === 0) {
                /** @type {?} */
                const formatedViewValue = this.formatToViewValue(value);
                this.setViewValue(formatedViewValue);
            }
            else {
                this.setViewValue('');
            }
        }
        if (value) {
            this.change.emit(value);
        }
    }
    // reponsável por adicionar 0 antes da virgula (decimalSeparator).
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    addZeroBefore(value) {
        /** @type {?} */
        const isDecimalSeparator = value === this.decimalSeparator;
        return isDecimalSeparator ? `0${value}` : value;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    containsComma(value) {
        return value.includes(this.decimalSeparator);
    }
    /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    containsMoreThanOneComma(value = '') {
        /** @type {?} */
        const foundComma = value.match(/,/g);
        return !!(foundComma && foundComma.length > 1);
    }
    /**
     * @private
     * @return {?}
     */
    controlChangeEmitter() {
        /** @type {?} */
        const elementValue = this.getScreenValue();
        // Emite o evento change manualmente quando o campo é alterado
        // Este evento é controlado manualmente devido ao preventDefault existente na máscara
        // e devido ao controle do t-clean, que também precisa emitir change
        if (elementValue !== this.valueBeforeChange) {
            this.fireChange = true;
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (this.fireChange) {
                    this.change.emit(elementValue);
                }
            }), 200);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    formatMask(value) {
        // necessário para não adicionar . nas casa decimais.
        // por exemplo: 12.345,123.45 (errado)
        // 12.345,12345 (correto)
        if (value.match(this.regex.decimal)) {
            /** @type {?} */
            const regex = new RegExp('(\\d)(?=(\\d{3})+(?!\\d),)', 'g');
            return value.toString().replace(regex, '$1.');
        }
        return value.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.');
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    formatToModelValue(value) {
        /** @type {?} */
        const formattedValue = this.replaceCommaToDot(value);
        /** @type {?} */
        const parsedValue = formattedValue ? parseFloat(Number(formattedValue).toFixed(this.decimalsLength)) : undefined;
        return parsedValue === 0 || parsedValue ? parsedValue : undefined;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    formatToViewValue(value) {
        /** @type {?} */
        let formatedNumber;
        /** @type {?} */
        let numberValue;
        /** @type {?} */
        let valueBeforeDot;
        /** @type {?} */
        let valueAfterDot;
        // - Necessário para tratar valores que contenham decimalSeparator
        value = this.replaceCommaToDot(value);
        numberValue = Number(value).toFixed(this.decimalsLength);
        valueBeforeDot = this.getValueBeforeSeparator(numberValue, this.thousandSeparator);
        valueAfterDot = this.getValueAfterSeparator(numberValue, this.thousandSeparator);
        formatedNumber = this.formatMask(valueBeforeDot);
        if (this.decimalsLength === 0) {
            return formatedNumber;
        }
        else {
            return formatedNumber + this.decimalSeparator + valueAfterDot;
        }
    }
    /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    formatValueWithoutThousandSeparator(value = '') {
        return value.toString().replace(this.regex.thousand, '');
    }
    /**
     * @private
     * @param {?=} value
     * @param {?=} separator
     * @return {?}
     */
    getValueAfterSeparator(value = '', separator) {
        return value.split(separator)[1] || '';
    }
    /**
     * @private
     * @param {?=} value
     * @param {?=} separator
     * @return {?}
     */
    getValueBeforeSeparator(value = '', separator) {
        return value.split(separator)[0] || '';
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    hasLessDot(value) {
        if (value) {
            /** @type {?} */
            const dots = value.match(this.regex.thousand);
            /** @type {?} */
            const dotsLength = dots && dots.length;
            if (dotsLength < this.oldDotsLength) {
                this.oldDotsLength = dotsLength;
                return true;
            }
        }
        if (!value) {
            this.oldDotsLength = null;
        }
        return false;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    hasMoreDot(value) {
        if (value) {
            /** @type {?} */
            const dots = value.match(this.regex.thousand);
            /** @type {?} */
            const dotsLength = dots && dots.length;
            if (dotsLength > this.oldDotsLength) {
                this.oldDotsLength = dotsLength;
                return true;
            }
        }
        if (!value) {
            this.oldDotsLength = null;
        }
        return false;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    hasMinusSignInvalidPosition(event) {
        /** @type {?} */
        const keyIsMinusSign = event.key === this.minusSign;
        /** @type {?} */
        const selectionStart = event.target.selectionStart;
        return keyIsMinusSign && selectionStart !== 0;
    }
    /**
     * @private
     * @param {?} event
     * @param {?} charCode
     * @return {?}
     */
    isInvalidKey(event, charCode) {
        /** @type {?} */
        const isInvalidNumber = !this.isValidNumber(event);
        return this.verifyInsertComma(event) || this.verifyThousandLength(event) ||
            this.verifyValueAfterComma(event) || this.verifyInsertMinusSign(event) ||
            this.hasMinusSignInvalidPosition(event) || isInvalidNumber ||
            this.validateCursorPositionBeforeSeparator(event) || this.verifyDecimalLengthIsZeroAndKeyPressedIsComma(charCode);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    isKeyDecimalSeparator(event) {
        return event.key === this.decimalSeparator || event.char === this.decimalSeparator;
    }
    /**
     * @private
     * @param {?} positionCursor
     * @param {?} value
     * @return {?}
     */
    isPositionAfterDecimalSeparator(positionCursor, value) {
        /** @type {?} */
        const indexComma = value && value.indexOf(this.decimalSeparator);
        if (indexComma && this.decimalsLength > 0) {
            return positionCursor > indexComma;
        }
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    isSelectionStartDifferentSelectionEnd(target) {
        return target.selectionStart !== target.selectionEnd;
    }
    /**
     * @private
     * @param {?} event
     * @param {?=} key
     * @return {?}
     */
    isValidKey(event, key) {
        /** @type {?} */
        const charCode = event.which || event.keyCode;
        /** @type {?} */
        const validKey = event.which === 8 || event.which === 0;
        if (validKey && !this.isKeyboardAndroid) {
            return;
        }
        if (key) {
            event.key = key;
        }
        if (this.isInvalidKey(event, charCode)) {
            event.preventDefault();
            return false;
        }
        return true;
    }
    // Quando decimalsLength for 0 não deve permitir informar vírgula (decimalSeparator)
    /**
     * @private
     * @param {?} charCode
     * @return {?}
     */
    verifyDecimalLengthIsZeroAndKeyPressedIsComma(charCode) {
        return (charCode === 44 && this.decimalsLength === 0);
    }
    /**
     * @private
     * @return {?}
     */
    putFocus() {
        if (this.focus) {
            this.inputEl.nativeElement.focus();
        }
    }
    /**
     * @private
     * @param {?} target
     * @param {?} selectionStart
     * @param {?} selectionEnd
     * @return {?}
     */
    setInitialSelectionRange(target, selectionStart, selectionEnd) {
        if (selectionStart === 1 && selectionEnd === 1) {
            return target.setSelectionRange(selectionStart + 1, selectionEnd + 1);
        }
        return target.setSelectionRange(selectionStart - 1, selectionEnd - 1);
    }
    /**
     * @private
     * @param {?} value
     * @param {?} index
     * @param {?} replace
     * @return {?}
     */
    replaceAt(value, index, replace) {
        return value.substring(0, index) + replace + value.substring(index + 1);
    }
    /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    replaceCommaToDot(value = '') {
        return value.toString().replace(this.regex.decimal, '.');
    }
    /**
     * @private
     * @param {?} event
     * @param {?} selectionStart
     * @param {?} selectionEnd
     * @return {?}
     */
    setCursorInput(event, selectionStart, selectionEnd) {
        /** @type {?} */
        const target = event.target;
        /** @type {?} */
        const viewValue = target.value;
        // Caso houver mais . do que anteriormente soma o valor com 1.
        if (this.hasMoreDot(viewValue) || viewValue === ('0' + this.decimalSeparator)) {
            return target.setSelectionRange(selectionStart + 1, selectionEnd + 1);
        }
        // Caso houver menos . do que anteriormente subtrai o valor por 1.
        if (this.hasLessDot(viewValue)) {
            this.setInitialSelectionRange(target, selectionStart, selectionEnd);
        }
        return target.setSelectionRange(selectionStart, selectionEnd);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    setPositionValue(event) {
        /** @type {?} */
        const value = event.target.value;
        /** @type {?} */
        const position = event.target.selectionStart - 1;
        if (position > 0 && event.key === this.minusSign) {
            event.target.value = value.substring(0, position) + value.substr(position + 1);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setViewValue(value) {
        this.inputEl.nativeElement.value = value;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    validateCursorPositionBeforeSeparator(event) {
        /** @type {?} */
        const target = event.target;
        /** @type {?} */
        const originalValue = this.formatValueWithoutThousandSeparator(target.value);
        /** @type {?} */
        const valueBeforeSeparator = this.getValueBeforeSeparator(target.value, this.decimalSeparator);
        /** @type {?} */
        const valueBeforeSeparatorOriginal = this.getValueBeforeSeparator(originalValue, this.decimalSeparator);
        if (this.isSelectionStartDifferentSelectionEnd(target)) {
            return false;
        }
        return target.selectionStart <= valueBeforeSeparator.length &&
            valueBeforeSeparatorOriginal.length === this.thousandMaxlength &&
            !this.isKeyDecimalSeparator(event);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    verifyThousandLength(event) {
        /** @type {?} */
        const target = event.target;
        /** @type {?} */
        const originalValue = this.formatValueWithoutThousandSeparator(target.value);
        /** @type {?} */
        const valueBeforeSeparatorOriginal = this.getValueBeforeSeparator(originalValue, this.decimalSeparator);
        if (this.isSelectionStartDifferentSelectionEnd(target)) {
            return false;
        }
        return valueBeforeSeparatorOriginal.length >= this.thousandMaxlength &&
            !this.isKeyDecimalSeparator(event) &&
            this.isPositionAfterDecimalSeparator(target.selectionStart - this.decimalsLength, target.value);
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    verifyInsertComma(e) {
        /** @type {?} */
        const hasComma = this.containsComma(e.target.value);
        return hasComma && e.key === this.decimalSeparator;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    verifyInsertMinusSign(event) {
        /** @type {?} */
        const value = event.target.value;
        /** @type {?} */
        const indexMinusSign = (value.lastIndexOf(this.minusSign) !== -1);
        /** @type {?} */
        const positionMinusSign = value.lastIndexOf('-');
        /** @type {?} */
        const occurancesMinusSign = value.match(new RegExp('-', 'g'));
        if (this.isKeyboardAndroid && indexMinusSign && occurancesMinusSign.length > 1) {
            event.target.value = this.replaceAt(value, positionMinusSign, '');
        }
        return indexMinusSign && event.key === this.minusSign;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    verifyValueAfterComma(event) {
        /** @type {?} */
        const value = event.target.value;
        /** @type {?} */
        const selectionStart = event.target.selectionStart;
        /** @type {?} */
        const valueAfterSeparator = this.getValueAfterSeparator(value, this.decimalSeparator);
        return this.isPositionAfterDecimalSeparator(selectionStart, value) && valueAfterSeparator.length >= this.decimalsLength;
    }
}
ThfDecimalComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-decimal',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n\n    <div *ngIf=\"icon\" class=\"thf-field-icon-container-left\">\n      <span class=\"thf-icon thf-field-icon {{ icon }}\" [class.thf-field-icon-disabled]=\"disabled\"></span>\n    </div>\n\n    <input #inp\n      class=\"thf-input\"\n      type=\"text\"\n      (input)=\"onInput($event)\"\n      (focus)=\"onFocus($event)\"\n      (blur)=\"onBlur($event)\"\n      (keypress)=\"onKeyPress($event)\"\n      [attr.name]=\"name\"\n      [class.thf-input-icon-left]=\"icon\"\n      [class.thf-input-icon-right]=\"clean\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean [t-element-ref]=\"inputEl\" (t-change-event)=\"clear($event)\"></thf-clean>\n    </div>\n  </div>\n\n  <thf-field-container-bottom>\n  </thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfDecimalComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfDecimalComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfDecimalComponent.ctorParameters = () => [
    { type: ElementRef }
];
ThfDecimalComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['inp', { read: ElementRef, static: true },] }],
    decimalsLength: [{ type: Input, args: ['t-decimals-length',] }],
    thousandMaxlength: [{ type: Input, args: ['t-thousand-maxlength',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ThfInputGeneric extends ThfInputBaseComponent {
    /**
     * @param {?} el
     */
    constructor(el) {
        super();
        this.type = 'text';
        this.el = el;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.afterViewInit();
    }
    /**
     * @return {?}
     */
    afterViewInit() {
        this.putFocus();
        if (this.type !== 'password') {
            this.setPaddingInput();
        }
    }
    /**
     * @return {?}
     */
    setPaddingInput() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const selectorIcons = '.thf-field-icon-container:not(.thf-field-icon-container-left) > .thf-icon';
            /** @type {?} */
            let icons = this.el.nativeElement.querySelectorAll(selectorIcons).length;
            if (this.clean) {
                icons++;
            }
            if (icons) {
                this.inputEl.nativeElement.style.paddingRight = `${icons * 36}px`;
            }
        }));
    }
    /**
     * @return {?}
     */
    putFocus() {
        if (this.focus) {
            this.inputEl.nativeElement.focus();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown(e) {
        if (this.mask && !this.readonly && e.target.keyCode !== 229) {
            this.eventOnBlur(e);
            this.objMask.keydown(e);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyup(e) {
        if (this.mask && !this.readonly) {
            if (e.target.keyCode !== 229) {
                this.eventOnBlur(e);
                this.objMask.keyup(e);
            }
            this.callOnChange(this.objMask.valueToModel);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    eventOnInput(e) {
        if (!this.mask) {
            /** @type {?} */
            const value = this.validMaxLength(this.maxlength, e.target.value);
            this.inputEl.nativeElement.value = value;
            this.callOnChange(value);
        }
    }
    /**
     * @param {?} maxlength
     * @param {?} value
     * @return {?}
     */
    validMaxLength(maxlength, value) {
        return ((maxlength || maxlength === 0) && value.length > maxlength) ? value.toString().substring(0, maxlength) : value;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    eventOnFocus(e) {
        // Atualiza valor da variável que será usada para verificar se o campo teve alteração
        this.valueBeforeChange = this.inputEl.nativeElement.value;
        // Dispara evento quando o usuário entrar no campo
        // Este evento também é disparado quando o campo inicia com foco.
        this.enter.emit();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    eventOnBlur(e) {
        if (this.mask) {
            this.objMask.blur(e);
        }
        if (e.type === 'blur') {
            this.blur.emit();
            this.controlChangeEmitter();
        }
    }
    /**
     * @return {?}
     */
    controlChangeEmitter() {
        /** @type {?} */
        const elementValue = this.inputEl.nativeElement.value;
        // Emite o evento change manualmente quando o campo é alterado
        // Este evento é controlado manualmente devido ao preventDefault existente na máscara
        // e devido ao controle do t-clean, que também precisa emitir change
        if (elementValue !== this.valueBeforeChange) {
            clearTimeout(this.timeoutChange);
            this.timeoutChange = setTimeout((/**
             * @return {?}
             */
            () => {
                this.change.emit(elementValue);
            }), 200);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    eventOnClick(e) {
        // Atualiza a posição do cursor ao clicar
        if (this.mask) {
            this.objMask.click(e);
        }
    }
    /**
     * @return {?}
     */
    hasInvalidClass() {
        return (this.el.nativeElement.classList.contains('ng-invalid') &&
            this.el.nativeElement.classList.contains('ng-dirty') &&
            this.inputEl.nativeElement.value !== '');
    }
    /**
     * @return {?}
     */
    getErrorPattern() {
        return (this.errorPattern !== '' && this.hasInvalidClass()) ? this.errorPattern : '';
    }
    /**
     * @return {?}
     */
    validateClassesForPattern() {
        /** @type {?} */
        const value = this.getScreenValue();
        /** @type {?} */
        const element = this.el.nativeElement;
        if (value && !this.verifyPattern(this.pattern, value)) {
            element.classList.add('ng-invalid');
            element.classList.add('ng-dirty');
        }
        else {
            element.classList.remove('ng-invalid');
        }
    }
    /**
     * @param {?} pattern
     * @param {?} value
     * @return {?}
     */
    verifyPattern(pattern, value) {
        return new RegExp(pattern).test(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    clear(value) {
        this.callOnChange(value);
        this.controlChangeEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValueModel(value) {
        this.passedWriteValue = true;
        if (this.inputEl) {
            if (value) {
                if (this.mask) {
                    this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
                    // Se o model for definido como formatado, então precisa atualizá-lo no primeiro acesso
                    if (this.objMask.formatModel) {
                        this.callUpdateModelWithTimeout(this.objMask.valueToModel);
                    }
                }
                else {
                    this.inputEl.nativeElement.value = value;
                }
            }
            else {
                // Se o valor for indefinido, deve limpar o campo.
                this.inputEl.nativeElement.value = '';
            }
        }
        // Emite evento quando o model é atualizado, inclusive a primeira vez
        if (value) {
            this.changeModel.emit(value);
        }
    }
    /**
     * @return {?}
     */
    getScreenValue() {
        /** @type {?} */
        const screenValue = this.inputEl && this.inputEl.nativeElement.value || undefined;
        if (this.type === 'number') {
            /** @type {?} */
            const parsedValue = parseFloat(screenValue);
            return parsedValue || parsedValue === 0 ? parsedValue : null;
        }
        else {
            return screenValue;
        }
    }
}
ThfInputGeneric.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['inp', { read: ElementRef, static: true },] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onKeyup: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfInputBaseComponent
 *
 * \@description
 *
 * thf-email é um input específico para receber E-mail, com o pattern já configurado.
 *
 * \@example
 *
 * <example name="thf-email-basic" title="Totvs Email Basic">
 *  <file name="sample-thf-email-basic/sample-thf-email-basic.component.html"> </file>
 *  <file name="sample-thf-email-basic/sample-thf-email-basic.component.ts"> </file>
 *  <file name="sample-thf-email-basic/sample-thf-email-basic.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-email-basic/sample-thf-email-basic.component.po.ts"> </file>
 * </example>
 *
 * <example name="thf-email-labs" title="Totvs Email Labs">
 *  <file name="sample-thf-email-labs/sample-thf-email-labs.component.html"> </file>
 *  <file name="sample-thf-email-labs/sample-thf-email-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-email-newsletter" title="Totvs Email - Newsletter">
 *  <file name="sample-thf-email-newsletter/sample-thf-email-newsletter.component.html"> </file>
 *  <file name="sample-thf-email-newsletter/sample-thf-email-newsletter.component.ts"> </file>
 * </example>
 */
class ThfEmailComponent extends ThfInputGeneric {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
        this.icon = 'thf-icon-mail';
        this.maxlength = 254;
        this.type = 'email';
        this.pattern = '^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$';
        this.mask = '';
        this.listener = this.validateClassesForPattern.bind(this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            // Se não tem ngModel ou reactive form adiciona validação com classes css
            if (!this.onChangePropagate) {
                this.inputEl.nativeElement.addEventListener('keyup', this.listener);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (!this.onChangePropagate) {
            this.inputEl.nativeElement.removeEventListener('keyup', this.listener);
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    extraValidation(c) {
        return null;
    }
}
ThfEmailComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-email',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <div *ngIf=\"icon\" class=\"thf-field-icon-container-left\">\n      <span class=\"thf-icon thf-field-icon {{ icon }}\" [class.thf-field-icon-disabled]=\"disabled\"></span>\n    </div>\n\n    <input #inp\n      class=\"thf-input\"\n      [attr.name]=\"name\"\n      [class.thf-input-icon-left]=\"icon\"\n      [class.thf-input-icon-right]=\"clean\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      [type]=\"type\"\n      (blur)=\"eventOnBlur($event)\"\n      (click)=\"eventOnClick($event)\"\n      (focus)=\"eventOnFocus($event)\"\n      (input)=\"eventOnInput($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean [t-element-ref]=\"inputEl\" (t-change-event)=\"clear($event)\"></thf-clean>\n    </div>\n  </div>\n\n  <thf-field-container-bottom\n    [t-error-pattern]=\"getErrorPattern()\">\n  </thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfEmailComponent)),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfEmailComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
ThfEmailComponent.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * Componente de uso interno, responsável por atribuir uma label para o campo
 */
class ThfFieldContainerComponent {
    constructor() {
        this._optional = false;
    }
    /**
     * Indica se o campo será opcional.
     * @param {?} value
     * @return {?}
     */
    set optional(value) {
        this._optional = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get optional() {
        return this._optional;
    }
    /**
     * @return {?}
     */
    getOptionalText() {
        /** @type {?} */
        const browserLanguage = getShortBrowserLanguage();
        /** @type {?} */
        const optional = {
            pt: '(Opcional)',
            en: '(Optional)',
            es: '(Opcional)'
        };
        return optional[browserLanguage];
    }
}
ThfFieldContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-field-container',
                template: "<div class=\"thf-field-container\">\n  <div class=\"thf-field-container-title\">\n    <span class=\"thf-field-title\">{{ label }}</span>\n    <span class=\"thf-field-optional\" *ngIf=\"optional && (label || help)\">{{ getOptionalText() }}</span>\n  </div>\n\n  <div class=\"thf-field-help\" *ngIf=\"help\">{{ help }}</div>\n\n  <ng-content></ng-content>\n</div>\n"
            }] }
];
ThfFieldContainerComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    optional: [{ type: Input, args: ['t-optional',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente de uso interno, responsável por gerar uma margem inferior nos componentes que utilizam o thf-field-container.
 * Essa margem inferior pode conter uma mensagem de erro.
 */
class ThfFieldContainerBottomComponent {
    constructor() {
        /**
         * Mensagem que será apresentada quando o pattern ou a máscara não for satisfeita.
         * Obs: Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido.
         */
        this.errorPattern = '';
    }
}
ThfFieldContainerBottomComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-field-container-bottom',
                template: "<div class=\"thf-field-container-bottom\">\n  <span *ngIf=\"errorPattern\"  class=\"thf-field-container-bottom-text-error\">\n    <span class=\"thf-icon thf-icon-warning thf-field-container-icon-error\"></span>\n    {{ errorPattern }}\n  </span>\n</div>\n"
            }] }
];
ThfFieldContainerBottomComponent.propDecorators = {
    errorPattern: [{ type: Input, args: ['t-error-pattern',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfInputBaseComponent
 *
 * \@description
 * O thf-login é um input específico para login. Já possui tipo, estilo e ícone predefinidos.
 *
 * \@example
 *
 * <example name="thf-login-basic" title="Totvs Login Basic">
 *  <file name="sample-thf-login-basic/sample-thf-login-basic.component.html"> </file>
 *  <file name="sample-thf-login-basic/sample-thf-login-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-login-labs" title="Totvs Login Labs">
 *  <file name="sample-thf-login-labs/sample-thf-login-labs.component.html"> </file>
 *  <file name="sample-thf-login-labs/sample-thf-login-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-login-confirm" title="Totvs Login - Confirm Identity">
 *  <file name="sample-thf-login-confirm/sample-thf-login-confirm.component.html"> </file>
 *  <file name="sample-thf-login-confirm/sample-thf-login-confirm.component.ts"> </file>
 * </example>
 *
 */
class ThfLoginComponent extends ThfInputGeneric {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
        this.type = 'text';
    }
    /**
     * @param {?} c
     * @return {?}
     */
    extraValidation(c) {
        return null;
    }
}
ThfLoginComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-login',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <div class=\"thf-field-icon-container-left\">\n      <span class=\"thf-icon thf-field-icon thf-icon-user\" [class.thf-field-icon-disabled]=\"disabled\"></span>\n    </div>\n\n    <input #inp\n      class=\"thf-input thf-input-icon-left\"\n      [attr.name]=\"name\"\n      [class.thf-input-icon-right]=\"clean\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      [type]=\"type\"\n      (blur)=\"eventOnBlur($event)\"\n      (click)=\"eventOnClick($event)\"\n      (focus)=\"eventOnFocus($event)\"\n      (input)=\"eventOnInput($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean [t-element-ref]=\"inputEl\" (t-change-event)=\"clear($event)\"></thf-clean>\n    </div>\n  </div>\n\n  <thf-field-container-bottom\n    [t-error-pattern]=\"getErrorPattern()\">\n  </thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfLoginComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfLoginComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfLoginComponent.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Componente utilizado para abrir uma janela de busca com uma tabela que lista dados de um serviço. Nesta janela é possível buscar e
 * selecionar o registro que será enviado para o campo. O `thf-lookup` permite que o usuário digite um valor e pressione a tecla *TAB* para
 * buscar um registro.
 *
 * > Caso o campo seja iniciado ou preenchido com um valor inexistente na busca, o mesmo será limpado.
 * No segundo caso ocorrerá após este perder o foco; ambos os casos o campo ficará inválido quando requerido.
 *
 * Este componente não é recomendado quando a busca dos dados possuir poucas informações, para isso utilize outros componentes como o
 * `thf-select` ou o `thf-combo`.
 * @abstract
 */
class ThfLookupBaseComponent {
    /**
     * @param {?} defaultService
     */
    constructor(defaultService) {
        this.defaultService = defaultService;
        this._disabled = false;
        this._focus = false;
        this._required = false;
        this.oldValue = '';
        this.onChangePropagate = null;
        // tslint:disable-next-line
        this.onTouched = null;
        /**
         * Mensagem que aparecerá enquanto o campo não estiver preenchido.
         */
        this.placeholder = '';
        /**
         * Evento será disparado quando ocorrer algum erro na requisição de busca do item.
         * Será passado por parâmetro o objeto de erro retornado.
         */
        this.onError = new EventEmitter();
        /**
         * Evento será disparado quando ocorrer alguma seleção.
         * Será passado por parâmetro o objeto com o valor selecionado.
         */
        this.selected = new EventEmitter();
    }
    /**
     * Serviço responsável por buscar os dados da tabela na janela. Pode ser informado um serviço que implemente a interface
     * `ThfLookupFilter` ou uma URL.
     *
     * Quando utilizada uma URL de um serviço, será concatenada nesta URL o valor que deseja-se filtrar, por exemplo:
     *
     * ```
     * url + ?page=1&pageSize=20&filter=Peter
     * ```
     *
     * Se for definido a propriedade `t-filter-params`, o mesmo também será concatenado. Por exemplo, para o
     * parâmetro `{ age: 23 }` a URL ficaria:
     *
     * ```
     * url + ?page=1&pageSize=20&age=23&filter=Peter
     * ```
     *
     * > Esta URL deve retornar e receber os dados no padrão de
     * [API da TOTVS](http://tdn.totvs.com/display/public/INT/Guia+de+implementacao+das+APIs+TOTVS) e utiliza os valores
     * definidos nas propriedades `t-field-label` e `t-field-value` para a construção do `thf-lookup`.
     * @param {?} filterService
     * @return {?}
     */
    set filterService(filterService) {
        this._filterService = filterService;
        this.setService(this.filterService);
    }
    /**
     * @return {?}
     */
    get filterService() {
        return this._filterService;
    }
    /**
     * \@optional
     * \@description
     *
     * Indica que o campo será obrigatório. Esta propriedade é desconsiderada quando o campo está desabilitado (t-disabled).
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.valueToModel);
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * \@description
     *
     * Indica que o campo iniciará com foco.
     *
     * \@default false
     * \@optional
     * @param {?} focus
     * @return {?}
     */
    set focus(focus) {
        this._focus = (/** @type {?} */ (focus)) === '' ? true : convertToBoolean(focus);
    }
    /**
     * @return {?}
     */
    get focus() {
        return this._focus;
    }
    /**
     * \@description
     *
     * Indica que o campo será desabilitado.
     *
     * \@default false
     * \@optional
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = (/** @type {?} */ (disabled)) === '' ? true : convertToBoolean(disabled);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.getSubscription) {
            this.getSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initializeColumn();
    }
    /**
     * @private
     * @return {?}
     */
    initializeColumn() {
        if (this.fieldLabel) {
            this.keysDescription = [this.fieldLabel];
        }
        else {
            this.keysDescription = [];
            this.keysDescription = this.columns.filter((/**
             * @param {?} element
             * @return {?}
             */
            element => element.fieldLabel))
                .map((/**
             * @param {?} element
             * @return {?}
             */
            element => element.property));
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    // Função implementada do ControlValueAccessor.
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model.
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangePropagate = func;
    }
    // Função implementada do ControlValueAccessor.
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model.
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouched = func;
    }
    // Seleciona o valor do model.
    /**
     * @param {?} valueSelected
     * @return {?}
     */
    selectValue(valueSelected) {
        this.valueToModel = valueSelected[this.fieldValue];
        this.callOnChange(this.valueToModel);
        this.selected.emit(valueSelected);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    callOnChange(value) {
        // Quando o input não possui um formulário, então esta função não é registrada.
        if (this.onChangePropagate) {
            this.onChangePropagate(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    searchById(value) {
        if (typeof (value) === 'string') {
            value = value.trim();
        }
        if (value !== '') {
            this.getSubscription = this.service.getObjectByValue(value, this.filterParams).subscribe((/**
             * @param {?} element
             * @return {?}
             */
            element => {
                if (element) {
                    this.oldValue = element[this.fieldLabel];
                    this.selectValue(element);
                    this.setViewValue(this.getFormattedLabel(element), element);
                }
                else {
                    this.cleanModel();
                }
            }), (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                this.cleanModel();
                this.onError.emit(error);
            }));
        }
        else {
            this.cleanModel();
        }
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
            return {
                required: {
                    valid: false,
                }
            };
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value && value instanceof Object) {
            // Esta condição é executada quando é retornado o objeto selecionado do componente Thf Lookup Modal.
            this.oldValue = value[this.fieldLabel];
            this.valueToModel = value[this.fieldValue];
            this.setViewValue(this.getFormattedLabel(value), value);
        }
        else if (value) {
            // Esta condição é executada somente quando é passado o ID para realizar a busca pelo ID.
            this.searchById(value);
        }
        else {
            this.cleanViewValue();
        }
    }
    /**
     * @protected
     * @return {?}
     */
    cleanModel() {
        this.cleanViewValue();
        this.callOnChange(undefined);
    }
    /**
     * @protected
     * @return {?}
     */
    cleanViewValue() {
        this.setViewValue('', {});
        this.oldValue = '';
        this.valueToModel = null;
    }
    // Formata a label do campo.
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    getFormattedLabel(value) {
        return value ? this.keysDescription.map((/**
         * @param {?} column
         * @return {?}
         */
        column => value[column])).join(' - ') : '';
    }
    // Chama o método writeValue e preenche o model.
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    selectModel(value) {
        this.writeValue(value);
        if (value && value instanceof Object) {
            this.selectValue(value);
        }
    }
    /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    validateModel(model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    /**
     * @private
     * @param {?} service
     * @return {?}
     */
    setService(service) {
        if (isTypeof(service, 'object')) {
            this.service = (/** @type {?} */ (service));
        }
        if (service && isTypeof(service, 'string')) {
            this.service = this.defaultService;
            this.service.setUrl(service);
        }
    }
}
ThfLookupBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    help: [{ type: Input, args: ['t-help',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    name: [{ type: Input, args: ['name',] }],
    fieldValue: [{ type: Input, args: ['t-field-value',] }],
    fieldLabel: [{ type: Input, args: ['t-field-label',] }],
    filterParams: [{ type: Input, args: ['t-filter-params',] }],
    fieldFormat: [{ type: Input, args: ['t-field-format',] }],
    columns: [{ type: Input, args: ['t-columns',] }],
    filterService: [{ type: Input, args: ['t-filter-service',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    required: [{ type: Input, args: ['t-required',] }],
    focus: [{ type: Input, args: ['t-focus',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    onError: [{ type: Output, args: ['t-error',] }],
    selected: [{ type: Output, args: ['t-selected',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço padrão utilizado para filtrar os dados do componente thf-lookup.
 */
class ThfLookupFilterService {
    /**
     * @param {?} httpClient
     */
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    /**
     * @param {?} filter
     * @param {?} page
     * @param {?=} pageSize
     * @param {?=} filterParams
     * @return {?}
     */
    getFilteredData(filter, page, pageSize, filterParams) {
        /** @type {?} */
        const validatedFilterParams = this.validateParams(filterParams);
        return this.httpClient.get(this.url, { params: Object.assign({ page: page.toString(), pageSize: pageSize.toString() }, validatedFilterParams, { filter }) });
    }
    /**
     * @param {?} value
     * @param {?=} filterParams
     * @return {?}
     */
    getObjectByValue(value, filterParams) {
        /** @type {?} */
        const validatedFilterParams = this.validateParams(filterParams);
        return this.httpClient.get(`${this.url}/${value}`, { params: validatedFilterParams });
    }
    /**
     * @param {?} url
     * @return {?}
     */
    setUrl(url) {
        this.url = url;
    }
    /**
     * @private
     * @param {?} params
     * @return {?}
     */
    validateParams(params) {
        return isTypeof(params, 'object') && !Array.isArray(params) ? params : undefined;
    }
}
ThfLookupFilterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfLookupFilterService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfComponentInjectorService {
    /**
     * @param {?} componentResolver
     * @param {?} applicationRef
     * @param {?} injector
     */
    constructor(componentResolver, applicationRef, injector) {
        this.componentResolver = componentResolver;
        this.applicationRef = applicationRef;
        this.injector = injector;
    }
    // Cria um dinamicamente no ApplicationRef
    /**
     * @param {?} component
     * @return {?}
     */
    createComponentInApplication(component) {
        /** @type {?} */
        const componentRef = this.componentResolver.resolveComponentFactory(component).create(this.injector);
        this.applicationRef.attachView(componentRef.hostView);
        /** @type {?} */
        const domElem = ((/** @type {?} */ (componentRef.hostView))).rootNodes[0];
        document.body.appendChild(domElem);
        return componentRef;
    }
    // Destrói o componente e remove do ApplicationRef
    /**
     * @param {?} componentRef
     * @return {?}
     */
    destroyComponentInApplication(componentRef) {
        this.applicationRef.detachView(componentRef.hostView);
        componentRef.destroy();
    }
}
ThfComponentInjectorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ThfComponentInjectorService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector }
];
/** @nocollapse */ ThfComponentInjectorService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ThfComponentInjectorService_Factory() { return new ThfComponentInjectorService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationRef), ɵɵinject(INJECTOR)); }, token: ThfComponentInjectorService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfLookupLiteralsDefault = {
    en: (/** @type {?} */ ({
        modalPrimaryActionLabel: 'Select',
        modalSecondaryActionLabel: 'Cancel',
        modalPlaceholder: 'Search',
        modalTitle: 'Select a record',
        modalTableNoColumns: thfTableLiteralsDefault.en.noColumns,
        modalTableNoData: thfTableLiteralsDefault.en.noData,
        modalTableLoadingData: thfTableLiteralsDefault.en.loadingData,
        modalTableLoadMoreData: thfTableLiteralsDefault.en.loadMoreData
    })),
    es: (/** @type {?} */ ({
        modalPrimaryActionLabel: 'Seleccionar',
        modalSecondaryActionLabel: 'Cancelar',
        modalPlaceholder: 'Buscar',
        modalTitle: 'Seleccione un registro',
        modalTableNoColumns: thfTableLiteralsDefault.es.noColumns,
        modalTableNoData: thfTableLiteralsDefault.es.noData,
        modalTableLoadingData: thfTableLiteralsDefault.es.loadingData,
        modalTableLoadMoreData: thfTableLiteralsDefault.es.loadMoreData
    })),
    pt: (/** @type {?} */ ({
        modalPrimaryActionLabel: 'Selecionar',
        modalSecondaryActionLabel: 'Cancelar',
        modalPlaceholder: 'Pesquisar',
        modalTitle: 'Selecione um registro',
        modalTableNoColumns: thfTableLiteralsDefault.pt.noColumns,
        modalTableNoData: thfTableLiteralsDefault.pt.noData,
        modalTableLoadingData: thfTableLiteralsDefault.pt.loadingData,
        modalTableLoadMoreData: thfTableLiteralsDefault.pt.loadMoreData
    }))
};
/**
 * \@docsPrivate
 *
 * Classe base do componente Thf Lookup Modal.
 * @abstract
 */
class ThfLookupModalBaseComponent {
    constructor() {
        this.hasNext = true;
        this.isLoading = false;
        this.page = 1;
        this.pageSize = 10;
        this.primaryAction = {
            action: (/**
             * @return {?}
             */
            () => {
                this.items.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                element => {
                    if (element['$selected']) {
                        this.model.emit(element);
                        this.thfModal.close();
                    }
                }));
            }),
            label: this.literals.modalPrimaryActionLabel
        };
        this.searchValue = '';
        this.secondaryAction = {
            action: (/**
             * @return {?}
             */
            () => {
                this.model.emit(null);
                this.thfModal.close();
            }),
            label: this.literals.modalSecondaryActionLabel
        };
        /**
         * Evento utilizado ao selecionar um registro da tabela.
         */
        this.model = new EventEmitter();
    }
    /**
     * Objeto com as literais usadas no `thf-lookup-modal`.
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfLookupLiteralsDefault[thfLocaleDefault], thfLookupLiteralsDefault[browserLanguage()], value);
            if (value.modalTitle) {
                this.title = this.literals.modalTitle;
            }
        }
        else {
            this._literals = thfLookupLiteralsDefault[browserLanguage()];
        }
        this.primaryAction.label = this.literals.modalPrimaryActionLabel;
        this.secondaryAction.label = this.literals.modalSecondaryActionLabel;
        this.setTableLiterals();
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfLookupLiteralsDefault[browserLanguage()];
    }
    /**
     * Título da modal.
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this._title = isTypeof(value, 'string') ? value : this.literals.modalTitle;
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.filterSubscription) {
            this.filterSubscription.unsubscribe();
        }
        if (this.searchSubscription) {
            this.searchSubscription.unsubscribe();
        }
        if (this.showMoreSubscription) {
            this.showMoreSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initializeData();
        this.setTableLiterals();
    }
    /**
     * @return {?}
     */
    search() {
        this.page = 1;
        if (this.searchValue) {
            this.isLoading = true;
            this.searchSubscription = this.getFilteredData(this.searchValue).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                this.items = data.items;
                this.hasNext = data.hasNext;
                this.isLoading = false;
            }));
        }
        else {
            this.initializeData();
        }
    }
    /**
     * @return {?}
     */
    showMoreEvent() {
        this.page++;
        this.isLoading = true;
        this.showMoreSubscription = this.getFilteredData(this.searchValue).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            data.items.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                this.items.push(item);
            }));
            this.hasNext = data.hasNext;
            this.isLoading = false;
        }));
    }
    /**
     * @private
     * @param {?} searchValue
     * @return {?}
     */
    getFilteredData(searchValue) {
        return this.filterService.getFilteredData(searchValue, this.page, this.pageSize, this.filterParams);
    }
    /**
     * @private
     * @return {?}
     */
    initializeData() {
        this.isLoading = true;
        this.filterSubscription = this.getFilteredData('').subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.items = data.items;
            this.hasNext = data.hasNext;
            this.isLoading = false;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    setTableLiterals() {
        this.tableLiterals = {
            'noColumns': this.literals.modalTableNoColumns,
            'noData': this.literals.modalTableNoData,
            'loadingData': this.literals.modalTableLoadingData,
            'loadMoreData': this.literals.modalTableLoadMoreData,
        };
    }
}
ThfLookupModalBaseComponent.propDecorators = {
    thfModal: [{ type: ViewChild, args: [ThfModalComponent, { static: true },] }],
    columns: [{ type: Input, args: ['t-columns',] }],
    items: [{ type: Input, args: ['t-items',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    title: [{ type: Input, args: ['t-title',] }],
    filterService: [{ type: Input, args: ['t-filter-service',] }],
    filterParams: [{ type: Input, args: ['t-filter-params',] }],
    model: [{ type: Output, args: ['t-change-model',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfLookupModalBaseComponent
 */
class ThfLookupModalComponent extends ThfLookupModalBaseComponent {
    constructor() {
        super(...arguments);
        this.keyUpObservable = null;
        this.containerHeight = 375;
        this.tableHeight = 370;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.initializeEventInput();
        this.setTableHeight();
    }
    /**
     * @return {?}
     */
    initializeEventInput() {
        this.keyUpObservable = fromEvent(this.inputSearchEl.nativeElement, 'keyup')
            .pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.validateEnterPressed(e))), debounceTime(400));
        this.keyUpObservable.subscribe((/**
         * @return {?}
         */
        () => {
            this.search();
        }));
    }
    /**
     * @return {?}
     */
    openModal() {
        this.thfModal.open();
    }
    /**
     * @private
     * @return {?}
     */
    setTableHeight() {
        if (window.innerHeight < 615) {
            this.tableHeight -= 50;
            this.containerHeight -= 50;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    validateEnterPressed(e) {
        return e.keyCode === 13;
    }
}
ThfLookupModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-lookup-modal',
                template: "<thf-modal\n  t-click-out=\"false\"\n  t-hide-close=\"false\"\n  t-size=\"lg\"\n  [t-primary-action]=\"primaryAction\"\n  [t-secondary-action]=\"secondaryAction\"\n  [t-title]=\"title\">\n\n  <thf-field-container\n    class=\"thf-lookup-header thf-md-6 thf-pull-right\"\n    [t-optional]=\"false\">\n\n    <div class=\"thf-field-container-content\">\n      <input #inpsearch\n        class=\"thf-input thf-input-icon-right\"\n        name=\"contentSearch\"\n        [(ngModel)]=\"searchValue\"\n        [placeholder]=\"literals.modalPlaceholder\"\n        type=\"text\">\n\n      <div class=\"thf-field-icon-container-right\">\n        <span #iconLookup\n          class=\"thf-icon thf-field-icon thf-icon-search\"\n          (click)=\"search()\">\n        </span>\n      </div>\n    </div>\n\n  </thf-field-container>\n\n  <div class=\"thf-row thf-lookup-container-table\" [style.height.px]=\"containerHeight\">\n\n    <thf-table\n      class=\"thf-md-12\"\n      t-checkbox=\"true\"\n      t-hide-detail=\"true\"\n      t-single-select=\"true\"\n      t-sort=\"true\"\n      [t-columns]=\"columns\"\n      [t-height]=\"tableHeight\"\n      [t-items]=\"items\"\n      [t-literals]=\"tableLiterals\"\n      [t-loading]=\"isLoading\"\n      [t-show-more-disabled]=\"!hasNext\"\n      (t-show-more)=\"showMoreEvent()\">\n    </thf-table>\n\n  </div>\n\n</thf-modal>\n"
            }] }
];
ThfLookupModalComponent.propDecorators = {
    inputSearchEl: [{ type: ViewChild, args: ['inpsearch', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * Serviço responsável por controlar a abertura do componente Thf Lookup Modal.
 */
class ThfLookupModalService {
    /**
     * @param {?} thfComponentInjector
     */
    constructor(thfComponentInjector) {
        this.thfComponentInjector = thfComponentInjector;
        this.componentRef = null;
        this.selectValueEvent = new EventEmitter();
    }
    /**
     * Método responsável por abrir a modal de busca das informações.
     *
     * @param {?} params
     * @return {?}
     */
    openModal(params) {
        const { service, columns, filterParams, title, literals } = params;
        this.componentRef = this.thfComponentInjector.createComponentInApplication(ThfLookupModalComponent);
        this.componentRef.instance.title = title;
        this.componentRef.instance.columns = columns;
        this.componentRef.instance.filterService = service;
        this.componentRef.instance.filterParams = filterParams;
        this.componentRef.instance.literals = literals;
        this.componentRef.instance.model.subscribe((/**
         * @param {?} $event
         * @return {?}
         */
        $event => {
            this.selectValue($event);
        }));
        this.componentRef.changeDetectorRef.detectChanges();
        this.componentRef.instance.openModal();
    }
    // Este metodo é chamado quando é selecionado um item na lookup modal.
    /**
     * @param {?} value
     * @return {?}
     */
    selectValue(value) {
        if (value) {
            this.selectValueEvent.emit(value);
        }
        this.componentRef.destroy();
    }
}
ThfLookupModalService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfLookupModalService.ctorParameters = () => [
    { type: ThfComponentInjectorService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfLookupBaseComponent
 *
 * \@description
 *
 * Quando existe muitos dados o thf-lookup por padrão traz apenas 10 itens na tabela e os demais são carregados por demanda através do
 * botão 'Carregar mais resultados'. Para que funcione corretamente, é importante que o serviço siga o
 * [Guia de implementação das APIs TOTVS](http://tdn.totvs.com/pages/releaseview.action?pageId=271660444).
 *
 * Importante:
 *
 * - Caso o thf-lookup contenha o [(ngModel)] sem o atributo name, ocorrerá um erro de angular.
 * Então será necessário informar o atributo name ou o atributo [ngModelOptions]="{standalone: true}".
 * ```
 * <thf-lookup
 *   [(ngModel)]="pessoa.nome"
 *   [ngModelOptions]="{standalone: true}">
 * </thf-lookup>
 * ```
 *
 * \@example
 *
 * <example name="thf-lookup-basic" title="Totvs Lookup Basic">
 *  <file name="sample-thf-lookup-basic/sample-thf-lookup-basic.component.html"> </file>
 *  <file name="sample-thf-lookup-basic/sample-thf-lookup-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-lookup-labs" title="Totvs Lookup Labs">
 *  <file name="sample-thf-lookup-labs/sample-thf-lookup-labs.component.html"> </file>
 *  <file name="sample-thf-lookup-labs/sample-thf-lookup-labs.component.ts"> </file>
 *  <file name="sample-thf-lookup.service.ts"> </file>
 * </example>
 *
 * <example name="thf-lookup-hero" title="Totvs Lookup - Hero">
 *  <file name="sample-thf-lookup-hero/sample-thf-lookup-hero.component.html"> </file>
 *  <file name="sample-thf-lookup-hero/sample-thf-lookup-hero.component.ts"> </file>
 *  <file name="sample-thf-lookup.service.ts"> </file>
 * </example>
 *
 * <example name="thf-lookup-hero-reactive-form" title="Totvs Lookup - Hero Reactive Form">
 *  <file name="sample-thf-lookup-hero-reactive-form/sample-thf-lookup-hero-reactive-form.component.html"> </file>
 *  <file name="sample-thf-lookup-hero-reactive-form/sample-thf-lookup-hero-reactive-form.component.ts"> </file>
 *  <file name="sample-thf-lookup.service.ts"> </file>
 * </example>
 *
 * <example name="thf-lookup-sw-films" title="Totvs Lookup - Star Wars films">
 *  <file name="sample-thf-lookup-sw-films/sample-thf-lookup-sw-films.component.html"> </file>
 *  <file name="sample-thf-lookup-sw-films/sample-thf-lookup-sw-films.component.ts"> </file>
 *  <file name="sample-thf-lookup-sw-films/sample-thf-lookup-sw-films.service.ts"> </file>
 * </example>
 */
class ThfLookupComponent extends ThfLookupBaseComponent {
    /**
     * @param {?} thfLookupFilterService
     * @param {?} thfLookupModalService
     */
    constructor(thfLookupFilterService, thfLookupModalService) {
        super(thfLookupFilterService);
        this.thfLookupModalService = thfLookupModalService;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.modalSubscription) {
            this.modalSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    openLookup() {
        if (this.isAllowedOpenModal()) {
            const { service, columns, filterParams, literals } = this;
            this.thfLookupModalService.openModal({ service, columns, filterParams, title: this.label, literals });
            if (!this.modalSubscription) {
                this.modalSubscription = this.thfLookupModalService.selectValueEvent.subscribe((/**
                 * @param {?} element
                 * @return {?}
                 */
                element => {
                    this.selectModel(element);
                }));
            }
        }
    }
    /**
     * @param {?} value
     * @param {?} object
     * @return {?}
     */
    setViewValue(value, object) {
        if (this.fieldFormat) {
            this.setInputValueWithFieldFormat(object);
        }
        else {
            this.inputEl.nativeElement.value = this.valueToModel ? value : '';
        }
    }
    /**
     * @return {?}
     */
    getViewValue() {
        return this.inputEl.nativeElement.value;
    }
    /**
     * @return {?}
     */
    searchEvent() {
        /** @type {?} */
        const value = this.getViewValue();
        if (this.oldValue !== value) {
            this.searchById(value);
        }
    }
    /**
     * @private
     * @return {?}
     */
    isAllowedOpenModal() {
        if (!this.service) {
            console.warn('No service informed');
        }
        return !!(this.service && !this.disabled);
    }
    /**
     * @private
     * @param {?} objectSelected
     * @return {?}
     */
    setInputValueWithFieldFormat(objectSelected) {
        /** @type {?} */
        const isEmpty = Object.keys(objectSelected).length === 0;
        /** @type {?} */
        const fieldFormated = this.fieldFormat(objectSelected);
        this.oldValue = isEmpty ? '' : fieldFormated;
        this.inputEl.nativeElement.value = isEmpty ? '' : fieldFormated;
    }
}
ThfLookupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-lookup',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <input #inp\n      class=\"thf-input thf-input-icon-right\"\n      type=\"text\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [required]=\"required\"\n      (blur)=\"searchEvent()\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <span tabindex=\"1\" #iconLookup (click)=\"openLookup()\" (focus)=\"inp.focus()\" class=\"thf-icon thf-field-icon thf-icon-search\"\n        [class.thf-field-icon-disabled]=\"disabled\"\n        [class.thf-field-icon]=\"!disabled\">\n      </span>\n    </div>\n  </div>\n\n  <thf-field-container-bottom></thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    ThfLookupFilterService,
                    ThfLookupModalService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfLookupComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfLookupComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfLookupComponent.ctorParameters = () => [
    { type: ThfLookupFilterService },
    { type: ThfLookupModalService }
];
ThfLookupComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['inp', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente de pesquisa que será criado dentro do dropdown do `thf-multiselect`.
 */
class ThfMultiselectSearchComponent {
    constructor() {
        /**
         * Evento que será disparado a cada tecla digitada no campo de busca.
         */
        this.change = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Placeholder do campo de pesquisa.
     *
     * > Caso o mesmo não seja informado, o valor padrão será traduzido com base no idioma do navegador (pt, es e en).
     *
     * \@default `Buscar`
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder && isTypeof(placeholder, 'string') ? placeholder : this.literals.placeholderSearch;
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.literals.placeholderSearch;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        this.change.emit({ event: event, value: this.inputElement.nativeElement.value });
    }
    /**
     * @return {?}
     */
    setFocus() {
        this.inputElement.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    clean() {
        this.inputElement.nativeElement.value = '';
    }
}
ThfMultiselectSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-multiselect-search',
                template: "<div class=\"thf-field-container-content thf-multiselect-container-search\">\n\n  <div class=\"thf-field-icon-container-left\">\n    <span class=\"thf-icon thf-icon-search thf-field-icon\"></span>\n  </div>\n\n  <input #inputElement\n    class=\"thf-input thf-input-icon-left\"\n    type=\"text\"\n    [placeholder]=\"placeholder\"\n    (keyup)=\"onChange($event)\">\n\n</div>\n"
            }] }
];
ThfMultiselectSearchComponent.propDecorators = {
    literals: [{ type: Input, args: ['t-literals',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    change: [{ type: Output, args: ['t-change',] }],
    inputElement: [{ type: ViewChild, args: ['inputElement', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que construíra o dropdown, contendo o campo de pesquisa e os itens para seleção.
 */
class ThfMultiselectDropdownComponent {
    constructor() {
        this.scrollTop = 0;
        this.show = false;
        this.haveOptions = false;
        /**
         * Propriedade que indica se o campo de pesquisa deverá ser escondido.
         */
        this.hideSearch = false;
        /**
         * Propriedade que recebe a lista de opções selecionadas.
         */
        this.selectedValues = [];
        /**
         * Propriedade que recebe a lista de opções que deverão ser criadas no dropdown.
         */
        this.options = [];
        /**
         * Evento disparado a cada tecla digitada na pesquisa.
         */
        this.changeSearch = new EventEmitter();
        /**
         * Evento disparado a cada alteração na lista das opções selecionadas.
         */
        this.change = new EventEmitter();
        /**
         * Evento disparado quando for detectada uma ação que necessite fechar o dropdown.
         * Por exemplo, no caso de ser teclado TAB dentro do dropdown, então é disparado este evento
         * para notificar o componente principal que deve fechar o dropdown.
         */
        this.closeDropdown = new EventEmitter();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    scrollTo(index) {
        this.scrollTop = (index <= 2) ? 0 : (index * 44) - 88;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    isSelectedItem(option) {
        return this.selectedValues.some((/**
         * @param {?} selectedItem
         * @return {?}
         */
        selectedItem => selectedItem === option.value));
    }
    /**
     * @param {?} check
     * @param {?} option
     * @return {?}
     */
    clickItem(check, option) {
        this.updateSelectedValues(check, option);
        if (!this.hideSearch) {
            this.searchElement.setFocus();
        }
    }
    /**
     * @param {?} checked
     * @param {?} option
     * @return {?}
     */
    updateSelectedValues(checked, option) {
        if (checked) {
            this.selectedValues.push(option.value);
        }
        else {
            /** @type {?} */
            const indexSelectedValues = this.selectedValues.indexOf(option.value);
            this.selectedValues.splice(indexSelectedValues, 1);
        }
        this.change.emit(this.selectedValues);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    callChangeSearch(event) {
        this.changeSearch.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        if (event.keyCode === 9) {
            this.closeDropdown.emit();
        }
    }
    /**
     * @param {?} toOpen
     * @return {?}
     */
    controlVisibility(toOpen) {
        this.show = toOpen;
        this.checkInitialOptions();
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (toOpen && this.searchElement && !this.hideSearch) {
                this.searchElement.setFocus();
                this.searchElement.clean();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    checkInitialOptions() {
        if (this.options.length) {
            this.haveOptions = true;
        }
    }
}
ThfMultiselectDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-multiselect-dropdown',
                template: "<div #container class=\"thf-multiselect-container\" [hidden]=\"!show\">\n\n  <thf-multiselect-search #searchElement\n    *ngIf=\"!hideSearch && haveOptions\"\n    [t-literals]=\"literals\"\n    [t-placeholder]=\"placeholderSearch\"\n    (t-change)=\"callChangeSearch($event)\">\n  </thf-multiselect-search>\n\n  <ul class=\"thf-multiselect-items-container\" [scrollTop]=\"scrollTop\" #ulElement>\n    <div *ngIf=\"!options.length\" class=\"thf-multiselect-container-no-data thf-text-center\">\n      <span> {{ literals.noData }}</span>\n    </div>\n\n    <thf-multiselect-item *ngFor=\"let option of options\"\n      [t-option]=\"option\"\n      [t-selected]=\"isSelectedItem(option)\"\n      (t-change)=\"clickItem($event, option)\">\n    </thf-multiselect-item>\n  </ul>\n</div>\n"
            }] }
];
ThfMultiselectDropdownComponent.propDecorators = {
    hideSearch: [{ type: Input, args: ['t-hide-search',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    placeholderSearch: [{ type: Input, args: ['t-placeholder-search',] }],
    selectedValues: [{ type: Input, args: ['t-selected-values',] }],
    options: [{ type: Input, args: ['t-options',] }],
    changeSearch: [{ type: Output, args: ['t-change-search',] }],
    change: [{ type: Output, args: ['t-change',] }],
    closeDropdown: [{ type: Output, args: ['t-close-dropdown',] }],
    container: [{ type: ViewChild, args: ['container', { read: ElementRef, static: true },] }],
    ulElement: [{ type: ViewChild, args: ['ulElement', { read: ElementRef, static: true },] }],
    searchElement: [{ type: ViewChild, args: ['searchElement', { static: false },] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfMultiselectFilterMode = {
    /** Verifica se o texto *inicia* com o valor pesquisado. */
    startsWith: 0,
    /** Verifica se o texto *contém* o valor pesquisado. */
    contains: 1,
    /** Verifica se o texto *finaliza* com o valor pesquisado. */
    endsWith: 2,
};
ThfMultiselectFilterMode[ThfMultiselectFilterMode.startsWith] = 'startsWith';
ThfMultiselectFilterMode[ThfMultiselectFilterMode.contains] = 'contains';
ThfMultiselectFilterMode[ThfMultiselectFilterMode.endsWith] = 'endsWith';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfMultiselectLiteralsDefault = {
    en: (/** @type {?} */ ({
        noData: 'No data found',
        placeholderSearch: 'Search'
    })),
    es: (/** @type {?} */ ({
        noData: 'Datos no encontrados',
        placeholderSearch: 'Busca'
    })),
    pt: (/** @type {?} */ ({
        noData: 'Nenhum dado encontrado',
        placeholderSearch: 'Buscar'
    }))
};
/**
 * \@description
 *
 * O thf-multiselect é um componente de múltipla seleção.
 * Este componente é recomendado para dar ao usuário a opção de selecionar vários itens em uma lista.
 *
 * Quando a lista possuir poucos itens, deve-se dar preferência para o uso do thf-checkbox-group, por ser mais simples
 * e mais rápido para a seleção do usuário.
 *
 * Este componente também não deve ser utilizado em casos onde a seleção seja única. Nesses casos, deve-se utilizar o
 * thf-select, thf-combo ou thf-radio-group.
 * @abstract
 */
class ThfMultiselectBaseComponent {
    constructor() {
        this._disabled = false;
        this._filterMode = ThfMultiselectFilterMode.startsWith;
        this._focus = false;
        this._hideSearch = false;
        this._required = false;
        this._sort = false;
        this.readyToValidation = false;
        this.selectedOptions = [];
        this.visibleOptionsDropdown = [];
        this.visibleDisclaimers = [];
        /**
         * Mensagem apresentada enquanto o campo estiver vazio.
         */
        this.placeholder = '';
        /**
         * \@description
         *
         * Placeholder do campo de pesquisa.
         *
         * > Caso o mesmo não seja informado, o valor padrão será traduzido com base no idioma do navegador (pt, es e en).
         *
         * \@default `Buscar`
         */
        this.placeholderSearch = '';
        /**
         * Pode ser informada uma função que será disparada quando houver alterações no ngModel.
         */
        this.change = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-multiselect`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfMultiselectLiterals = {
     *    noData: 'Nenhum dado encontrado',
     *    placeholderSearch: 'Buscar'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfMultiselectLiterals = {
     *    noData: 'Sem dados'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
     *
     * ```
     * <thf-multiselect
     *   [t-literals]="customLiterals">
     * </thf-thf-multiselect>
     * ```
     *
     *  > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfMultiselectLiteralsDefault[thfLocaleDefault], thfMultiselectLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfMultiselectLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfMultiselectLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório. Esta propriedade é desconsiderada quando o campo está desabilitado (t-disabled).
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = (/** @type {?} */ (required)) === '' ? true : convertToBoolean(required);
        this.updateModelToValidate();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será desabilitado.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = (/** @type {?} */ (disabled)) === '' ? true : convertToBoolean(disabled);
        this.updateModelToValidate();
        this.updateVisibleItems();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Esconde o campo de pesquisa existente dentro do dropdown do thf-multiselect.
     *
     * \@default `false`
     * @param {?} hideSearch
     * @return {?}
     */
    set hideSearch(hideSearch) {
        this._hideSearch = (/** @type {?} */ (hideSearch)) === '' ? true : convertToBoolean(hideSearch);
    }
    /**
     * @return {?}
     */
    get hideSearch() {
        return this._hideSearch;
    }
    /**
     * \@description
     *
     * Nesta propriedade deve ser definida uma lista de objetos que implementam a interface ThfMultiselectOption.
     * Esta lista deve conter os valores e os labels que serão apresentados na tela.
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        this._options = options;
        this.validAndSortOptions();
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que a lista definida na propriedade t-options será ordenada pelo label antes de ser apresentada no
     * dropdown.
     *
     * \@default `false`
     * @param {?} sort
     * @return {?}
     */
    set sort(sort) {
        this._sort = (/** @type {?} */ (sort)) === '' ? true : convertToBoolean(sort);
        this.validAndSortOptions();
    }
    /**
     * @return {?}
     */
    get sort() {
        return this._sort;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo iniciará com foco.
     *
     * \@default `false`
     * @param {?} focus
     * @return {?}
     */
    set focus(focus) {
        this._focus = (/** @type {?} */ (focus)) === '' ? true : convertToBoolean(focus);
    }
    /**
     * @return {?}
     */
    get focus() {
        return this._focus;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define o modo de pesquisa utilizado no campo de busca, quando habilitado.
     * Valores definidos no enum: ThfMultiselectFilterMode
     *
     * \@default `startsWith`
     * @param {?} filterMode
     * @return {?}
     */
    set filterMode(filterMode) {
        this._filterMode = (filterMode in ThfMultiselectFilterMode) ? filterMode : ThfMultiselectFilterMode.startsWith;
        switch (this._filterMode.toString()) {
            case 'startsWith':
                this._filterMode = ThfMultiselectFilterMode.startsWith;
                break;
            case 'contains':
                this._filterMode = ThfMultiselectFilterMode.contains;
                break;
            case 'endsWith':
                this._filterMode = ThfMultiselectFilterMode.endsWith;
                break;
        }
    }
    /**
     * @return {?}
     */
    get filterMode() {
        return this._filterMode;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateList(this.options);
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        // Seta esta variável para indicar que a tela já foi carregada e podem ser aplicadas as validações.
        // A partir desse momento, toda vez que uma propriedade que interfere na validação, for alterada, o model será atualizado
        // para que o campo seja validado novamente.
        this.readyToValidation = true;
    }
    /**
     * @return {?}
     */
    validAndSortOptions() {
        if (this.options && this.options.length) {
            removeUndefinedAndNullOptions(this.options);
            removeDuplicatedOptions(this.options);
            this.setUndefinedLabels(this.options);
            if (this.sort) {
                sortOptionsByProperty(this.options, 'label');
            }
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    setUndefinedLabels(options) {
        options.forEach((/**
         * @param {?} option
         * @return {?}
         */
        option => {
            if (!option['label']) {
                option.label = option.value;
            }
        }));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    updateList(options) {
        if (options) {
            this.visibleOptionsDropdown = options;
        }
    }
    // Emite a atualização do model caso esta propriedade seja alterada dinamicamente.
    /**
     * @return {?}
     */
    updateModelToValidate() {
        if (this.readyToValidation) {
            // Este timeout é necessário para quando for atualizado o model e uma propriedade do Datepicker ao mesmo tempo.
            // Caso contrário, o writeValue não é disparado, não atualizando o model do componente.
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.callOnChange(this.selectedOptions);
            }));
        }
    }
    /**
     * @param {?} selectedOptions
     * @return {?}
     */
    callOnChange(selectedOptions) {
        if (this.onModelChange) {
            this.onModelChange(this.getValuesFromOptions(selectedOptions));
            this.eventChange(selectedOptions);
        }
    }
    /**
     * @param {?} selectedOptions
     * @return {?}
     */
    eventChange(selectedOptions) {
        if (selectedOptions && this.lastLengthModel !== selectedOptions.length) {
            this.change.emit(selectedOptions);
        }
        this.lastLengthModel = selectedOptions ? selectedOptions.length : null;
    }
    /**
     * @param {?} selectedOptions
     * @return {?}
     */
    getValuesFromOptions(selectedOptions) {
        return selectedOptions && selectedOptions.length ? selectedOptions.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option.value)) : [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getLabelByValue(value) {
        /** @type {?} */
        const index = this.options.findIndex((/**
         * @param {?} option
         * @return {?}
         */
        option => option.value === value));
        return this.options[index].label;
    }
    /**
     * @param {?} selectedValues
     * @return {?}
     */
    changeItems(selectedValues) {
        this.updateSelectedOptions(selectedValues);
        this.callOnChange(this.selectedOptions);
    }
    /**
     * @param {?} search
     * @param {?} options
     * @param {?} filterMode
     * @return {?}
     */
    searchByLabel(search, options, filterMode) {
        if (search && options && options.length) {
            /** @type {?} */
            const newOptions = [];
            options.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => {
                if (option.label && this.compareMethod(search, option, filterMode)) {
                    newOptions.push(option);
                }
            }));
            this.visibleOptionsDropdown = newOptions;
        }
    }
    /**
     * @param {?} search
     * @param {?} option
     * @param {?} filterMode
     * @return {?}
     */
    compareMethod(search, option, filterMode) {
        switch (filterMode) {
            case ThfMultiselectFilterMode.startsWith:
                return this.startsWith(search, option);
            case ThfMultiselectFilterMode.contains:
                return this.contains(search, option);
            case ThfMultiselectFilterMode.endsWith:
                return this.endsWith(search, option);
        }
    }
    /**
     * @param {?} search
     * @param {?} option
     * @return {?}
     */
    startsWith(search, option) {
        return option.label.toLowerCase().startsWith(search.toLowerCase());
    }
    /**
     * @param {?} search
     * @param {?} option
     * @return {?}
     */
    contains(search, option) {
        return option.label.toLowerCase().indexOf(search.toLowerCase()) > -1;
    }
    /**
     * @param {?} search
     * @param {?} option
     * @return {?}
     */
    endsWith(search, option) {
        return option.label.toLowerCase().endsWith(search.toLowerCase());
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        if (requiredFailed(this.required, this.disabled, c.value)) {
            return { required: {
                    valid: false,
                } };
        }
        return null;
    }
    /**
     * @param {?} values
     * @return {?}
     */
    updateSelectedOptions(values) {
        this.selectedOptions = [];
        values.forEach((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.options.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => {
                if (option.value === value) {
                    this.selectedOptions.push(option);
                }
            }));
        }));
        this.updateVisibleItems();
    }
    /**
     * @param {?} values
     * @return {?}
     */
    writeValue(values) {
        if (!values) {
            values = [];
            this.callOnChange([]);
        }
        // Validar se todos os items existem entre os options, senão atualizar o model
        this.updateSelectedOptions(values);
        if (this.selectedOptions.length < values.length) {
            this.callOnChange(this.selectedOptions);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
ThfMultiselectBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    placeholderSearch: [{ type: Input, args: ['t-placeholder-search',] }],
    name: [{ type: Input, args: ['name',] }],
    required: [{ type: Input, args: ['t-required',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    hideSearch: [{ type: Input, args: ['t-hide-search',] }],
    options: [{ type: Input, args: ['t-options',] }],
    sort: [{ type: Input, args: ['t-sort',] }],
    focus: [{ type: Input, args: ['t-focus',] }],
    filterMode: [{ type: Input, args: ['t-filter-mode',] }],
    change: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfMultiselectContainerOffset = 8;
/** @type {?} */
const thfMultiselectContainerPositionDefault = 'bottom';
/**
 * \@docsExtends ThfMultiselectBaseComponent
 *
 * \@example
 *
 * <example name="thf-multiselect-basic" title="Totvs Multiselect Basic">
 *   <file name="sample-thf-multiselect-basic/sample-thf-multiselect-basic.component.html"> </file>
 *   <file name="sample-thf-multiselect-basic/sample-thf-multiselect-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-multiselect-labs" title="Totvs Multiselect Labs">
 *   <file name="sample-thf-multiselect-labs/sample-thf-multiselect-labs.component.html"> </file>
 *   <file name="sample-thf-multiselect-labs/sample-thf-multiselect-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-multiselect-vacation" title="Totvs Multiselect - Vacation">
 *   <file name="sample-thf-multiselect-vacation/sample-thf-multiselect-vacation.component.html"> </file>
 *   <file name="sample-thf-multiselect-vacation/sample-thf-multiselect-vacation.component.ts"> </file>
 * </example>
 *
 * <example name="thf-multiselect-vacation-reactive-form" title="Totvs Multiselect - Vacation Reactive Form">
 *   <file name="sample-thf-multiselect-vacation-reactive-form/sample-thf-multiselect-vacation-reactive-form.component.html"> </file>
 *   <file name="sample-thf-multiselect-vacation-reactive-form/sample-thf-multiselect-vacation-reactive-form.component.ts"> </file>
 * </example>
 */
class ThfMultiselectComponent extends ThfMultiselectBaseComponent {
    /**
     * @param {?} renderer
     * @param {?} changeDetector
     * @param {?} controlPosition
     * @param {?} el
     */
    constructor(renderer, changeDetector, controlPosition, el) {
        super();
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        this.controlPosition = controlPosition;
        this.el = el;
        this.disclaimerOffset = 0;
        this.dropdownIcon = 'thf-icon-arrow-down';
        this.dropdownOpen = false;
        this.initialized = false;
        this.visibleElement = false;
        this.isCalculateVisibleItems = true;
        this.onScroll = (/**
         * @return {?}
         */
        () => {
            this.adjustContainerPosition();
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.focus) {
            this.inputElement.nativeElement.focus();
        }
        this.initialized = true;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const inputWidth = this.inputElement.nativeElement.offsetWidth;
        // Permite que os disclaimers sejam calculados na primeira vez que o componente torna-se visível,
        // evitando com isso, problemas com Tabs ou Divs que iniciem escondidas.
        if ((inputWidth && !this.visibleElement && this.initialized) || (inputWidth && this.isCalculateVisibleItems)) {
            this.debounceResize();
            this.visibleElement = true;
            return;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @return {?}
     */
    getInputWidth() {
        return this.el.nativeElement.querySelector('.thf-input').offsetWidth - 40;
    }
    /**
     * @return {?}
     */
    getDisclaimersWidth() {
        /** @type {?} */
        const disclaimers = this.el.nativeElement.querySelectorAll('thf-disclaimer');
        return Array.from(disclaimers).map((/**
         * @param {?} disclaimer
         * @return {?}
         */
        disclaimer => disclaimer['offsetWidth']));
    }
    /**
     * @return {?}
     */
    calculateVisibleItems() {
        /** @type {?} */
        const disclaimersWidth = this.getDisclaimersWidth();
        /** @type {?} */
        const inputWidth = this.getInputWidth();
        /** @type {?} */
        const extraDisclaimerSize = 38;
        /** @type {?} */
        const disclaimersVisible = disclaimersWidth[0];
        this.visibleDisclaimers = [];
        if (inputWidth > 0) {
            /** @type {?} */
            let sum = 0;
            /** @type {?} */
            let i = 0;
            for (i = 0; i < this.selectedOptions.length; i++) {
                sum += disclaimersWidth[i];
                this.visibleDisclaimers.push(this.selectedOptions[i]);
                if (sum > inputWidth) {
                    sum -= disclaimersWidth[i];
                    this.isCalculateVisibleItems = false;
                    break;
                }
            }
            if (disclaimersVisible || !this.selectedOptions.length) {
                if (i === this.selectedOptions.length) {
                    this.isCalculateVisibleItems = false;
                    return;
                }
                if (sum + extraDisclaimerSize > inputWidth) {
                    this.visibleDisclaimers.splice(-2, 2);
                    /** @type {?} */
                    const label = '+' + (this.selectedOptions.length + 1 - i).toString();
                    this.visibleDisclaimers.push({ value: '', label: label });
                }
                else {
                    this.visibleDisclaimers.splice(-1, 1);
                    /** @type {?} */
                    const label = '+' + (this.selectedOptions.length - i).toString();
                    this.visibleDisclaimers.push({ value: '', label: label });
                }
            }
        }
    }
    /**
     * @return {?}
     */
    updateVisibleItems() {
        this.visibleDisclaimers = [].concat(this.selectedOptions);
        this.debounceResize();
        // quando estiver dentro de modal
        if (!this.inputElement.nativeElement.offsetWidth) {
            this.isCalculateVisibleItems = true;
        }
    }
    /**
     * @return {?}
     */
    debounceResize() {
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout((/**
         * @return {?}
         */
        () => {
            this.calculateVisibleItems();
        }), 200);
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onKeyDown(event) {
        if (event.keyCode === ThfKeyCodeEnum.arrowUp || event.keyCode === ThfKeyCodeEnum.arrowDown) {
            event.preventDefault();
            this.controlDropdownVisibility(true);
            return;
        }
        if (event.keyCode === ThfKeyCodeEnum.tab) {
            this.controlDropdownVisibility(false);
            return;
        }
    }
    /**
     * @return {?}
     */
    toggleDropdownVisibility() {
        if (this.disabled) {
            return;
        }
        this.controlDropdownVisibility(!this.dropdownOpen);
    }
    /**
     * @param {?} toOpen
     * @return {?}
     */
    openDropdown(toOpen) {
        if (toOpen && !this.disabled) {
            this.controlDropdownVisibility(true);
        }
    }
    /**
     * @param {?} toOpen
     * @return {?}
     */
    controlDropdownVisibility(toOpen) {
        toOpen ? this.open() : this.close();
    }
    /**
     * @return {?}
     */
    scrollToSelectedOptions() {
        if (this.selectedOptions && this.selectedOptions.length) {
            /** @type {?} */
            const index = this.options.findIndex((/**
             * @param {?} option
             * @return {?}
             */
            option => option.value === this.selectedOptions[0].value));
            this.dropdown.scrollTo(index);
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    setVisibleOptionsDropdown(options) {
        this.visibleOptionsDropdown = options;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changeSearch(event) {
        (event && event.value) ? this.searchByLabel(event.value, this.options, this.filterMode) : this.setVisibleOptionsDropdown(this.options);
        // timeout necessário para reposicionar corretamente quando dropdown estiver pra cima do input e realizar busca no input
        setTimeout((/**
         * @return {?}
         */
        () => this.adjustContainerPosition()));
    }
    /**
     * @return {?}
     */
    getPlaceholder() {
        return (this.placeholder && !this.visibleDisclaimers.length) ? this.placeholder : '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    closeDisclaimer(value) {
        /** @type {?} */
        const index = this.selectedOptions.findIndex((/**
         * @param {?} option
         * @return {?}
         */
        option => option.value === value));
        this.selectedOptions.splice(index, 1);
        this.updateVisibleItems();
        this.callOnChange(this.selectedOptions);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    wasClickedOnToggle(event) {
        if (!this.inputElement.nativeElement.contains(event.target) &&
            !this.iconElement.nativeElement.contains(event.target) &&
            !this.dropdownElement.nativeElement.contains(event.target) &&
            !this.disclaimerContainerElement.nativeElement.contains(event.target) &&
            this.dropdownOpen) {
            this.controlDropdownVisibility(false);
        }
    }
    /**
     * @private
     * @return {?}
     */
    adjustContainerPosition() {
        this.controlPosition.adjustPosition(thfMultiselectContainerPositionDefault);
    }
    /**
     * @private
     * @return {?}
     */
    close() {
        this.dropdownIcon = 'thf-icon-arrow-down';
        this.dropdownOpen = false;
        this.dropdown.controlVisibility(false);
        this.setVisibleOptionsDropdown(this.options);
        this.removeListeners();
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.clickOutListener = this.renderer.listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.wasClickedOnToggle(event);
        }));
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.updateVisibleItems();
            isMobile() ? this.adjustContainerPosition() : this.close();
        }));
        window.addEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    open() {
        this.dropdownIcon = 'thf-icon-arrow-up';
        this.dropdownOpen = true;
        this.dropdown.controlVisibility(true);
        this.setVisibleOptionsDropdown(this.options);
        this.initializeListeners();
        this.scrollToSelectedOptions();
        this.changeDetector.detectChanges();
        this.setPositionDropdown();
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.clickOutListener) {
            this.clickOutListener();
        }
        if (this.resizeListener) {
            this.resizeListener();
        }
        window.removeEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    setPositionDropdown() {
        this.controlPosition.setElements(this.dropdown.container.nativeElement, thfMultiselectContainerOffset, this.inputElement, ['top', 'bottom'], true);
        this.adjustContainerPosition();
    }
}
ThfMultiselectComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-multiselect',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\"\n    [class.thf-multiselect-show]=\"dropdownOpen\">\n\n    <input #inputElement\n      class=\"thf-input thf-input-icon-right thf-clickable\"\n      readonly\n      type=\"text\"\n      [value]=\"getPlaceholder()\"\n      [disabled]=\"disabled\"\n      (keydown)=\"onKeyDown($event)\"\n      (click)=\"toggleDropdownVisibility()\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <span #iconElement\n        class=\"thf-icon thf-field-icon {{ dropdownIcon }}\"\n        [ngClass]=\"disabled ? 'thf-field-icon-disabled' : ''\"\n        (click)=\"toggleDropdownVisibility()\">\n      </span>\n    </div>\n\n    <div #disclaimerContainer\n      class=\"thf-multiselect-field\"\n      [class.thf-multiselect-field-disabled]=\"disabled\">\n\n      <thf-disclaimer *ngFor=\"let disclaimer of visibleDisclaimers\"\n        [t-label]=\"disclaimer.label\"\n        [t-value]=\"disclaimer.value\"\n        [t-hide-close]=\"disclaimer.value === '' || disabled\"\n        [class.thf-clickable]=\"disclaimer.value === '' && !disabled\"\n        (click)=\"openDropdown(disclaimer.value === '')\"\n        (t-close-action)=\"closeDisclaimer(disclaimer.value)\">\n      </thf-disclaimer>\n    </div>\n  </div>\n\n  <thf-multiselect-dropdown #dropdownElement\n    [t-hide-search]=\"hideSearch\"\n    [t-literals]=\"literals\"\n    [t-options]=\"visibleOptionsDropdown\"\n    [t-selected-values]=\"getValuesFromOptions(selectedOptions)\"\n    [t-placeholder-search]=\"placeholderSearch\"\n    (t-change)=\"changeItems($event)\"\n    (t-change-search)=\"changeSearch($event)\"\n    (t-close-dropdown)=\"controlDropdownVisibility(false)\">\n  </thf-multiselect-dropdown>\n\n  <thf-field-container-bottom></thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    ThfControlPositionService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfMultiselectComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfMultiselectComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfMultiselectComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: ThfControlPositionService },
    { type: ElementRef }
];
ThfMultiselectComponent.propDecorators = {
    dropdownElement: [{ type: ViewChild, args: ['dropdownElement', { read: ElementRef, static: true },] }],
    dropdown: [{ type: ViewChild, args: ['dropdownElement', { static: true },] }],
    disclaimerContainerElement: [{ type: ViewChild, args: ['disclaimerContainer', { read: ElementRef, static: true },] }],
    iconElement: [{ type: ViewChild, args: ['iconElement', { read: ElementRef, static: true },] }],
    inputElement: [{ type: ViewChild, args: ['inputElement', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que constrói cada item no dropdown, contendo o checkbox e o label.
 */
class ThfMultiselectItemComponent {
    constructor() {
        /**
         * Opção que irá gerar o item, implementando a interface ThfMultiselectOption.
         */
        this.option = null;
        /**
         * Esta propriedade indica se o campo está selecionado ou não.
         */
        this.selected = false;
        /**
         * Evento que será disparado toda vez que o usuário marcar ou desmarcar um item.
         */
        this.change = new EventEmitter();
    }
    /**
     * @return {?}
     */
    itemClicked() {
        this.selected = !this.selected;
        this.change.emit(this.selected);
    }
}
ThfMultiselectItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-multiselect-item',
                template: "<li [value]=\"option?.value\"\n  (click)=\"itemClicked()\"\n  [class.thf-multiselect-item-selected]=\"selected\">\n\n  <a class=\"thf-multiselect-item\">\n    <input\n      [checked]=\"selected\"\n      class=\"thf-multiselect-checkbox-input\"\n      [class.thf-multiselect-checkbox-input-checked]=\"selected\"\n      type=\"checkbox\">\n\n    <label class=\"thf-multiselect-checkbox-label thf-clickable\">\n      {{ option?.label }}\n    </label>\n  </a>\n</li>\n"
            }] }
];
ThfMultiselectItemComponent.propDecorators = {
    option: [{ type: Input, args: ['t-option',] }],
    selected: [{ type: Input, args: ['t-selected',] }],
    change: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfRichTextBodyCommands = [
    'bold', 'italic', 'underline', 'justifyleft', 'justifycenter', 'justifyright', 'justifyfull', 'insertUnorderedList'
];
class ThfRichTextBodyComponent {
    constructor() {
        this.commands = new EventEmitter();
        this.value = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.bodyElement.nativeElement.designMode = 'on';
        // timeout necessário para setar o valor vindo do writeValue do componente principal.
        setTimeout((/**
         * @return {?}
         */
        () => { this.updateValueWithModelValue(); }));
    }
    /**
     * @param {?} command
     * @return {?}
     */
    executeCommand(command) {
        this.bodyElement.nativeElement.focus();
        document.execCommand(command, false, null);
        this.updateModel();
        this.value.emit(this.modelValue);
    }
    /**
     * @return {?}
     */
    onClick() {
        this.emitSelectionCommands();
    }
    /**
     * @return {?}
     */
    onKeyUp() {
        // Tratamento necessário para eliminar a tag <br> criada no firefox quando o body for limpo.
        if (!this.bodyElement.nativeElement.innerText.trim() && this.bodyElement.nativeElement.firstChild) {
            this.bodyElement.nativeElement.firstChild.remove();
        }
        this.updateModel();
        this.emitSelectionCommands();
    }
    /**
     * @return {?}
     */
    update() {
        setTimeout((/**
         * @return {?}
         */
        () => { this.updateModel(); }));
        setTimeout((/**
         * @return {?}
         */
        () => { this.onKeyUp(); }));
    }
    /**
     * @private
     * @return {?}
     */
    emitSelectionCommands() {
        /** @type {?} */
        const commands = thfRichTextBodyCommands.filter((/**
         * @param {?} command
         * @return {?}
         */
        command => {
            return document.queryCommandState(command);
        }));
        this.commands.emit(commands);
    }
    /**
     * @private
     * @return {?}
     */
    updateModel() {
        this.modelValue = this.bodyElement.nativeElement.innerHTML;
        this.value.emit(this.modelValue);
    }
    /**
     * @private
     * @return {?}
     */
    updateValueWithModelValue() {
        if (this.modelValue) {
            this.bodyElement.nativeElement.insertAdjacentHTML('afterbegin', this.modelValue);
        }
    }
}
ThfRichTextBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-rich-text-body',
                template: "<div #bodyElement\n  class=\"thf-rich-text-body\"\n  [attr.contenteditable]=\"!readonly\"\n  [attr.data-placeholder]=\"placeholder\"\n  [style.height.px]=\"height\"\n  (click)=\"onClick()\"\n  (cut)=\"update()\"\n  (keyup)=\"onKeyUp()\"\n  (paste)=\"update()\">\n</div>\n"
            }] }
];
ThfRichTextBodyComponent.propDecorators = {
    bodyElement: [{ type: ViewChild, args: ['bodyElement', { static: true },] }],
    height: [{ type: Input, args: ['t-height',] }],
    modelValue: [{ type: Input, args: ['t-model-value',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    commands: [{ type: Output, args: ['t-commands',] }],
    value: [{ type: Output, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-rich-text` é um editor de textos enriquecidos.
 *
 * Para edição de texto simples sem formatação recomenda-se o uso do componente [**thf-textarea**](/documentation/thf-textarea).
 * @abstract
 */
class ThfRichTextBaseComponent {
    constructor() {
        this.onChangeModel = null;
        this.invalid = false;
        // tslint:disable-next-line
        this.onTouched = null;
        /**
         * \@description
         *
         * Mensagem que será apresentada quando a propriedade required estiver habilitada e o campo for limpo após algo ser digitado.
         */
        this.errorMessage = '';
        /**
         * \@description
         *
         * Indica que o campo será obrigatório.
         *
         * \@default `false`
         */
        this.required = false;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a altura da área de edição de texto.
     *
     * > Altura mínima do componente é `94` e a altura máxima é `262`.
     * @param {?} height
     * @return {?}
     */
    set height(height) {
        this._height = height;
    }
    /**
     * @return {?}
     */
    get height() {
        return this._height;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Mensagem que aparecerá enquanto o campo não estiver preenchido.
     *
     * \@default ''
     * @param {?} value
     * @return {?}
     */
    set placeholder(value) {
        this._placeholder = value || '';
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será somente leitura.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * @param {?} required
     * @return {?}
     */
    set setRequired(required) {
        this.required = convertToBoolean(required);
        this.validateModel(this.value);
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangeModel = func;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouched = func;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if (requiredFailed(this.required, false, abstractControl.value)) {
            return { required: {
                    valid: false,
                } };
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    // Executa a função onChange
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    updateModel(value) {
        // Quando o rich-text não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(value);
        }
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    validateModel(value) {
        if (this.validatorChange) {
            this.validatorChange(value);
        }
    }
}
ThfRichTextBaseComponent.propDecorators = {
    errorMessage: [{ type: Input, args: ['t-error-message',] }],
    height: [{ type: Input, args: ['t-height',] }],
    help: [{ type: Input, args: ['t-help',] }],
    label: [{ type: Input, args: ['t-label',] }],
    name: [{ type: Input, args: ['name',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    setRequired: [{ type: Input, args: ['t-required',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfRichTextBaseComponent
 *
 * \@example
 *
 * <example name="thf-rich-text-basic" title="Totvs Rich Text Basic">
 *   <file name="sample-thf-rich-text-basic/sample-thf-rich-text-basic.component.html"> </file>
 *   <file name="sample-thf-rich-text-basic/sample-thf-rich-text-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-rich-text-recipe" title="Totvs Rich Text Recipe">
 *   <file name="sample-thf-rich-text-recipe/sample-thf-rich-text-recipe.component.html"> </file>
 *   <file name="sample-thf-rich-text-recipe/sample-thf-rich-text-recipe.component.ts"> </file>
 * </example>
 */
class ThfRichTextComponent extends ThfRichTextBaseComponent {
    /**
     * @param {?} element
     */
    constructor(element) {
        super();
        this.element = element;
        this.listener = this.validateClassesForRequired.bind(this);
    }
    /**
     * @return {?}
     */
    get errorMsg() {
        return (this.errorMessage !== '' && !this.value && this.required && this.invalid) ? this.errorMessage : '';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Se não tem ngModel ou reactive form adiciona validação com classes css
        if (!this.onChangeModel) {
            this.element.nativeElement.addEventListener('keyup', this.listener);
            this.element.nativeElement.addEventListener('cut', this.listener);
            this.element.nativeElement.addEventListener('paste', this.listener);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (!this.onChangeModel) {
            this.element.nativeElement.removeEventListener('keyup', this.listener);
            this.element.nativeElement.removeEventListener('cut', this.listener);
            this.element.nativeElement.removeEventListener('paste', this.listener);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.value = value;
        this.invalid = !value;
        this.updateModel(this.value);
    }
    /**
     * @private
     * @return {?}
     */
    validateClassesForRequired() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const value = this.value;
            /** @type {?} */
            const element = this.element.nativeElement;
            if (!value && this.required) {
                element.classList.add('ng-invalid');
                element.classList.add('ng-dirty');
            }
            else {
                element.classList.remove('ng-invalid');
            }
        }));
    }
}
ThfRichTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-rich-text',
                template: "<thf-field-container\n[t-help]=\"help\"\n[t-label]=\"label\"\n[t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n\n    <thf-rich-text-body #richTextBody\n      [t-height]=\"height\"\n      [t-model-value]=\"value\"\n      [t-placeholder]=\"placeholder\"\n      [t-readonly]=\"readonly\"\n      (t-commands)=\"richTextToolbar.setButtonsStates($event)\"\n      (t-value)=\"updateValue($event)\">\n    </thf-rich-text-body>\n\n    <thf-rich-text-toolbar #richTextToolbar\n      [t-readonly]=\"readonly\"\n      (t-command)=\"richTextBody.executeCommand($event)\">\n    </thf-rich-text-toolbar>\n\n  </div>\n\n  <thf-field-container-bottom [t-error-pattern]=\"errorMsg\"></thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfRichTextComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfRichTextComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfRichTextComponent.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfRichTextLiteralsDefault = {
    en: {
        bold: 'Bold',
        italic: 'Italic',
        underline: 'Underline',
        left: 'Left',
        center: 'Center',
        right: 'Right',
        justify: 'Justify',
        unorderedList: 'Bulleted list'
    },
    es: {
        bold: 'Negrita',
        italic: 'Cursiva',
        underline: 'Subrayado',
        left: 'Izquierda',
        center: 'Centro',
        right: 'Derecha',
        justify: 'Justificado',
        unorderedList: 'Lista con viñetas'
    },
    pt: {
        bold: 'Negrito',
        italic: 'Itálico',
        underline: 'Sublinhado',
        left: 'Esquerda',
        center: 'Centro',
        right: 'Direita',
        justify: 'Justificado',
        unorderedList: 'Lista com marcadores'
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfRichTextToolbarComponent {
    /**
     * @param {?} languageService
     */
    constructor(languageService) {
        this.languageService = languageService;
        this.literals = Object.assign({}, thfRichTextLiteralsDefault[this.languageService.getShortLanguage()]);
        this.alignButtons = [
            {
                command: 'justifyleft',
                icon: 'thf-icon-align-left',
                tooltip: this.literals.left,
                action: this.emitAlignCommand.bind(this, 'justifyleft'),
                selected: true
            },
            {
                command: 'justifycenter',
                icon: 'thf-icon-align-center',
                tooltip: this.literals.center,
                action: this.emitAlignCommand.bind(this, 'justifycenter')
            },
            {
                command: 'justifyright',
                icon: 'thf-icon-align-right',
                tooltip: this.literals.right,
                action: this.emitAlignCommand.bind(this, 'justifyright')
            },
            {
                command: 'justifyfull',
                icon: 'thf-icon-align-justify',
                tooltip: this.literals.justify,
                action: this.emitAlignCommand.bind(this, 'justifyfull')
            }
        ];
        this.formatButtons = [
            {
                command: 'bold',
                icon: 'thf-icon-text-bold',
                tooltip: this.literals.bold,
                action: this.emitCommand.bind(this, 'bold')
            },
            {
                command: 'italic',
                icon: 'thf-icon-text-italic',
                tooltip: this.literals.italic,
                action: this.emitCommand.bind(this, 'italic')
            },
            {
                command: 'underline',
                icon: 'thf-icon-text-underline',
                tooltip: this.literals.underline,
                action: this.emitCommand.bind(this, 'underline')
            }
        ];
        this.listButtons = [
            {
                command: 'insertUnorderedList',
                icon: 'thf-icon-list',
                tooltip: this.literals.unorderedList,
                action: this.emitCommand.bind(this, 'insertUnorderedList')
            }
        ];
        this.command = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = value;
        this.toggleDisableButtons(this._readonly);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.removeButtonFocus();
    }
    /**
     * @param {?} commands
     * @return {?}
     */
    setButtonsStates(commands) {
        if (!this.readonly) {
            this.alignButtons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => { button.selected = commands.includes(button.command); }));
            this.formatButtons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => { button.selected = commands.includes(button.command); }));
            this.listButtons[0].selected = commands.includes(this.listButtons[0].command);
        }
    }
    /**
     * @private
     * @param {?} command
     * @return {?}
     */
    emitAlignCommand(command) {
        /** @type {?} */
        const index = this.alignButtons.findIndex((/**
         * @param {?} btn
         * @return {?}
         */
        btn => btn.command === command));
        if (this.alignButtons[index].selected) {
            this.alignButtons[index].selected = false;
        }
        this.command.emit(command);
    }
    /**
     * @private
     * @param {?} command
     * @return {?}
     */
    emitCommand(command) {
        this.command.emit(command);
    }
    /**
     * @private
     * @return {?}
     */
    removeButtonFocus() {
        /** @type {?} */
        const buttons = this.toolbarElement.nativeElement.querySelectorAll('button');
        buttons.forEach((/**
         * @param {?} button
         * @return {?}
         */
        button => { button.setAttribute('tabindex', '-1'); }));
    }
    /**
     * @private
     * @param {?} state
     * @return {?}
     */
    toggleDisableButtons(state) {
        this.alignButtons.forEach((/**
         * @param {?} button
         * @return {?}
         */
        button => { button.disabled = state; }));
        this.formatButtons.forEach((/**
         * @param {?} button
         * @return {?}
         */
        button => { button.disabled = state; }));
        this.listButtons[0].disabled = state;
    }
}
ThfRichTextToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-rich-text-toolbar',
                template: "<div class=\"thf-rich-text-toolbar\" #toolbarElement>\n  <div class=\"thf-rich-text-toolbar-button-align\">\n    <thf-button-group [t-buttons]=\"formatButtons\" t-toggle=\"multiple\"></thf-button-group>\n  </div>\n\n  <div class=\"thf-rich-text-toolbar-button-align\">\n    <thf-button-group [t-buttons]=\"alignButtons\" t-toggle=\"single\"></thf-button-group>\n  </div>\n\n  <div class=\"thf-rich-text-toolbar-button-align\">\n    <thf-button-group [t-buttons]=\"listButtons\" t-toggle=\"single\"></thf-button-group>\n  </div>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfRichTextToolbarComponent.ctorParameters = () => [
    { type: ThfLanguageService }
];
ThfRichTextToolbarComponent.propDecorators = {
    toolbarElement: [{ type: ViewChild, args: ['toolbarElement', { static: true },] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    command: [{ type: Output, args: ['t-command',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfInputBaseComponent
 *
 * \@example
 *
 * <example name="thf-input-basic" title="Totvs Input Basic">
 *  <file name="sample-thf-input-basic/sample-thf-input-basic.component.html"> </file>
 *  <file name="sample-thf-input-basic/sample-thf-input-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-input-labs" title="Totvs Input Labs">
 *  <file name="sample-thf-input-labs/sample-thf-input-labs.component.html"> </file>
 *  <file name="sample-thf-input-labs/sample-thf-input-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-input-reactive-form" title="Totvs Input - Reactive Form">
 *  <file name="sample-thf-input-reactive-form/sample-thf-input-reactive-form.component.html"> </file>
 *  <file name="sample-thf-input-reactive-form/sample-thf-input-reactive-form.component.ts"> </file>
 * </example>
 */
class ThfInputComponent extends ThfInputGeneric {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    extraValidation(c) {
        return null;
    }
}
ThfInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-input',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <div *ngIf=\"icon\" class=\"thf-field-icon-container-left\">\n      <span class=\"thf-icon thf-field-icon {{ icon }}\" [class.thf-field-icon-disabled]=\"disabled\"></span>\n    </div>\n\n    <input #inp\n      class=\"thf-input\"\n      [attr.name]=\"name\"\n      [class.thf-input-icon-left]=\"icon\"\n      [class.thf-input-icon-right]=\"clean\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      [type]=\"type\"\n      (blur)=\"eventOnBlur($event)\"\n      (click)=\"eventOnClick($event)\"\n      (focus)=\"eventOnFocus($event)\"\n      (input)=\"eventOnInput($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean [t-element-ref]=\"inputEl\" (t-change-event)=\"clear($event)\"></thf-clean>\n    </div>\n  </div>\n\n  <thf-field-container-bottom\n    [t-error-pattern]=\"getErrorPattern()\">\n  </thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfInputComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfInputComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfInputComponent.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ThfNumberBaseComponent extends ThfInputGeneric {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        super(elementRef);
        this.type = 'number';
    }
    /**
     * @param {?} e
     * @return {?}
     */
    eventOnInput(e) {
        if (!this.mask) {
            /** @type {?} */
            let value = e.target.value;
            /** @type {?} */
            const valueMaxlength = this.validMaxLength(this.maxlength, value);
            if (value !== valueMaxlength) {
                value = valueMaxlength;
                this.inputEl.nativeElement.value = value;
            }
            this.callOnChange(this.formatNumber(value));
        }
    }
    /**
     * @param {?} maxlength
     * @param {?} value
     * @return {?}
     */
    validMaxLength(maxlength, value) {
        if (maxlength && value.length > maxlength) {
            /** @type {?} */
            const substringValue = value.toString().substring(0, maxlength);
            if (substringValue && this.isEndWithDot(substringValue)) {
                return substringValue.toString().substring(0, maxlength - 1);
            }
            return substringValue;
        }
        return value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValueModel(value) {
        if (this.inputEl) {
            if (value || value === 0) {
                if (this.mask) {
                    this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
                    // Se o model for definido como formatado, então precisa atualizá-lo no primeiro acesso
                    if (this.objMask.formatModel) {
                        this.onChangePropagate(this.objMask.valueToModel);
                    }
                }
                else {
                    this.inputEl.nativeElement.value = value;
                }
            }
            else { // Se for o valor for undefined, deve limpar o campo
                this.inputEl.nativeElement.value = '';
            }
        }
        // Emite evento quando o model é atualizado, inclusive a primeira vez
        this.changeModel.emit(value);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isEndWithDot(value) {
        return value && value.lastIndexOf('.') === value.length - 1;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    formatNumber(value) {
        return value ? Number(value) : null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfInputBaseComponent
 *
 * \@description
 *
 * thf-number é um input específico para receber apenas números.
 * É possível configurar um valor mínimo, máximo e um step com t-min, t-max e t-step,
 * respectivamente.
 *
 * \@example
 *
 * <example name="thf-number-basic" title="Totvs Number Basic">
 *  <file name="sample-thf-number-basic/sample-thf-number-basic.component.html"> </file>
 *  <file name="sample-thf-number-basic/sample-thf-number-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-number-labs" title="Totvs Number Labs">
 *  <file name="sample-thf-number-labs/sample-thf-number-labs.component.html"> </file>
 *  <file name="sample-thf-number-labs/sample-thf-number-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-number-calculate" title="Totvs Number - Calculate">
 *  <file name="sample-thf-number-calculate/sample-thf-number-calculate.component.html"> </file>
 *  <file name="sample-thf-number-calculate/sample-thf-number-calculate.component.ts"> </file>
 * </example>
 */
class ThfNumberComponent extends ThfNumberBaseComponent {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
        /**
         * \@optional
         *
         * \@description
         *
         * Intervalo.
         *
         * \@default 1
         */
        this.step = '1';
    }
    /**
     * @param {?} min
     * @return {?}
     */
    set setMin(min) {
        /** @type {?} */
        const parsedInt = parseInt(min, 10);
        this.min = !isNaN(parsedInt) ? parsedInt : undefined;
        this.validateModel();
    }
    /**
     * @param {?} max
     * @return {?}
     */
    set setMax(max) {
        /** @type {?} */
        const parsedInt = parseInt(max, 10);
        this.max = !isNaN(parsedInt) ? parsedInt : undefined;
        this.validateModel();
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    extraValidation(abstractControl) {
        if (minFailed(this.min, abstractControl.value)) {
            return { min: {
                    valid: false,
                } };
        }
        if (maxFailed(this.max, abstractControl.value)) {
            return { max: {
                    valid: false,
                } };
        }
        return null;
    }
}
ThfNumberComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-number',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <input #inp\n      class=\"thf-input\"\n      type=\"number\"\n      [attr.max]=\"max\"\n      [attr.min]=\"min\"\n      [attr.name]=\"name\"\n      [attr.step]=\"step\"\n      [class.thf-input-icon-right]=\"clean\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      (blur)=\"eventOnBlur($event)\"\n      (focus)=\"eventOnFocus($event)\"\n      (input)=\"eventOnInput($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean [t-default-value]=\"null\"\n        [t-element-ref]=\"inputEl\"\n        (t-change-event)=\"clear($event)\">\n      </thf-clean>\n    </div>\n  </div>\n\n  <thf-field-container-bottom\n    [t-error-pattern]=\"getErrorPattern()\">\n  </thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfNumberComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfNumberComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfNumberComponent.ctorParameters = () => [
    { type: ElementRef }
];
ThfNumberComponent.propDecorators = {
    setMin: [{ type: Input, args: ['t-min',] }],
    setMax: [{ type: Input, args: ['t-max',] }],
    step: [{ type: Input, args: ['t-step',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfInputBaseComponent
 *
 * \@description
 * O thf-password é um input específico para senhas. Já possui tipo, estilo e ícone predefinidos.
 *
 * \@example
 *
 * <example name="thf-password-basic" title="Totvs Password Basic">
 *   <file name="sample-thf-password-basic/sample-thf-password-basic.component.html"> </file>
 *   <file name="sample-thf-password-basic/sample-thf-password-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-password-labs" title="Totvs Password Labs">
 *   <file name="sample-thf-password-labs/sample-thf-password-labs.component.html"> </file>
 *   <file name="sample-thf-password-labs/sample-thf-password-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-password-reset" title="Totvs Password - Reset">
 *   <file name="sample-thf-password-reset/sample-thf-password-reset.component.html"> </file>
 *   <file name="sample-thf-password-reset/sample-thf-password-reset.component.ts"> </file>
 * </example>
 */
class ThfPasswordComponent extends ThfInputGeneric {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
        this._hidePasswordPeek = false;
        this.type = 'password';
        this.visiblePassword = false;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Permite esconder a função de espiar a senha digitada.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set hidePasswordPeek(value) {
        this._hidePasswordPeek = convertToBoolean(value);
        if (value) {
            this.visiblePassword = false;
            this.type = 'password';
        }
    }
    /**
     * @return {?}
     */
    get hidePasswordPeek() {
        return this._hidePasswordPeek;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    extraValidation(c) {
        return null;
    }
    /**
     * @return {?}
     */
    showPassword() {
        this.visiblePassword = !this.visiblePassword;
        this.type = this.type === 'password' ? 'text' : 'password';
    }
}
ThfPasswordComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-password',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <div class=\"thf-field-icon-container-left\">\n      <span class=\"thf-icon thf-field-icon thf-icon-lock\"\n        [class.thf-field-icon-disabled]=\"disabled\">\n      </span>\n    </div>\n\n    <input #inp\n      class=\"thf-input thf-input-icon-left\"\n      [attr.name]=\"name\"\n      [class.thf-input-double-icon-right]=\"clean && inp.value && !hidePasswordPeek\"\n      [class.thf-input-icon-right]=\"clean || !hidePasswordPeek\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      [type]=\"disabled ? 'password' : type\"\n      (blur)=\"eventOnBlur($event)\"\n      (click)=\"eventOnClick($event)\"\n      (focus)=\"eventOnFocus($event)\"\n      (input)=\"eventOnInput($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean\n        class=\"thf-icon thf-field-icon\"\n        [t-element-ref]=\"inputEl\"\n        (t-change-event)=\"clear($event)\">\n      </thf-clean>\n\n      <span *ngIf=\"!hidePasswordPeek && !disabled\"\n        class=\"thf-icon thf-field-icon\"\n        [ngClass]=\"visiblePassword ? 'thf-icon-eye' : 'thf-icon-eye-off thf-field-icon-disabled'\"\n        (click)=\"showPassword()\">\n      </span>\n    </div>\n  </div>\n\n  <thf-field-container-bottom\n    [t-error-pattern]=\"getErrorPattern()\">\n  </thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfPasswordComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfPasswordComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfPasswordComponent.ctorParameters = () => [
    { type: ElementRef }
];
ThfPasswordComponent.propDecorators = {
    hidePasswordPeek: [{ type: Input, args: ['t-hide-password-peek',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfRadioGroupColumnsDefaultLength = 6;
/** @type {?} */
const thfRadioGroupColumnsTotalLength = 12;
/**
 * \@description
 *
 * O componente `thf-radio-group` deve ser utilizado para disponibilizar múltiplas opções ao usuário, permitindo a ele que
 * selecione apenas uma delas. Seu uso é recomendado para um número pequeno de opções, caso contrário, recomenda-se o uso
 * do [**thf-combo**](/documentation/thf-combo) ou [**thf-select**](/documentation/thf-select).
 *
 * Este não é um componente de multiseleção, se for este o caso, deve-se utilizar o
 * [**thf-checkbox-group**](/documentation/thf-checkbox-group).
 *
 * > Ao passar um valor para o *model* que não esteja na lista de opções, o mesmo será definido como `undefined`.
 * @abstract
 */
class ThfRadioGroupBaseComponent {
    constructor() {
        this._columns = thfRadioGroupColumnsDefaultLength;
        this._disabled = false;
        this._required = false;
        this.mdColumns = thfRadioGroupColumnsDefaultLength;
        this.onChangePropagate = null;
        /**
         * Evento ao alterar valor do campo.
         */
        this.change = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a quantidade de colunas para exibição das opções.
     *
     * **Considerações:**
     *  - É possível exibir as opções entre `1` e `4` colunas.
     *  - O número máximo de colunas é invariável nas seguintes resoluções:
     *    + `sm`: `1`
     *    + `md`: `2`
     *
     * \@default `2`
     * @param {?} value
     * @return {?}
     */
    set columns(value) {
        /** @type {?} */
        const columns = convertToInt(value, thfRadioGroupColumnsDefaultLength);
        this._columns = this.getGridSystemColumns(columns, 4);
        this.mdColumns = this.getGridSystemColumns(columns, 2);
    }
    /**
     * @return {?}
     */
    get columns() {
        return this._columns;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será desabilitado.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = convertToBoolean(disabled);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * Lista de opções que serão exibidas.
     * Nesta propriedade deve ser definido um array de objetos que implementam a interface ThfRadioGroupOption.
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = value;
        removeDuplicatedOptions(this.options);
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    // Função que controla quando deve ser emitido onChange e atualiza o Model
    /**
     * @param {?} changedValue
     * @return {?}
     */
    changeValue(changedValue) {
        if (this.onChangePropagate) {
            this.onChangePropagate(changedValue);
        }
        if (this.value !== changedValue) {
            this.change.emit(changedValue);
        }
        this.value = changedValue;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangePropagate = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
            return {
                required: {
                    valid: false,
                }
            };
        }
    }
    /**
     * @param {?} modelValue
     * @return {?}
     */
    writeValue(modelValue) {
        this.value = modelValue;
        // Busca radio com o valor especificado
        /** @type {?} */
        const element = this.getElementByValue(modelValue);
        if (!element && this.onChangePropagate) {
            this.value = undefined;
            this.onChangePropagate(this.value);
        }
    }
    /**
     * @private
     * @param {?} columns
     * @param {?} maxColumns
     * @return {?}
     */
    checkColumnsRange(columns, maxColumns) {
        /** @type {?} */
        const minColumns = 1;
        return columns >= minColumns && columns <= maxColumns;
    }
    /**
     * @private
     * @param {?} columns
     * @param {?} maxColumns
     * @return {?}
     */
    getGridSystemColumns(columns, maxColumns) {
        /** @type {?} */
        const gridSystemColumns = thfRadioGroupColumnsTotalLength / columns;
        return this.checkColumnsRange(columns, maxColumns) ? gridSystemColumns : thfRadioGroupColumnsDefaultLength;
    }
    /**
     * @private
     * @return {?}
     */
    validateModel() {
        if (this.validatorChange) {
            this.validatorChange();
        }
    }
}
ThfRadioGroupBaseComponent.propDecorators = {
    name: [{ type: Input, args: ['name',] }],
    columns: [{ type: Input, args: ['t-columns',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    required: [{ type: Input, args: ['t-required',] }],
    options: [{ type: Input, args: ['t-options',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    change: [{ type: Output, args: ['t-change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfRadioGroupBaseComponent
 *
 * \@example
 *
 * <example name="thf-radio-group-basic" title="Totvs Radio Group Basic">
 *  <file name="sample-thf-radio-group-basic/sample-thf-radio-group-basic.component.html"> </file>
 *  <file name="sample-thf-radio-group-basic/sample-thf-radio-group-basic.component.ts"> </file>
 *  <file name="sample-thf-radio-group-basic/sample-thf-radio-group-basic.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-radio-group-basic/sample-thf-radio-group-basic.component.po.ts"> </file>
 * </example>
 *
 * <example name="thf-radio-group-labs" title="Totvs Radio Group Labs">
 *  <file name="sample-thf-radio-group-labs/sample-thf-radio-group-labs.component.html"> </file>
 *  <file name="sample-thf-radio-group-labs/sample-thf-radio-group-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-radio-group-translator" title="Totvs Radio Group - Translator">
 *  <file name="sample-thf-radio-group-translator/sample-thf-radio-group-translator.component.html"> </file>
 *  <file name="sample-thf-radio-group-translator/sample-thf-radio-group-translator.component.ts"> </file>
 * </example>
 *
 * <example name="thf-radio-group-translator-reactive-form" title="Totvs Radio Group - Translator Reactive Form">
 *  <file name="sample-thf-radio-group-translator-reactive-form/sample-thf-radio-group-translator-reactive-form.component.html"> </file>
 *  <file name="sample-thf-radio-group-translator-reactive-form/sample-thf-radio-group-translator-reactive-form.component.ts"> </file>
 * </example>
 *
 */
class ThfRadioGroupComponent extends ThfRadioGroupBaseComponent {
    /**
     * @param {?} differs
     */
    constructor(differs) {
        super();
        this.differ = differs.find([]).create(null);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const change = this.differ.diff(this.options);
        if (change) {
            removeDuplicatedOptions(this.options);
        }
    }
    /**
     * @param {?} value
     * @param {?} disabled
     * @return {?}
     */
    eventClick(value, disabled) {
        if (!disabled) {
            this.changeValue(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getElementByValue(value) {
        return this.inputEl.nativeElement.querySelector(`input[value='${value}']`);
    }
    /**
     * @param {?} event
     * @param {?} value
     * @return {?}
     */
    onKeyUp(event, value) {
        /** @type {?} */
        const key = event.keyCode || event.which;
        if (this.isArrowKey(key)) {
            this.changeValue(value);
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    isArrowKey(key) {
        return key >= 37 && key <= 40;
    }
}
ThfRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-radio-group',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-row thf-pt-1 thf-pb-1\" #inp>\n    <div *ngFor=\"let option of options\"\n      class=\"thf-radio-group-item thf-md-{{ mdColumns }} thf-lg-{{ columns }}\">\n\n      <input #input\n        class=\"thf-radio-group-input\"\n        type=\"radio\"\n        [attr.name]=\"name\"\n        [checked]=\"value === option.value\"\n        [class.thf-radio-group-input-checked]=\"value === option.value\"\n        [disabled]=\"option.disabled === true || disabled\"\n        [readonly]=\"readonly\"\n        [required]=\"required\"\n        [value]=\"option.value\"\n        (keyup)=\"onKeyUp($event, option.value)\">\n        <label\n          class=\"thf-radio-group-label\"\n          [class.thf-clickable]=\"!input.disabled\"\n          [for]=\"name\"\n          (click)=\"eventClick(option.value, option.disabled === true || disabled)\">\n        {{ option.label }}\n      </label>\n    </div>\n  </div>\n  <thf-field-container-bottom></thf-field-container-bottom>\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfRadioGroupComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfRadioGroupComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfRadioGroupComponent.ctorParameters = () => [
    { type: IterableDiffers }
];
ThfRadioGroupComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    inputEl: [{ type: ViewChild, args: ['inp', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente thf-select exibe uma lista de valores e permite que o usuário selecione um desses valores.
 * Os valores listados podem ser fixos ou dinâmicos de acordo com a necessidade do desenvolvedor, dando mais flexibilidade ao componente.
 * O thf-select não permite que o usuário informe um valor diferente dos valores listados, isso garante a consistência da informação.
 * O thf-select não permite que sejam passados valores duplicados, undefined e null para as opções, excluindo-os da lista.
 *
 * > Ao passar um valor para o _model_ que não está na lista de opções, o mesmo será definido como `undefined`.
 *
 * Também existe a possibilidade de utilizar um _template_ para a exibição dos itens da lista,
 * veja mais em **[t-select-option-template](/documentation/thf-select-option-template)**.
 * @abstract
 */
class ThfSelectBaseComponent {
    /**
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(element, changeDetector) {
        this.element = element;
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        /**
         * Deve ser informada uma função que será disparada quando houver alterações no ngModel.
         */
        this.change = new EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new EventEmitter();
        this.readyToValidation = false;
        this.element = element;
        this.changeDetector = changeDetector;
    }
    /**
     * Nesta propriedade deve ser definido uma coleção de objetos que implementam a interface ThfSelectOption.
     * Caso esta lista estiver vazia, o model será undefined.
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        this._options = options;
        removeDuplicatedOptions(this._options);
        removeUndefinedAndNullOptions(this._options);
        this.onUpdateOptions();
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será desabilitado.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = convertToBoolean(disabled);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será somente para leitura.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    callModelChange(value) {
        // Caso o componente estiver dentro de um form, terá acesso ao método onModelChange.
        return (this.onModelChange) ? this.onModelChange(value) : this.ngModelChange.emit(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChange(value) {
        this.change.emit(value);
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if (requiredFailed(this._required, this._disabled, abstractControl.value)) {
            return {
                required: {
                    valid: false,
                }
            };
        }
        return null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    validateModel() {
        if (this.onValidatorChange) {
            this.onValidatorChange();
        }
    }
}
ThfSelectBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    name: [{ type: Input, args: ['name',] }],
    help: [{ type: Input, args: ['t-help',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    options: [{ type: Input, args: ['t-options',] }],
    change: [{ type: Output, args: ['t-change',] }],
    ngModelChange: [{ type: Output, args: ['ngModelChange',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    required: [{ type: Input, args: ['t-required',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfSelectComponent
 *
 * \@description
 *
 * Esta diretiva permite personalizar o conteúdo dos itens exibidos na lista suspensa do componente.
 *
 * > Quando utilizada em _mobile_ será exibido o componente nativo.
 *
 * Para personalizar o conteúdo de cada item da lista deve-se utilizar a diretiva `t-select-option-template` com `ng-template`
 * dentro da tag `thf-select`.
 *
 * Para obter a referência do item atual, use `let-option`, com isso você terá acesso aos valores e poderá personalizar sua exibição.
 *
 * Esta diretiva compõe-se de dois meios para uso, de forma explícita tal como em *syntax sugar*. Veja a seguir ambos, respectivamente:
 *
 * ```
 * ...
 * <thf-select
 *   name="select"
 *   [(ngModel)]="select"
 *   [t-options]="options">
 *     <ng-template t-select-option-template let-option>
 *       <option-template [option]="option"></option-template>
 *     </ng-template>
 * </thf-select>
 * ...
 * ```
 *
 * ```
 * ...
 * <thf-select
 *   name="select"
 *   [(ngModel)]="select"
 *   [t-options]="options">
 *     <div *t-select-option-template="let option">
 *       <option-template [option]="option"></option-template>
 *     </div>
 * </thf-select>
 * ...
 *
 * ```
 */
class ThfSelectOptionTemplateDirective {
    // Necessário manter templateRef para o funcionamento do row template.
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ThfSelectOptionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[t-select-option-template]'
            },] }
];
/** @nocollapse */
ThfSelectOptionTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfSelectContentOffset = 8;
/** @type {?} */
const thfSelectContentPositionDefault = 'bottom';
/**
 * \@docsExtends ThfSelectBaseComponent
 *
 * \@example
 *
 * <example name="thf-select-basic" title="Totvs Select Basic">
 *   <file name="sample-thf-select-basic/sample-thf-select-basic.component.html"> </file>
 *   <file name="sample-thf-select-basic/sample-thf-select-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-select-labs" title="Totvs Select Labs">
 *   <file name="sample-thf-select-labs/sample-thf-select-labs.component.html"> </file>
 *   <file name="sample-thf-select-labs/sample-thf-select-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-select-customer-registration" title="Totvs Select - Customer registration">
 *   <file name="sample-thf-select-customer-registration/sample-thf-select-customer-registration.component.html"> </file>
 *   <file name="sample-thf-select-customer-registration/sample-thf-select-customer-registration.component.ts"> </file>
 *   <file name="sample-thf-select-customer-registration/sample-thf-select-customer-registration.service.ts"> </file>
 *   <file name='sample-thf-select-customer-registration/sample-thf-select-customer-registration.component.e2e-spec.ts'> </file>
 *   <file name='sample-thf-select-customer-registration/sample-thf-select-customer-registration.component.po.ts'> </file>
 * </example>
 */
class ThfSelectComponent extends ThfSelectBaseComponent {
    /**
     * @param {?} element
     * @param {?} changeDetector
     * @param {?} differs
     * @param {?} renderer
     * @param {?} controlPosition
     */
    constructor(element, changeDetector, differs, renderer, controlPosition) {
        super(element, changeDetector);
        this.renderer = renderer;
        this.controlPosition = controlPosition;
        this.isMobile = isMobile();
        this.open = false;
        this.selectIcon = 'thf-icon-arrow-down';
        this.onScroll = (/**
         * @return {?}
         */
        () => {
            this.controlPosition.adjustPosition(thfSelectContentPositionDefault);
        });
        this.differ = differs.find([]).create(null);
    }
    /**
     * @return {?}
     */
    get isInvisibleSelectNative() {
        return this.readonly && this.isMobile;
    }
    /**
     * @param {?=} $event
     * @return {?}
     */
    onKeydown($event) {
        /** @type {?} */
        const charCode = $event.which || $event.keyCode;
        // Tratamentos para quando o readonly for ativado.
        if (this.readonly) {
            // deve matar o evento do teclado devido a alterar o valor do model mesmo com os options fechados
            if (charCode !== ThfKeyCodeEnum.tab) {
                this.disableDefaultEventAndToggleButton();
                $event.preventDefault();
            }
            return;
        }
        // Seleciona os itens com as teclas "up" e "down"
        if ((!this.open || $event.altKey) && (charCode === ThfKeyCodeEnum.arrowDown || charCode === ThfKeyCodeEnum.arrowUp)) {
            this.disableDefaultEventAndToggleButton();
        }
        // Abre o thf-select com as teclas "enter" e "espaço"
        if (charCode === ThfKeyCodeEnum.enter || charCode === ThfKeyCodeEnum.space) {
            this.disableDefaultEventAndToggleButton();
        }
        // Fecha o thf-select com a tecla "tab"
        if (this.open && charCode === ThfKeyCodeEnum.tab) {
            $event.preventDefault();
            this.toggleButton();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const change = this.differ.diff(this.options);
        if (change) {
            removeDuplicatedOptions(this.options);
            removeUndefinedAndNullOptions(this.options);
        }
    }
    /**
     * @return {?}
     */
    hideDropDown() {
        this.selectIcon = 'thf-icon-arrow-down';
        this.selector('.thf-select-container').classList.remove('thf-select-show');
        this.open = false;
        this.changeDetector.markForCheck();
        this.selectElement.nativeElement.focus();
        this.removeListeners();
    }
    /**
     * @param {?} value
     * @param {?} inputValue
     * @return {?}
     */
    isEqual(value, inputValue) {
        if ((value || value === 0) && inputValue) {
            return value.toString() === inputValue.toString();
        }
        if ((value === null && inputValue !== null) ||
            (value === undefined && inputValue !== undefined)) {
            value = `${value}`; // Transformando em string
        }
        return value === inputValue;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    onOptionClick(option) {
        this.toggleButton();
        this.updateModel(option);
    }
    // Altera o valor ao selecionar um item.
    /**
     * @param {?} value
     * @return {?}
     */
    onSelectChange(value) {
        /** @type {?} */
        const ulDropdpwn = this.element.nativeElement.querySelector('ul.thf-select-content');
        if (value && this.options && this.options.length) {
            /** @type {?} */
            const optionFound = this.options.find((/**
             * @param {?} option
             * @return {?}
             */
            option => {
                return this.isEqual(option.value, value);
            }));
            if (optionFound) {
                /** @type {?} */
                const index = this.options.indexOf(optionFound);
                ulDropdpwn.scrollTop = this.scrollValue(index, ulDropdpwn.clientHeight);
                this.updateModel(optionFound);
            }
        }
    }
    /**
     * @return {?}
     */
    onUpdateOptions() {
        if (this.modelValue) {
            this.onSelectChange(this.modelValue);
        }
    }
    /**
     * @param {?} index
     * @param {?} clientHeight
     * @return {?}
     */
    scrollValue(index, clientHeight) {
        /** @type {?} */
        const heightScrollValue = (index + 1) * this.getSelectItemHeight();
        return this.scrollPosition = heightScrollValue > clientHeight ? heightScrollValue : 0;
    }
    /**
     * @param {?} query
     * @return {?}
     */
    selector(query) {
        return this.element.nativeElement.querySelector(query);
    }
    /**
     * @return {?}
     */
    toggleButton() {
        this.open ? this.hideDropDown() : this.showDropdown();
    }
    // Atualiza valores
    /**
     * @param {?} option
     * @return {?}
     */
    updateModel(option) {
        if (this.selectedValue !== option.value) {
            this.selectedValue = option.value;
            this.selectElement.nativeElement.value = option.value;
            this.callModelChange(option.value);
            this.displayValue = option.label;
            this.onChange(option.value);
        }
    }
    // Esconde Content do Select quando for clicado fora
    /**
     * @param {?} event
     * @return {?}
     */
    wasClickedOnToggle(event) {
        if (!this.selectButtonElement.nativeElement.contains(event.target) &&
            !this.iconElement.nativeElement.contains(event.target)) {
            this.hideDropDown();
        }
    }
    // Recebe as alterações do model
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        /** @type {?} */
        const optionFound = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        option => {
            return this.isEqual(option.value, value);
        }));
        if (optionFound) {
            this.selectElement.nativeElement.value = optionFound.value;
            this.selectedValue = optionFound.value;
            this.displayValue = (optionFound.label);
        }
        else if (validValue(this.selectedValue)) {
            this.selectElement.nativeElement.value = undefined;
            this.callModelChange(undefined);
            this.selectedValue = undefined;
            this.displayValue = undefined;
        }
        this.modelValue = value;
        this.changeDetector.detectChanges();
    }
    // Método necessário para bloquear o evento default do select nativo.
    // Ao utilizar event.preventDefault(), nos navegadores Firefox e IE o mesmo não cancela o evento.
    /**
     * @private
     * @return {?}
     */
    disableDefaultEventAndToggleButton() {
        this.selectElement.nativeElement.style.display = 'none';
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.selectElement.nativeElement.style.display = 'block';
            this.toggleButton();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    getSelectItemHeight() {
        /** @type {?} */
        const selectItem = this.selector('div.thf-select-item');
        return selectItem && selectItem.clientHeight;
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.clickoutListener = this.renderer.listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.wasClickedOnToggle(event);
        }));
        this.eventResizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.hideDropDown();
        }));
        window.addEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.clickoutListener) {
            this.clickoutListener();
        }
        this.eventResizeListener();
        window.removeEventListener('scroll', this.onScroll, true);
    }
    /**
     * @private
     * @return {?}
     */
    setPositionDropdown() {
        this.controlPosition.setElements(this.contentList.nativeElement, thfSelectContentOffset, this.selectButtonElement, ['top', 'bottom'], true);
        this.controlPosition.adjustPosition(thfSelectContentPositionDefault);
    }
    /**
     * @private
     * @return {?}
     */
    showDropdown() {
        if (!this.readonly) {
            this.selectElement.nativeElement.focus();
            if (this.options && this.options.length) {
                /** @type {?} */
                const ulDropdpwn = this.element.nativeElement.querySelector('ul.thf-select-content');
                ulDropdpwn.scrollTop = this.scrollPosition;
            }
            this.selectIcon = 'thf-icon-arrow-up';
            this.selector('.thf-select-container').classList.add('thf-select-show');
            this.open = true;
            this.changeDetector.markForCheck();
            this.setPositionDropdown();
            this.initializeListeners();
        }
    }
}
ThfSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-select',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <select #select\n    class=\"thf-select\"\n    [attr.name]=\"name\"\n    [disabled]=\"disabled\"\n    [ngClass]=\"{'thf-select-mobile' : isMobile, 'thf-invisible': isInvisibleSelectNative}\"\n    [required]=\"required\"\n    (change)=\"onSelectChange($event.target.value)\">\n    <option *ngIf=\"isMobile\" disabled hidden selected></option>\n    <option *ngFor=\"let option of options\"\n      [disabled]=\"readonly\"\n      [value]=\"option.value\"\n      (click)=\"onOptionClick(option)\">\n        {{option?.label}}\n    </option>\n  </select>\n\n  <div class=\"thf-select-container\">\n    <div #selectButton\n      class=\"thf-select-button\"\n      [ngClass]=\"{'thf-select-button-disabled' : disabled, 'thf-select-button-readonly' : readonly}\"\n      (click)=\"toggleButton()\">\n\n      <span>{{displayValue || placeholder}}</span>\n\n      <div class=\"thf-field-icon-container-right\">\n        <span #icon\n          class=\"thf-icon {{selectIcon}} thf-field-icon\"\n          [ngClass]=\"{'thf-field-icon-disabled' : disabled, 'thf-field-icon-readonly' : readonly}\"></span>\n      </div>\n    </div>\n\n    <ul #contentList\n      class=\"thf-select-content\"\n      [ngClass]=\"{'thf-invisible': isMobile}\">\n\n      <li *ngFor=\"let option of options\"\n        [class.thf-select-item-selected]=\"selectedValue == option.value\"\n        [value]=\"option.value\"\n        (click)=\"onOptionClick(option)\">\n        <div class=\"thf-select-item\">\n\n          <ng-container *ngIf=\"selectOptionTemplate; then optionTemplate; else defaultOptionTemplate\"></ng-container>\n\n          <ng-template #defaultOptionTemplate>\n            <span>{{option?.label}}</span>\n          </ng-template>\n\n          <ng-template #optionTemplate\n            [ngTemplateOutlet]=\"selectOptionTemplate?.templateRef\"\n            [ngTemplateOutletContext]=\"{$implicit: option}\">\n          </ng-template>\n\n        </div>\n      </li>\n    </ul>\n  </div>\n\n  <thf-field-container-bottom></thf-field-container-bottom>\n\n</thf-field-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfSelectComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfSelectComponent)),
                        multi: true,
                    },
                    ThfControlPositionService
                ]
            }] }
];
/** @nocollapse */
ThfSelectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IterableDiffers },
    { type: Renderer2 },
    { type: ThfControlPositionService }
];
ThfSelectComponent.propDecorators = {
    selectOptionTemplate: [{ type: ContentChild, args: [ThfSelectOptionTemplateDirective, { static: true },] }],
    contentList: [{ type: ViewChild, args: ['contentList', { read: ElementRef, static: true },] }],
    iconElement: [{ type: ViewChild, args: ['icon', { read: ElementRef, static: true },] }],
    selectElement: [{ type: ViewChild, args: ['select', { read: ElementRef, static: true },] }],
    selectButtonElement: [{ type: ViewChild, args: ['selectButton', { read: ElementRef, static: true },] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfSwitchLabelPosition = {
    /** Posiciona o label do lado esquerdo do switch. */
    Right: 0,
    /** Posiciona o label do lado direito do switch. */
    Left: 1,
};
ThfSwitchLabelPosition[ThfSwitchLabelPosition.Right] = 'Right';
ThfSwitchLabelPosition[ThfSwitchLabelPosition.Left] = 'Left';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-switch` é um [checkbox](/documentation/thf-checkbox-group) mais intuitivo, pois faz analogia a um interruptor.
 * Deve ser usado quando deseja-se transmitir a ideia de ligar / desligar uma funcionalidade específica.
 *
 * Pode-se ligar ou deligar o botão utilizando a tecla de espaço ou o clique do mouse.
 *
 * O texto exibido pode ser alterado de acordo com o valor setado aumentando as possibilidades de uso do componente,
 * portanto, recomenda-se informar textos que contextualizem seu uso para que facilite a compreensão do usuário.
 *
 * > O componente não altera o valor incial informado no *model*, portanto indica-se inicializa-lo caso ter necessidade.
 */
class ThfSwitchBaseComponent {
    constructor() {
        this._disabled = false;
        this.switchValue = false;
        /**
         * Texto exibido quando o valor do componente for `true`.
         *
         * \@default `true`
         */
        this.labelOn = 'true';
        /**
         * Texto exibido quando o valor do componente for `false`.
         *
         * \@default `false`
         */
        this.labelOff = 'false';
        /**
         * \@optional
         *
         * \@description
         *
         * Posição de exibição do rótulo.
         *
         * > Por padrão exibe à direita.
         */
        this.labelPosition = ThfSwitchLabelPosition.Right;
        /**
         * Evento disparado ao alterar valor do campo.
         */
        this.change = new EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new EventEmitter();
    }
    /**
     * @param {?} label
     * @return {?}
     */
    set setLabelOn(label) {
        this.labelOn = label || 'true';
    }
    /**
     * @param {?} label
     * @return {?}
     */
    set setLabelOff(label) {
        this.labelOff = label || 'false';
    }
    /**
     * @param {?} position
     * @return {?}
     */
    set setLabelPosition(position) {
        this.labelPosition = (position in ThfSwitchLabelPosition) ? parseInt((/** @type {?} */ (position)), 10) : ThfSwitchLabelPosition.Right;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica se o campo será desabilitado.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = convertToBoolean(disabled);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeValue(value) {
        if (this.switchValue !== value) {
            this.switchValue = value;
            if (this.propagateChange) {
                this.propagateChange(value);
            }
            else {
                this.ngModelChange.emit(value);
            }
            this.change.emit(this.switchValue);
        }
    }
    /**
     * @return {?}
     */
    eventClick() {
        if (!this.disabled) {
            this.changeValue(!this.switchValue);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.switchValue) {
            this.switchValue = !!value;
        }
    }
}
ThfSwitchBaseComponent.propDecorators = {
    name: [{ type: Input, args: ['name',] }],
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    setLabelOn: [{ type: Input, args: ['t-label-on',] }],
    setLabelOff: [{ type: Input, args: ['t-label-off',] }],
    setLabelPosition: [{ type: Input, args: ['t-label-position',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    change: [{ type: Output, args: ['t-change',] }],
    ngModelChange: [{ type: Output, args: ['ngModelChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfSwitchBaseComponent
 *
 * \@example
 *
 * <example name="thf-switch-basic" title="Totvs Switch Basic">
 *   <file name="sample-thf-switch-basic/sample-thf-switch-basic.component.html"> </file>
 *   <file name="sample-thf-switch-basic/sample-thf-switch-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-switch-labs" title="Totvs Switch Labs">
 *   <file name="sample-thf-switch-labs/sample-thf-switch-labs.component.html"> </file>
 *   <file name="sample-thf-switch-labs/sample-thf-switch-labs.component.ts"> </file>
 *   <file name="sample-thf-switch-labs/sample-thf-switch-labs.component.e2e-spec.ts"> </file>
 *   <file name="sample-thf-switch-labs/sample-thf-switch-labs.component.po.ts"> </file>
 * </example>
 *
 * <example name="thf-switch-order" title="Totvs Switch - Order Summary">
 *   <file name="sample-thf-switch-order/sample-thf-switch-order.component.html"> </file>
 *   <file name="sample-thf-switch-order/sample-thf-switch-order.component.ts"> </file>
 * </example>
 *
 * <example name="thf-switch-order-reactive-form" title="Totvs Switch - Order Summary Reactive Form">
 *   <file name="sample-thf-switch-order-reactive-form/sample-thf-switch-order-reactive-form.component.html"> </file>
 *   <file name="sample-thf-switch-order-reactive-form/sample-thf-switch-order-reactive-form.component.ts"> </file>
 * </example>
 */
class ThfSwitchComponent extends ThfSwitchBaseComponent {
    /**
     * @param {?} changeDetector
     */
    constructor(changeDetector) {
        super();
        this.changeDetector = changeDetector;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    getLabelPosition() {
        switch (this.labelPosition) {
            case ThfSwitchLabelPosition.Left: return 'left';
            case ThfSwitchLabelPosition.Right: return 'right';
            default: return 'right';
        }
    }
    /**
     * @return {?}
     */
    getSwitchPosition() {
        switch (this.labelPosition) {
            case ThfSwitchLabelPosition.Left: return 'right';
            case ThfSwitchLabelPosition.Right: return 'left';
            default: return 'left';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (event.which === 32 || event.keyCode === 32) {
            event.preventDefault();
            this.eventClick();
        }
    }
}
ThfSwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-switch',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\">\n\n  <div class=\"thf-field-container-content thf-switch-content\" [attr.name]=\"name\">\n    <div class=\"thf-switch-container thf-clickable\"\n      [class.thf-switch-container-disabled]=\"disabled\"\n      [class.thf-switch-container-off]=\"switchValue === false && !disabled\"\n      [class.thf-switch-container-on]=\"switchValue === true && !disabled\"\n      [class.thf-switch-container-right]=\"getSwitchPosition() === 'right'\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      (click)=\"eventClick()\"\n      (keydown)=\"onKeyDown($event)\">\n\n      <div class=\"thf-switch-button\"\n        [class.thf-switch-button-on]=\"switchValue === true\"\n        [class.thf-switch-button-off]=\"switchValue === false\"\n        [class.thf-switch-button-disabled]=\"disabled\">\n\n        <span class=\"thf-icon thf-icon-{{ switchValue === true ? 'ok' : 'close' }}\"></span>\n      </div>\n    </div>\n\n    <span class=\"thf-switch-label thf-clickable thf-switch-label-{{ getLabelPosition() }}\"\n      (click)=\"eventClick()\">\n        {{ switchValue === true ? labelOn : labelOff }}\n    </span>\n  </div>\n\n  <thf-field-container-bottom></thf-field-container-bottom>\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfSwitchComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfSwitchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Este é um componente de entrada de dados que possibilita o preechimento com múltiplas linhas.
 * É recomendado para observações, detalhamentos e outras situações onde o usuário deva preencher com um texto.
 *
 * Importante:
 *
 * - A propriedade `name` é obrigatória para que o formulário e o `model` funcionem corretamente. Do contrário, ocorrerá um erro de
 * _Angular_, onde será necessário informar o atributo `name` ou o atributo `[ngModelOptions]="{standalone: true}"`, por exemplo:
 *
 * ```
 * <thf-textarea
 *   [(ngModel)]="pessoa.nome"
 *   [ngModelOptions]="{standalone: true}">
 * </thf-textarea>
 * ```
 * @abstract
 */
class ThfTextareaBaseComponent {
    constructor() {
        this._disabled = false;
        this._focus = false;
        this._readonly = false;
        this._required = false;
        this._rows = 3;
        this.onChangePropagate = null;
        // tslint:disable-next-line
        this.onTouched = null;
        /**
         * Placeholder, mensagem que aparecerá enquanto o campo não estiver preenchido.
         */
        this.placeholder = '';
        /**
         * Evento disparado ao sair do campo.
         */
        this.blur = new EventEmitter();
        /**
         * Evento disparado ao entrar do campo.
         */
        this.enter = new EventEmitter();
        /**
         * Evento disparado ao alterar valor e deixar o campo.
         */
        this.change = new EventEmitter();
        /**
         * Evento disparado ao alterar valor do model.
         */
        this.changeModel = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será desabilitado.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = convertToBoolean(disabled);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será somente leitura.
     *
     * \@default `false`
     * @param {?} readonly
     * @return {?}
     */
    set readonly(readonly) {
        this._readonly = convertToBoolean(readonly);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * > Esta propriedade é desconsiderada quando o _input_ está desabilitado `(t-disabled)`.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo iniciará com foco.
     *
     * \@default `false`
     * @param {?} focus
     * @return {?}
     */
    set focus(focus) {
        this._focus = convertToBoolean(focus);
    }
    /**
     * @return {?}
     */
    get focus() {
        return this._focus;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica a quantidade mínima de caracteres que o campo aceita.
     * @param {?} minlength
     * @return {?}
     */
    set minlength(minlength) {
        this._minlength = convertToInt(minlength);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get minlength() {
        return this._minlength;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica a quantidade máxima de caracteres que o campo aceita.
     * @param {?} maxlength
     * @return {?}
     */
    set maxlength(maxlength) {
        this._maxlength = convertToInt(maxlength);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get maxlength() {
        return this._maxlength;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica a quantidade de linhas que serão exibidas.
     *
     * \@default `3`
     * @param {?} value
     * @return {?}
     */
    set rows(value) {
        this._rows = isNaN(parseInt((/** @type {?} */ (value)), 10)) || value < 3 ? 3 : parseInt((/** @type {?} */ (value)), 10);
    }
    /**
     * @return {?}
     */
    get rows() {
        return this._rows;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    callOnChange(value) {
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangePropagate) {
            this.onChangePropagate(value);
        }
        this.controlChangeModelEmitter(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    controlChangeModelEmitter(value) {
        if (this.modelLastUpdate !== value) {
            this.changeModel.emit(value);
            this.modelLastUpdate = value;
        }
    }
    // Funções `registerOnChange`, `registerOnTouched` e `registerOnValidatorChange` implementadas referentes ao ControlValueAccessor
    // usadas para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangePropagate = func;
    }
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouched = func;
    }
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnValidatorChange(func) {
        this.validatorChange = func;
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
            return { required: {
                    valid: false,
                } };
        }
        if (minlengthFailed(this.minlength, abstractControl.value)) {
            return { minlength: {
                    valid: false,
                } };
        }
        if (maxlengthFailed(this.maxlength, abstractControl.value)) {
            return { maxlength: {
                    valid: false,
                } };
        }
    }
    // Função implementada do ControlValueAccessor
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.writeValueModel(value);
    }
    /**
     * @protected
     * @return {?}
     */
    validateModel() {
        if (this.validatorChange) {
            this.validatorChange();
        }
    }
}
ThfTextareaBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    help: [{ type: Input, args: ['t-help',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    name: [{ type: Input, args: ['name',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    required: [{ type: Input, args: ['t-required',] }],
    focus: [{ type: Input, args: ['t-focus',] }],
    minlength: [{ type: Input, args: ['t-minlength',] }],
    maxlength: [{ type: Input, args: ['t-maxlength',] }],
    rows: [{ type: Input, args: ['t-rows',] }],
    blur: [{ type: Output, args: ['t-blur',] }],
    enter: [{ type: Output, args: ['t-enter',] }],
    change: [{ type: Output, args: ['t-change',] }],
    changeModel: [{ type: Output, args: ['t-change-model',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfTextareaBaseComponent
 *
 * \@example
 *
 * <example name="thf-textarea-basic" title="Totvs Textarea Basic" >
 *  <file name="sample-thf-textarea-basic/sample-thf-textarea-basic.component.html"> </file>
 *  <file name="sample-thf-textarea-basic/sample-thf-textarea-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-textarea-labs" title="Totvs Textarea Labs" >
 *  <file name="sample-thf-textarea-labs/sample-thf-textarea-labs.component.html"> </file>
 *  <file name="sample-thf-textarea-labs/sample-thf-textarea-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-textarea-email" title="Totvs Textarea - Email" >
 *  <file name="sample-thf-textarea-email/sample-thf-textarea-email.component.html"> </file>
 *  <file name="sample-thf-textarea-email/sample-thf-textarea-email.component.ts"> </file>
 * </example>
 *
 * <example name="thf-textarea-email-reactive-form" title="Totvs Textarea - Email Reactive Form" >
 *  <file name="sample-thf-textarea-email-reactive-form/sample-thf-textarea-email-reactive-form.component.html"> </file>
 *  <file name="sample-thf-textarea-email-reactive-form/sample-thf-textarea-email-reactive-form.component.ts"> </file>
 * </example>
 *
 */
class ThfTextareaComponent extends ThfTextareaBaseComponent {
    constructor() {
        super();
        this.fireChange = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValueModel(value) {
        if (this.inputEl) {
            if (!value) {
                // Se for o valor for undefined, deve limpar o campo
                this.inputEl.nativeElement.value = '';
            }
            else {
                this.inputEl.nativeElement.value = value;
            }
        }
        // Emite evento quando o model é atualizado, inclusive a primeira vez
        if (value) {
            this.change.emit(value);
        }
    }
    /**
     * @param {?} maxlength
     * @param {?} value
     * @return {?}
     */
    validMaxLength(maxlength, value) {
        return (maxlength && value.length > maxlength) ? value.toString().substring(0, maxlength) : value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    eventOnInput(event) {
        /** @type {?} */
        const value = this.validMaxLength(this.maxlength, event.target.value);
        this.callOnChange(value);
        this.inputEl.nativeElement.value = value;
    }
    /**
     * @return {?}
     */
    eventOnFocus() {
        // Atualiza valor da variável que será usada para verificar se o campo teve alteração
        this.valueBeforeChange = this.inputEl.nativeElement.value;
        // Dispara evento quando o usuário entrar no campo
        // Este evento também é disparado quando o campo inicia com foco.
        this.enter.emit();
    }
    /**
     * @return {?}
     */
    eventOnBlur() {
        this.blur.emit();
        this.controlChangeEmitter();
    }
    /**
     * @return {?}
     */
    controlChangeEmitter() {
        /** @type {?} */
        const elementValue = this.inputEl.nativeElement.value;
        if (elementValue !== this.valueBeforeChange) {
            this.change.emit(elementValue);
        }
    }
}
ThfTextareaComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-textarea',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <textarea #inp\n      class=\"thf-textarea\"\n      (blur)=\"eventOnBlur()\"\n      (focus)=\"eventOnFocus()\"\n      (input)=\"eventOnInput($event)\"\n      [attr.name]=\"name\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      [rows]=\"rows\">\n    </textarea>\n  </div>\n\n  <thf-field-container-bottom></thf-field-container-bottom>\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfTextareaComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfTextareaComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfTextareaComponent.ctorParameters = () => [];
ThfTextareaComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['inp', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfUploadStatus = {
    // Enviou com sucesso.
    Uploaded: 0,
    // Está enviando.
    Uploading: 1,
    // Ocorreu algum erro no envio.
    Error: 2,
    // Não enviou ou aconteceu algum erro.
    None: 3,
};
ThfUploadStatus[ThfUploadStatus.Uploaded] = 'Uploaded';
ThfUploadStatus[ThfUploadStatus.Uploading] = 'Uploading';
ThfUploadStatus[ThfUploadStatus.Error] = 'Error';
ThfUploadStatus[ThfUploadStatus.None] = 'None';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Classe responsável pelo arquivo do THF Upload
class ThfUploadFile {
    /**
     * @param {?} file
     */
    constructor(file) {
        if (file) {
            this.name = file.name;
            this.extension = this.getExtension(file.name);
            this.size = file.size;
            this.rawFile = file;
            this.uid = this.generateUUID();
            this.status = ThfUploadStatus.None;
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    getExtension(value) {
        if (value) {
            /** @type {?} */
            const extension = value.substr(value.lastIndexOf('.'));
            return extension.toLowerCase();
        }
        return '';
    }
    /**
     * @private
     * @return {?}
     */
    generateUUID() {
        /**
         * @return {?}
         */
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfUploadLiteralsDefault = {
    en: (/** @type {?} */ ({
        selectFile: 'Select file',
        deleteFile: 'Delete',
        cancel: 'Cancel',
        tryAgain: 'Try again',
        startSending: 'Start sending'
    })),
    es: (/** @type {?} */ ({
        selectFile: 'Seleccionar archivo',
        deleteFile: 'Borrar',
        cancel: 'Cancelar',
        tryAgain: 'Intentar de nuevo',
        startSending: 'Iniciar carga'
    })),
    pt: (/** @type {?} */ ({
        selectFile: 'Selecionar arquivo',
        deleteFile: 'Excluir',
        cancel: 'Cancelar',
        tryAgain: 'Tentar Novamente',
        startSending: 'Iniciar envio'
    }))
};
/** @type {?} */
const thfUploadFormFieldDefault = 'files';
/**
 * \@description
 *
 * O componente `thf-upload` permite que o usuário envie arquivo(s) ao servidor e acompanhe o progresso.
 * Este componente também possibilita algumas configurações como:
 *  - Múltipla seleção, onde o usuário pode enviar mais de um arquivo ao servidor.
 *  - Auto envio, onde o arquivo é enviado imediatamente após a seleção do usuário, não necessitando que o usuário
 * clique em enviar.
 *  - Restrições de formatos de arquivo e tamanho.
 *  - Função de sucesso que será disparada quando os arquivos forem enviados com sucesso.
 *  - Função de erro que será disparada quando houver erro no envio dos arquivos.
 */
class ThfUploadBaseComponent {
    /**
     * @param {?} uploadService
     */
    constructor(uploadService) {
        this.uploadService = uploadService;
        /**
         * Define o valor do atributo `name` do componente.
         */
        this.name = 'file';
        /**
         * \@optional
         *
         * \@description
         *
         * Define se o envio do arquivo será automático ao selecionar o mesmo.
         *
         * \@default `false`
         */
        this.autoUpload = false;
        /**
         * Função que será executada no momento de realizar o envio do arquivo,
         * onde será possível adicionar informações ao parâmetro que será enviado na requisição.
         * É passado por parâmetro um objeto com o arquivo e a propiedade data nesta propriedade pode ser informado algum dado,
         * que será enviado em conjunto com o arquivo na requisição, por exemplo:
         *
         * ```
         *   event.data = {id: 'id do usuario'};
         * ```
         */
        this.onUpload = new EventEmitter();
        /**
         * Evento será disparado quando ocorrer algum erro no envio do arquivo.
         * > Por parâmetro será passado o objeto do retorno que é do tipo `HttpErrorResponse`.
         */
        this.onError = new EventEmitter();
        /**
         * Evento será disparado quando o envio do arquivo for realizado com sucesso.
         * > Por parâmetro será passado o objeto do retorno que é do tipo `HttpResponse`.
         */
        this.onSuccess = new EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da *tag* `form`.
        this.ngModelChange = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Omite o botão de seleção de arquivos.
     *
     * > Caso o valor definido seja `true`, caberá ao desenvolvedor a responsabilidade
     * pela chamada do método `selectFiles()` para seleção de arquivos.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set hideSelectButton(value) {
        this._hideSelectButton = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get hideSelectButton() {
        return this._hideSelectButton;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Omite o botão de envio de arquivos.
     *
     * > Caso o valor definido seja `true`, caberá ao desenvolvedor a responsabilidade
     * pela chamada do método `sendFiles()` para envio do(s) arquivo(s) selecionado(s).
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set hideSendButton(value) {
        this._hideSendButton = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get hideSendButton() {
        return this._hideSendButton;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-upload`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfUploadLiterals = {
     *    selectFile: 'Buscar arquivo',
     *    deleteFile: 'Deletar',
     *    cancel: 'Desistir',
     *    tryAgain: 'Recomeçar',
     *    startSending: 'Enviar'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfUploadLiterals = {
     *    deleteFile: 'Deletar'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
     *
     * ```
     * <thf-upload
     *   [t-literals]="customLiterals">
     * </thf-upload>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfUploadLiteralsDefault[thfLocaleDefault], thfUploadLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfUploadLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfUploadLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto que segue a definição da interface `ThfFileRestrictions`,
     * que possibilita definir tamanho máximo/mínimo e extensão dos arquivos permitidos.
     * @param {?} restrictions
     * @return {?}
     */
    set fileRestrictions(restrictions) {
        this._fileRestrictions = restrictions;
        this.setAllowedExtensions(restrictions);
    }
    /**
     * @return {?}
     */
    get fileRestrictions() {
        return this._fileRestrictions;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Nome do campo de formulário que será enviado para o serviço informado na propriedade `t-url`.
     *
     * \@default `files`
     * @param {?} value
     * @return {?}
     */
    set formField(value) {
        this._formField = value && typeof value === 'string' ? value : thfUploadFormFieldDefault;
        this.getUploadService().formField = this.formField;
    }
    /**
     * @return {?}
     */
    get formField() {
        return this._formField;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será desabilitado.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
        this.validateModel(this.currentFiles);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.currentFiles);
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
            return {
                required: {
                    valid: false,
                }
            };
        }
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        if (model) {
            if (!isEquals(this.currentFiles, model)) {
                this.currentFiles = this.parseFiles(model);
            }
        }
        else {
            this.currentFiles = undefined;
        }
    }
    /**
     * @protected
     * @param {?} currentFilesLength
     * @return {?}
     */
    isExceededFileLimit(currentFilesLength) {
        return this.isMultiple &&
            this.fileRestrictions &&
            this.fileRestrictions.maxFiles > 0 &&
            this.fileRestrictions.maxFiles <= currentFilesLength;
    }
    // Faz o parse dos arquivos selecionados para arquivos do formato ThfUploadFile e atualiza os arquivos correntes.
    /**
     * @protected
     * @param {?} files
     * @return {?}
     */
    parseFiles(files) {
        /** @type {?} */
        let thfUploadFiles = this.currentFiles || [];
        /** @type {?} */
        const filesLength = files.length;
        for (let i = 0; i < filesLength; i++) {
            if (this.isExceededFileLimit(thfUploadFiles.length)) {
                break;
            }
            /** @type {?} */
            const file = new ThfUploadFile(files[i]);
            if (this.checkRestrictions(file)) {
                thfUploadFiles = this.insertFileInFiles(file, thfUploadFiles);
            }
        }
        return thfUploadFiles;
    }
    /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    validateModel(model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    // Verifica se o arquivo está de acordo com as restrições.
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    checkRestrictions(file) {
        /** @type {?} */
        const restrictions = this.fileRestrictions;
        if (restrictions) {
            /** @type {?} */
            const allowedExtensions = restrictions.allowedExtensions;
            /** @type {?} */
            const minFileSize = restrictions.minFileSize || 0;
            /** @type {?} */
            const maxFileSize = restrictions.maxFileSize || 31457280;
            // 30MB
            /** @type {?} */
            const isAccept = allowedExtensions ? this.isAllowedExtension(file.extension, allowedExtensions) : true;
            /** @type {?} */
            const isAcceptSize = file.size >= minFileSize && file.size <= maxFileSize;
            return isAccept && isAcceptSize;
        }
        return true;
    }
    /**
     * @private
     * @param {?} file
     * @param {?} files
     * @return {?}
     */
    existsFileSameName(file, files) {
        return files.some((/**
         * @param {?} currentFile
         * @return {?}
         */
        currentFile => file.name === currentFile.name));
    }
    /**
     * @private
     * @return {?}
     */
    getUploadService() {
        return this.uploadService;
    }
    /**
     * @private
     * @param {?} newFile
     * @param {?} files
     * @return {?}
     */
    insertFileInFiles(newFile, files) {
        if (this.existsFileSameName(newFile, files)) {
            return this.updateExistsFileInFiles(newFile, files);
        }
        if (this.isMultiple) {
            files.push(newFile);
        }
        else {
            files.splice(0, files.length, newFile);
        }
        return files;
    }
    /**
     * @private
     * @param {?} extension
     * @param {?=} allowedExtensions
     * @return {?}
     */
    isAllowedExtension(extension, allowedExtensions = []) {
        return allowedExtensions.some((/**
         * @param {?} ext
         * @return {?}
         */
        ext => ext.toLowerCase() === extension));
    }
    /**
     * @private
     * @param {?=} restrictions
     * @return {?}
     */
    setAllowedExtensions(restrictions = {}) {
        /** @type {?} */
        const _allowedExtensions = restrictions.allowedExtensions || [];
        this.allowedExtensions = _allowedExtensions.join(',');
    }
    /**
     * @private
     * @param {?} newFile
     * @param {?} files
     * @return {?}
     */
    updateExistsFileInFiles(newFile, files) {
        /** @type {?} */
        const fileIndex = files.findIndex((/**
         * @param {?} currentFile
         * @return {?}
         */
        currentFile => newFile.name === currentFile.name && currentFile.status !== ThfUploadStatus.Uploaded));
        if (fileIndex !== -1) {
            files.splice(fileIndex, 1, newFile);
        }
        return files;
    }
}
ThfUploadBaseComponent.propDecorators = {
    hideSelectButton: [{ type: Input, args: ['t-hide-select-button',] }],
    hideSendButton: [{ type: Input, args: ['t-hide-send-button',] }],
    label: [{ type: Input, args: ['t-label',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    help: [{ type: Input, args: ['t-help',] }],
    url: [{ type: Input, args: ['t-url',] }],
    fileRestrictions: [{ type: Input, args: ['t-restrictions',] }],
    name: [{ type: Input, args: ['name',] }],
    formField: [{ type: Input, args: ['t-form-field',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    autoUpload: [{ type: Input, args: ['t-auto-upload',] }],
    isMultiple: [{ type: Input, args: ['t-multiple',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    required: [{ type: Input, args: ['t-required',] }],
    onUpload: [{ type: Output, args: ['t-upload',] }],
    onError: [{ type: Output, args: ['t-error',] }],
    onSuccess: [{ type: Output, args: ['t-success',] }],
    ngModelChange: [{ type: Output, args: ['ngModelChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfUploadBaseService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.formField = 'files';
        this.requests = [];
    }
    /**
     * Método responsável por enviar os arquivos ao servidor, conforme o parâmetro URL.
     *
     * @param {?} url URL da requisição a ser efetuada.
     * @param {?} files Arquivos a serem enviados.
     * @param {?} tOnUpload Função a ser executada quando o arquivo for enviado ao servidor.
     * @param {?} uploadCallback Função que será executada enquanto os arquivos estiverem sendo enviados.
     * @param {?} successCallback Função a ser executada quando a requisição for efetuada com sucesso.
     * @param {?} errorCallback Função a ser executada quando a requisição foi efetuada com sucesso.
     * @return {?}
     */
    upload(url, files, tOnUpload, uploadCallback, successCallback, errorCallback) {
        /** @type {?} */
        const filesLength = files.length;
        /** @type {?} */
        const uploadEvent = {
            data: {},
            file: null
        };
        for (let i = 0; i < filesLength; i++) {
            /** @type {?} */
            const formData = new FormData();
            /** @type {?} */
            const file = files[i];
            /** @type {?} */
            const fileName = file.rawFile.name;
            formData.append(this.formField, file.rawFile, fileName);
            // Função upload, onde o desenvolvedor pode enviar dados para a requisição.
            if (tOnUpload) {
                uploadEvent['file'] = file;
                tOnUpload.emit(uploadEvent);
                formData.append('data', JSON.stringify(uploadEvent.data));
            }
            this.sendFile(url, file, formData, uploadCallback, successCallback, errorCallback);
        }
    }
    /**
     * @param {?} url
     * @param {?} file
     * @param {?} formData
     * @param {?} uploadCallback
     * @param {?} successCallback
     * @param {?} errorCallback
     * @return {?}
     */
    sendFile(url, file, formData, uploadCallback, successCallback, errorCallback) {
        /** @type {?} */
        const request = this.getRequest(url, formData).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (event.type === HttpEventType.UploadProgress) {
                this.addRequest(file, request);
                /** @type {?} */
                const percentDone = Math.round(100 * event.loaded / event.total);
                uploadCallback(file, percentDone);
            }
            else if (event instanceof HttpResponse) {
                // Sucesso, arquivos enviados.
                successCallback(file, event);
            }
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            errorCallback(file, err);
        }));
    }
    /**
     * @param {?} url
     * @param {?} formData
     * @return {?}
     */
    getRequest(url, formData) {
        /** @type {?} */
        const req = new HttpRequest('POST', url, formData, {
            reportProgress: true
        });
        return this.http.request(req);
    }
    /**
     * @param {?} file
     * @param {?} callback
     * @return {?}
     */
    stopRequestByFile(file, callback) {
        /** @type {?} */
        const requestObj = this.requests.find((/**
         * @param {?} req
         * @return {?}
         */
        req => {
            return req.file.uid === file.uid;
        }));
        if (requestObj) {
            /** @type {?} */
            const request = requestObj.request;
            request.unsubscribe();
            this.removeRequest(requestObj);
            callback();
        }
    }
    /**
     * @param {?} requestObj
     * @return {?}
     */
    removeRequest(requestObj) {
        /** @type {?} */
        const index = this.requests.indexOf(requestObj);
        this.requests.splice(index, 1);
    }
    /**
     * @param {?} file
     * @param {?} request
     * @return {?}
     */
    addRequest(file, request) {
        /** @type {?} */
        const hasRequest = this.requests.some((/**
         * @param {?} req
         * @return {?}
         */
        req => {
            return req.file.uid === file.uid;
        }));
        if (!hasRequest) {
            this.requests.push({ file, request });
        }
    }
}
ThfUploadBaseService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfUploadBaseService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfUploadService extends ThfUploadBaseService {
}
ThfUploadService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfUploadBaseComponent
 *
 * \@example
 *
 * <example name="thf-upload-basic" title="Totvs Upload Basic">
 *   <file name="sample-thf-upload-basic/sample-thf-upload-basic.component.html"> </file>
 *   <file name="sample-thf-upload-basic/sample-thf-upload-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-upload-labs" title="Totvs Upload Labs">
 *   <file name="sample-thf-upload-labs/sample-thf-upload-labs.component.html"> </file>
 *   <file name="sample-thf-upload-labs/sample-thf-upload-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-upload-resume" title="Totvs Upload - Resume">
 *   <file name="sample-thf-upload-resume/sample-thf-upload-resume.component.html"> </file>
 *   <file name="sample-thf-upload-resume/sample-thf-upload-resume.component.ts"> </file>
 * </example>
 *
 * <example name="thf-upload-rs" title="Totvs Upload - Realize & Show">
 *   <file name="sample-thf-upload-rs/sample-thf-upload-rs.component.html"> </file>
 *   <file name="sample-thf-upload-rs/sample-thf-upload-rs.component.ts"> </file>
 * </example>
 */
class ThfUploadComponent extends ThfUploadBaseComponent {
    /**
     * @param {?} elementRef
     * @param {?} uploadService
     */
    constructor(elementRef, uploadService) {
        super(uploadService);
        this.elementRef = elementRef;
        this.calledByCleanInputValue = false;
    }
    /**
     * @return {?}
     */
    get displaySendButton() {
        /** @type {?} */
        const currentFiles = this.currentFiles || [];
        return !this.hideSendButton && !this.autoUpload && (currentFiles.length > 0 && this.hasFileNotUploaded);
    }
    /**
     * @return {?}
     */
    get hasFileNotUploaded() {
        if (Array.isArray(this.currentFiles)) {
            return this.currentFiles.some((/**
             * @param {?} file
             * @return {?}
             */
            file => file.status !== ThfUploadStatus.Uploaded));
        }
        return false;
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        /** @type {?} */
        const currentFiles = this.currentFiles || [];
        return this.hasAnyFileUploading(this.currentFiles) ||
            !this.url ||
            this.disabled ||
            this.isExceededFileLimit(currentFiles.length);
    }
    /**
     * Método responsável por **limpar** o(s) arquivo(s) selecionado(s).
     * @return {?}
     */
    clear() {
        this.currentFiles = undefined;
        this.updateModel([]);
        this.cleanInputValue();
    }
    // Função disparada ao selecionar algum arquivo.
    /**
     * @param {?} event
     * @return {?}
     */
    onFileChange(event) {
        // necessario este tratamento quando para IE, pois nele o change é disparado quando o campo é limpado também
        if (this.calledByCleanInputValue) {
            this.calledByCleanInputValue = false;
            return event.preventDefault();
        }
        /** @type {?} */
        const files = event.target.files;
        this.currentFiles = this.currentFiles || [];
        this.currentFiles = this.parseFiles(files);
        this.updateModel([...this.currentFiles]);
        if (this.autoUpload) {
            this.uploadFiles(this.currentFiles);
        }
        this.cleanInputValue();
    }
    // Remove o arquivo passado por parametro da lista dos arquivos correntes.
    /**
     * @param {?} file
     * @return {?}
     */
    removeFile(file) {
        /** @type {?} */
        const index = this.currentFiles.indexOf(file);
        this.currentFiles.splice(index, 1);
        this.updateModel([...this.currentFiles]);
    }
    /**
     * Método responsável por **abrir** a janela para seleção de arquivo(s).
     * @return {?}
     */
    selectFiles() {
        this.calledByCleanInputValue = false;
        this.inputFile.nativeElement.click();
    }
    /**
     * Método responsável por **enviar** o(s) arquivo(s) selecionado(s).
     * @return {?}
     */
    sendFiles() {
        if (this.currentFiles && this.currentFiles.length) {
            this.uploadFiles(this.currentFiles);
        }
    }
    // Retorna o tamanho do arquivo em KBytes.
    /**
     * @protected
     * @param {?} size
     * @return {?}
     */
    getFileSize(size) {
        /** @type {?} */
        let kbSize = 0;
        if (size) {
            kbSize = Math.ceil(size / 1024);
        }
        return `${kbSize} KB`;
    }
    // Retorna o thf-icon de acordo com o status do arquivo.
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    getThfIcon(file) {
        switch (file.status) {
            case ThfUploadStatus.Uploaded:
                return 'thf-icon-ok';
            case ThfUploadStatus.Error:
                return 'thf-icon-close';
            case ThfUploadStatus.None:
                return 'thf-icon-info';
            case ThfUploadStatus.Uploading:
            default:
                return '';
        }
    }
    // Verifica se existe algum arquivo sendo enviado ao serviço.
    /**
     * @protected
     * @param {?} files
     * @return {?}
     */
    hasAnyFileUploading(files) {
        if (files && files.length) {
            return files.some((/**
             * @param {?} file
             * @return {?}
             */
            file => file.status === ThfUploadStatus.Uploading));
        }
        return false;
    }
    // Valida se o status passado por parâmetro é igual ao status do arquivo.
    /**
     * @protected
     * @param {?} status
     * @param {?} file
     * @return {?}
     */
    isStatusFile(status, file) {
        return file.status === ThfUploadStatus[status];
    }
    // Caso o componente estiver no modo AutoUpload, o arquivo também será removido da lista.
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    stopUpload(file) {
        this.uploadService.stopRequestByFile(file, (/**
         * @return {?}
         */
        () => {
            if (this.autoUpload) {
                this.removeFile(file);
            }
            else {
                this.stopUploadHandler(file);
            }
        }));
    }
    // Envia os arquivos passados por parâmetro, exceto os que já foram enviados ao serviço.
    /**
     * @protected
     * @param {?} files
     * @return {?}
     */
    uploadFiles(files) {
        /** @type {?} */
        const filesFiltered = files.filter((/**
         * @param {?} file
         * @return {?}
         */
        file => {
            return file.status !== ThfUploadStatus.Uploaded;
        }));
        this.uploadService.upload(this.url, filesFiltered, this.onUpload, (/**
         * @param {?} file
         * @param {?} percent
         * @return {?}
         */
        (file, percent) => {
            // UPLOADING
            this.uploadingHandler(file, percent);
        }), (/**
         * @param {?} file
         * @param {?} eventResponse
         * @return {?}
         */
        (file, eventResponse) => {
            // SUCCESS
            this.successHandler(file);
            this.onSuccess.emit(eventResponse);
        }), (/**
         * @param {?} file
         * @param {?} eventError
         * @return {?}
         */
        (file, eventError) => {
            // Error
            this.errorHandler(file);
            this.onError.emit(eventError);
        }));
    }
    // Atualiza a classe da div, que conter a classe 'thf-upload-filename', para 'thf-upload-filename-loading'.
    /**
     * @private
     * @param {?} uid
     * @return {?}
     */
    addFileNameClass(uid) {
        /** @type {?} */
        const divStatus = this.elementRef.nativeElement.querySelector(`div[id='${uid}'].thf-upload-progress`);
        /** @type {?} */
        const fileNameDiv = divStatus.querySelector('.thf-upload-filename');
        fileNameDiv.classList.add('thf-upload-filename-loading');
    }
    /**
     * @private
     * @return {?}
     */
    cleanInputValue() {
        this.calledByCleanInputValue = true;
        this.inputFile.nativeElement.value = '';
    }
    // Função disparada quando é retornado um erro no envio do arquivo.
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    errorHandler(file) {
        file.status = ThfUploadStatus.Error;
        this.setProgressStatus(file.uid, 0, false);
        this.setUploadStatus(file, 'thf-upload-progress-error', 100);
    }
    // Remove a classe 'thf-upload-filename-loading' da div que conter a classe 'thf-upload-filename'.
    /**
     * @private
     * @param {?} uid
     * @return {?}
     */
    removeFileNameClass(uid) {
        /** @type {?} */
        const divStatus = this.elementRef.nativeElement.querySelector(`div[id='${uid}'].thf-upload-progress`);
        /** @type {?} */
        const fileNameDiv = divStatus.querySelector('.thf-upload-filename');
        fileNameDiv.classList.remove('thf-upload-filename-loading');
    }
    // Atualiza o status do progresso do envio do arquivo.
    /**
     * @private
     * @param {?} uid
     * @param {?} percent
     * @param {?} isShow
     * @return {?}
     */
    setProgressStatus(uid, percent, isShow) {
        /** @type {?} */
        const divStatus = this.elementRef.nativeElement.querySelector(`div[id='${uid}'].thf-upload-progress`);
        /** @type {?} */
        const divProgress = divStatus.querySelector('.thf-upload-progress-status');
        /** @type {?} */
        const isDisplay = isShow ? 'block' : 'none';
        divProgress.setAttribute('style', `display: ${isDisplay};`);
        divProgress.setAttribute('style', `width: ${percent}%;`);
    }
    // Atualiza o status do envio de arquivos.
    /**
     * @private
     * @param {?} file
     * @param {?} className
     * @param {?} percent
     * @return {?}
     */
    setUploadStatus(file, className, percent) {
        /** @type {?} */
        const uid = file.uid;
        /** @type {?} */
        const divStatus = this.elementRef.nativeElement.querySelector(`div[id='${uid}'].thf-upload-progress`);
        divStatus.classList.remove('thf-upload-progress-error', 'thf-upload-progress-success');
        divStatus.classList.add(className);
        if (percent > 5 && file.status !== ThfUploadStatus.None) {
            this.addFileNameClass(uid);
        }
    }
    // Função disparada ao parar um envio de arquivo.
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    stopUploadHandler(file) {
        file.status = ThfUploadStatus.None;
        this.removeFileNameClass(file.uid);
        this.setProgressStatus(file.uid, 0, false);
        this.setUploadStatus(file, 'thf-upload-progress', 100);
    }
    // Função disparada quando o envio é realizado com sucesso.
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    successHandler(file) {
        file.status = ThfUploadStatus.Uploaded;
        this.setProgressStatus(file.uid, 0, false);
        this.setUploadStatus(file, 'thf-upload-progress-success', 100);
    }
    // Atualiza o ngModel para os arquivos passados por parâmetro.
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    updateModel(files) {
        this.onModelChange ? this.onModelChange(files) : this.ngModelChange.emit(files);
    }
    // Função disparada enquanto o arquivo está sendo enviado ao serviço.
    /**
     * @private
     * @param {?} file
     * @param {?} percent
     * @return {?}
     */
    uploadingHandler(file, percent) {
        file.status = ThfUploadStatus.Uploading;
        this.setProgressStatus(file.uid, percent, true);
        this.setUploadStatus(file, 'thf-upload-progress', percent);
    }
}
ThfUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-upload',
                template: "<thf-field-container\n  [t-label]=\"label\"\n  [t-help]=\"help\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-upload\">\n    <input\n      #inputFile\n      class=\"thf-upload-input\"\n      type=\"file\"\n      [accept]=\"allowedExtensions\"\n      [attr.name]=\"name\"\n      [disabled]=\"isDisabled\"\n      [multiple]=\"isMultiple\"\n      [required]=\"required\"\n      (change)=\"onFileChange($event)\">\n\n    <thf-button\n      *ngIf=\"!hideSelectButton\"\n      class=\"thf-upload-button\"\n      for=\"file\"\n      [t-disabled]=\"isDisabled\"\n      [t-label]=\"literals.selectFile\"\n      (t-click)=\"selectFiles()\">\n    </thf-button>\n\n    <div class=\"thf-upload-progress\" *ngFor=\"let file of currentFiles\" [id]=\"file.uid\">\n      <div class=\"thf-upload-progress-status\"></div>\n      <div class=\"thf-upload-filename-foreground\">\n\n        <div class=\"thf-upload-filename\">\n          <span class=\"thf-icon {{ getThfIcon(file) }}\"></span> {{ file.name }} - {{ getFileSize(file.size) }}\n        </div>\n\n        <div class=\"thf-upload-group-actions\">\n          <span\n            *ngIf=\"isStatusFile('None', file) || isStatusFile('Error', file)\"\n            class=\"thf-upload-action\"\n            (click)=\"removeFile(file)\">\n            {{ literals.deleteFile }}\n          </span>\n\n          <span\n            *ngIf=\"isStatusFile('Uploading', file)\"\n            class=\"thf-upload-action\"\n            (click)=\"stopUpload(file)\">\n            {{ literals.cancel }}\n          </span>\n\n          <span\n            *ngIf=\"isStatusFile('Error', file)\"\n            class=\"thf-upload-action\"\n            (click)=\"uploadFiles([file])\">\n\n            {{ literals.tryAgain }}\n          </span>\n        </div>\n\n      </div>\n    </div>\n\n    <thf-button\n      *ngIf=\"displaySendButton\"\n      t-type=\"primary\"\n      [t-disabled]=\"hasAnyFileUploading(currentFiles)\"\n      [t-label]=\"literals.startSending\"\n      (t-click)=\"uploadFiles(currentFiles)\">\n    </thf-button>\n\n  </div>\n\n</thf-field-container>\n",
                providers: [
                    ThfUploadService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfUploadComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfUploadComponent)),
                        multi: true,
                    }
                ]
            }] }
];
/** @nocollapse */
ThfUploadComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ThfUploadService }
];
ThfUploadComponent.propDecorators = {
    inputFile: [{ type: ViewChild, args: ['inputFile', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfInputBaseComponent
 *
 * \@description
 *
 * thf-url é um input específico para receber URL, com o pattern já configurado.
 *
 * \@example
 *
 * <example name="thf-url-basic" title="Totvs Url Basic">
 *   <file name="sample-thf-url-basic/sample-thf-url-basic.component.html"> </file>
 *   <file name="sample-thf-url-basic/sample-thf-url-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-url-labs" title="Totvs Url Labs">
 *   <file name="sample-thf-url-labs/sample-thf-url-labs.component.html"> </file>
 *   <file name="sample-thf-url-labs/sample-thf-url-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-url-shortener" title="Totvs Url - Shortener">
 *   <file name="sample-thf-url-shortener/sample-thf-url-shortener.component.html"> </file>
 *   <file name="sample-thf-url-shortener/sample-thf-url-shortener.component.ts"> </file>
 * </example>
 *
 */
class ThfUrlComponent extends ThfInputGeneric {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
        this.icon = 'thf-icon-world';
        this.maxlength = 254;
        this.type = 'url';
        this.pattern = '^((https|http):\\/\\/)?' + // protocol
            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // domain name
            '((\\d{1,3}\\.){3}\\d{1,3}))' + // OR ip (v4) address
            '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' + // port and path
            '(\\?[;&a-z\\d%_.~+=-]*)?' + // query string
            '(\\#[-a-z\\d_]*)?$';
        this.mask = '';
        this.listener = this.validateClassesForPattern.bind(this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Se não tem ngModel ou reactive form adiciona validação com classes css
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (!this.onChangePropagate) {
                this.inputEl.nativeElement.addEventListener('keyup', this.listener);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (!this.onChangePropagate) {
            this.inputEl.nativeElement.removeEventListener('keyup', this.listener);
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    extraValidation(c) {
        return null;
    }
}
ThfUrlComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-url',
                template: "<thf-field-container\n  [t-help]=\"help\"\n  [t-label]=\"label\"\n  [t-optional]=\"!required && optional\">\n\n  <div class=\"thf-field-container-content\">\n    <div *ngIf=\"icon\" class=\"thf-field-icon-container-left\">\n      <span class=\"thf-icon thf-field-icon {{ icon }}\" [class.thf-field-icon-disabled]=\"disabled\"></span>\n    </div>\n\n    <input #inp\n      class=\"thf-input\"\n      [attr.name]=\"name\"\n      [class.thf-input-icon-left]=\"icon\"\n      [class.thf-input-icon-right]=\"clean\"\n      [disabled]=\"disabled\"\n      [placeholder]=\"placeholder\"\n      [readonly]=\"readonly\"\n      [required]=\"required\"\n      [type]=\"type\"\n      (blur)=\"eventOnBlur($event)\"\n      (click)=\"eventOnClick($event)\"\n      (focus)=\"eventOnFocus($event)\"\n      (input)=\"eventOnInput($event)\">\n\n    <div class=\"thf-field-icon-container-right\">\n      <thf-clean [t-element-ref]=\"inputEl\" (t-change-event)=\"clear($event)\"></thf-clean>\n    </div>\n  </div>\n\n  <thf-field-container-bottom\n    [t-error-pattern]=\"getErrorPattern()\">\n  </thf-field-container-bottom>\n\n</thf-field-container>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfUrlComponent)),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ThfUrlComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
ThfUrlComponent.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo dos componentes thf-combo, thf-checkbox-group, thf-datepicker, thf-datepicker-range, thf-email, thf-input, thf-lookup,
 * thf-number, thf-multiselect, thf-password, thf-radio-group, thf-select, thf-switch, thf-textarea, thf-upload e thf-url.
 */
class ThfFieldModule {
}
ThfFieldModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    ThfButtonModule,
                    ThfDisclaimerModule,
                    ThfLoadingModule,
                    ThfModalModule,
                    ThfTableModule,
                    ThfButtonGroupModule
                ],
                exports: [
                    ThfCheckboxGroupComponent,
                    ThfCleanComponent,
                    ThfComboComponent,
                    ThfDecimalComponent,
                    ThfDatepickerComponent,
                    ThfDatepickerRangeComponent,
                    ThfEmailComponent,
                    ThfInputComponent,
                    ThfLoginComponent,
                    ThfLookupComponent,
                    ThfLookupModalComponent,
                    ThfMultiselectComponent,
                    ThfNumberComponent,
                    ThfPasswordComponent,
                    ThfRadioGroupComponent,
                    ThfRichTextComponent,
                    ThfSelectComponent,
                    ThfSelectOptionTemplateDirective,
                    ThfSwitchComponent,
                    ThfTextareaComponent,
                    ThfUploadComponent,
                    ThfUrlComponent
                ],
                declarations: [
                    ThfCalendarComponent$1,
                    ThfCheckboxGroupComponent,
                    ThfCleanComponent,
                    ThfComboComponent,
                    ThfDecimalComponent,
                    ThfDatepickerComponent,
                    ThfDatepickerRangeComponent,
                    ThfEmailComponent,
                    ThfFieldContainerComponent,
                    ThfFieldContainerBottomComponent,
                    ThfInputComponent,
                    ThfLoginComponent,
                    ThfLookupComponent,
                    ThfLookupModalComponent,
                    ThfMultiselectComponent,
                    ThfMultiselectDropdownComponent,
                    ThfMultiselectItemComponent,
                    ThfMultiselectSearchComponent,
                    ThfNumberComponent,
                    ThfPasswordComponent,
                    ThfRadioGroupComponent,
                    ThfRichTextBodyComponent,
                    ThfRichTextComponent,
                    ThfRichTextToolbarComponent,
                    ThfSelectComponent,
                    ThfSelectOptionTemplateDirective,
                    ThfSwitchComponent,
                    ThfTextareaComponent,
                    ThfUploadComponent,
                    ThfUrlComponent
                ],
                providers: [],
                entryComponents: [
                    ThfCalendarComponent$1,
                    ThfLookupModalComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfInfoOrientation = {
    /** O valor será exibido na horizontal, ao lado direito em relação ao label. */
    Horizontal: 'horizontal',
    /** Exibe o valor na vertical, ou seja, abaixo do label. */
    Vertical: 'vertical',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfInfoOrientationDefault = ThfInfoOrientation.Vertical;
class ThfInfoBaseComponent {
    constructor() {
        this._orientation = thfInfoOrientationDefault;
        this.thfInfoOrientation = ThfInfoOrientation;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Quantidade de [colunas](/guides/grid-system) usadas para a exibição da `t-label` quando o componente for
     * utilizado na orientação horizontal.
     *
     * Valores válidos:
     *  - `[1 .. 11]`
     *
     * > A propriedade `t-value` recebe o número de colunas restantes, por exemplo, se definido 3 colunas a mesma assume 9 colunas.
     * @param {?} value
     * @return {?}
     */
    set labelSize(value) {
        if (isNaN(parseInt((/** @type {?} */ (value)), 10))) {
            this._labelSize = undefined;
        }
        else {
            value = parseInt((/** @type {?} */ (value)), 10);
            this._labelSize = (value < 1 || value > 11) ? undefined : value;
        }
    }
    /**
     * @return {?}
     */
    get labelSize() {
        return this._labelSize;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define o layout de exibição.
     *
     * > Quando definido na horizontal, pode-se utilizar a propriedade `t-label-size` para um maior controle das informações exibidas.
     *
     * \@default `vertical`
     * @param {?} value
     * @return {?}
     */
    set orientation(value) {
        this._orientation = ((/** @type {?} */ (Object))).values(ThfInfoOrientation).includes(value) ? value : thfInfoOrientationDefault;
    }
    /**
     * @return {?}
     */
    get orientation() {
        return this._orientation;
    }
}
ThfInfoBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    labelSize: [{ type: Input, args: ['t-label-size',] }],
    orientation: [{ type: Input, args: ['t-orientation',] }],
    value: [{ type: Input, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfInfoBaseComponent
 *
 * \@description
 *
 * Este componente tem como objetivo renderizar valores na tela no estilo label na parte superior e
 * valor na parte inferior. Facilita a exibição de dados pois vem com layout padrão Totvs.
 *
 * \@example
 *
 * <example name="thf-info-basic" title="Totvs Info Basic">
 *  <file name="sample-thf-info-basic/sample-thf-info-basic.component.html"> </file>
 *  <file name="sample-thf-info-basic/sample-thf-info-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-info-labs" title="Totvs Info Labs">
 *  <file name="sample-thf-info-labs/sample-thf-info-labs.component.html"> </file>
 *  <file name="sample-thf-info-labs/sample-thf-info-labs.component.ts"> </file>
 * </example>
 */
class ThfInfoComponent extends ThfInfoBaseComponent {
}
ThfInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-info',
                template: "<div class=\"thf-info\" [class.thf-row]=\"orientation === thfInfoOrientation.Horizontal && labelSize\">\n  <div class=\"thf-info-container-title\"\n    [ngClass]=\"labelSize && orientation === thfInfoOrientation.Horizontal ? 'thf-sm-' + labelSize : ''\"\n    [class.thf-info-label-horizontal]=\"orientation === thfInfoOrientation.Horizontal\"\n    [class.thf-text-nowrap]=\"orientation === thfInfoOrientation.Horizontal && !labelSize\">\n    <span class=\"thf-info-label\">\n      {{ orientation === thfInfoOrientation.Horizontal ? label + ':' : label }}\n    </span>\n  </div>\n\n  <div [ngClass]=\"labelSize && orientation === thfInfoOrientation.Horizontal ? 'thf-sm-' + (12 - labelSize) : ''\"\n    [class.thf-info-container-content]=\"orientation !== thfInfoOrientation.Horizontal\"\n    [class.thf-info-value-horizontal]=\"orientation === thfInfoOrientation.Horizontal\">\n    <span class=\"thf-info-value\">{{ value }}</span>\n  </div>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-info.
 */
class ThfInfoModule {
}
ThfInfoModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ThfInfoComponent
                ],
                exports: [ThfInfoComponent],
                providers: [],
                schemas: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfTagIcon = {
    /** Ícone fechar */
    Danger: 'close',
    /** Ícone de informação */
    Info: 'info',
    /** Ícone que representa confirmação */
    Success: 'ok',
    /** Ícone com ponto de exclamação */
    Warning: 'warning',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfTagOrientation = {
    /** A tag será exibida na horizontal, ao lado direito em relação ao label. */
    Horizontal: 'horizontal',
    /** Exibe a tag na vertical, ou seja, abaixo do label. */
    Vertical: 'vertical',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfTagType = {
    /** Erro, perigo, problema ou aviso crítico. */
    Danger: 'danger',
    /** Informativo ou explicativo. */
    Info: 'info',
    /** Confirmação, resultados positivos ou êxito */
    Success: 'success',
    /** Aviso ou advertência. */
    Warning: 'warning',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfTagOrientationDefault = ThfTagOrientation.Vertical;
/** @type {?} */
const thfTagTypeDefault = ThfTagType.Info;
/**
 * \@description
 *
 * Este componente apresenta um valor em um marcador colorido que pode conter ícone e *label*, as cores são definidas conforme o tipo
 * escolhido.
 * Seu uso é indicado para informações que necessitam de destaque em forma de marcação.
 */
class ThfTagBaseComponent {
    constructor() {
        this._orientation = thfTagOrientationDefault;
        this._type = thfTagTypeDefault;
        this.thfTagOrientation = ThfTagOrientation;
        /**
         * \@optional
         *
         * \@description
         *
         * Ação que será executada quando o usuário clicar sobre o `thf-tag`
         * e que receberá como parâmetro um objeto contendo o valor e tipo de tag.
         */
        this.click = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Apresenta um ícone na tag conforme o tipo:
     * - `danger`: <span class="thf-icon thf-icon-close"></span>
     * - `info`: <span class="thf-icon thf-icon-info"></span>
     * - `success`: <span class="thf-icon thf-icon-ok"></span>
     * - `warning`: <span class="thf-icon thf-icon-warning"></span>
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set icon(value) {
        this._icon = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define o layout de exibição.
     *
     * \@default `vertical`
     * @param {?} value
     * @return {?}
     */
    set orientation(value) {
        this._orientation = ((/** @type {?} */ (Object))).values(ThfTagOrientation).includes(value) ? value : thfTagOrientationDefault;
    }
    /**
     * @return {?}
     */
    get orientation() {
        return this._orientation;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define o tipo e determina a cor do `thf-tag`.
     *
     * Valores válidos:
     *  - `success`: cor verde utilizada para simbolizar sucesso ou êxito.
     *  - `warning`: cor amarela que representa aviso ou advertência.
     *  - `danger`: cor vermelha para erro ou aviso crítico.
     *  - `info`: cor cinza escuro que caracteriza conteúdo informativo.
     *
     * \@default `info`
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = ((/** @type {?} */ (Object))).values(ThfTagType).includes(value) ? value : thfTagTypeDefault;
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @return {?}
     */
    get iconFromType() {
        switch (this.type) {
            case ThfTagType.Danger: return ThfTagIcon.Danger;
            case ThfTagType.Info: return ThfTagIcon.Info;
            case ThfTagType.Success: return ThfTagIcon.Success;
            case ThfTagType.Warning: return ThfTagIcon.Warning;
        }
    }
}
ThfTagBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    icon: [{ type: Input, args: ['t-icon',] }],
    orientation: [{ type: Input, args: ['t-orientation',] }],
    type: [{ type: Input, args: ['t-type',] }],
    value: [{ type: Input, args: ['t-value',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfTagBaseComponent
 *
 * \@example
 *
 * <example name="thf-tag-basic" title="Totvs Tag Basic">
 *  <file name="sample-thf-tag-basic/sample-thf-tag-basic.component.html"> </file>
 *  <file name="sample-thf-tag-basic/sample-thf-tag-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tag-labs" title="Totvs Tag Labs">
 *  <file name="sample-thf-tag-labs/sample-thf-tag-labs.component.html"> </file>
 *  <file name="sample-thf-tag-labs/sample-thf-tag-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tag-bank-account" title="Totvs Tag - Bank Account">
 *  <file name="sample-thf-tag-bank-account/sample-thf-tag-bank-account.component.html"> </file>
 *  <file name="sample-thf-tag-bank-account/sample-thf-tag-bank-account.component.ts"> </file>
 * </example>
 */
class ThfTagComponent extends ThfTagBaseComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isClickable = this.click.observers.length > 0;
    }
    /**
     * @return {?}
     */
    onClick() {
        /** @type {?} */
        const submittedTagItem = { value: this.value, type: this.type };
        this.click.emit(submittedTagItem);
    }
}
ThfTagComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-tag',
                template: "<div class=\"thf-tag-container\" [class.thf-tag-container-horizontal]=\"orientation === thfTagOrientation.Horizontal\">\n  <div *ngIf=\"label\" class=\"thf-tag-title thf-text-nowrap\">\n    <span class=\"thf-tag-label\">{{ orientation === thfTagOrientation.Horizontal ? label + ':' : label }}</span>\n  </div>\n  <div \n    class=\"thf-tag thf-tag-{{ type }}\" \n    [ngClass]=\"{'thf-clickable': isClickable}\"\n    (click)=\"onClick()\">\n    <span *ngIf=\"icon\" class=\"thf-icon thf-icon-{{ iconFromType }}\"></span>\n    <span class=\"thf-tag-value\">{{value}}</span>\n  </div>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente `thf-tag`.
 */
class ThfTagModule {
}
ThfTagModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ThfTagComponent
                ],
                exports: [
                    ThfTagComponent
                ],
                providers: [],
                schemas: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 *
 * Componente para criação de formulários dinâmicos a partir de uma lista de objetos.
 *
 * Também é possível verificar se o formulário está válido e informar valores para a exibição de informações.
 *
 * > Temos uma ferramenta para criação de formulários, onde é possível inicializá-lo através de um JSON.
 * [**Veja aqui**](tools/dynamic-form).
 */
class ThfDynamicFormBaseComponent {
    constructor() {
        this._groupForm = false;
        /**
         * \@optional
         *
         * \@description
         *
         * Na inicialização do componente será repassado o objeto de formulário utilizado no componente,
         * podendo ser utilizado para validações e/ou detecção de mudança dos valores.
         *
         * Portanto existem duas maneiras de recuperar o formulário,
         * através de *template reference* e através do *output*, veja os exemplos abaixo:
         *
         * > *template reference*
         *
         * ```html
         *  <thf-dynamic-form #dynamicForm>
         *  </thf-dynamic-form>
         *
         *  <thf-button t-label="Adicionar" [t-disabled]="dynamicForm?.form.invalid">
         *  </thf-button>
         *
         * ```
         *
         * > *Output*
         *
         * ```html
         *  ...
         *  <thf-dynamic-form (t-form)="getForm($event)">
         *  </thf-dynamic-form>
         *
         *  <thf-button t-label="Adicionar" [t-disabled]="dynamicForm?.invalid">
         *  </thf-button>
         *  ...
         *
         * ```
         *
         * ```ts
         *  ...
         *
         *  export class AppComponent {
         *
         *    dynamicForm: NgForm;
         *
         *    getForm(form: NgForm) {
         *      this.dynamicForm = form;
         *    }
         *
         *  }
         * ```
         *
         * > Caso a propriedade `t-group-form` for verdadeira não será repassado o formulário, pois o mesmo utilizará
         * o formulário pai.
         */
        this.formOutput = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     * Ao informar esta propriedade, o componente passará a utilizar o formulário pai para criar os `FormControl`
     * e com isso é possível recuperar o valor do formulário e suas validações a partir do formulário pai.
     *
     * ```html
     * <form #parentForm="ngForm">
     *
     *   <thf-dynamic-form t-group-form [t-fields]="fields"></thf-dynamic-form>
     *
     *  <thf-button t-label="Adicionar" [t-disabled]="parentForm.invalid"></thf-button>
     * </form>
     * ```
     * @param {?} value
     * @return {?}
     */
    set groupForm(value) {
        this._groupForm = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get groupForm() {
        return this._groupForm;
    }
}
ThfDynamicFormBaseComponent.propDecorators = {
    fields: [{ type: Input, args: ['t-fields',] }],
    value: [{ type: Input, args: ['t-value',] }],
    formOutput: [{ type: Output, args: ['t-form',] }],
    groupForm: [{ type: Input, args: ['t-group-form',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfDynamicFormBaseComponent
 *
 * \@example
 *
 * <example name="thf-dynamic-form-basic" title="Totvs Dynamic Form Basic">
 *  <file name="sample-thf-dynamic-form-basic/sample-thf-dynamic-form-basic.component.html"> </file>
 *  <file name="sample-thf-dynamic-form-basic/sample-thf-dynamic-form-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-dynamic-form-register" title="Totvs Dynamic Form - Register">
 *  <file name="sample-thf-dynamic-form-register/sample-thf-dynamic-form-register.component.html"> </file>
 *  <file name="sample-thf-dynamic-form-register/sample-thf-dynamic-form-register.component.ts"> </file>
 * </example>
 */
class ThfDynamicFormComponent extends ThfDynamicFormBaseComponent {
    /**
     * @param {?} value
     * @return {?}
     */
    set form(value) {
        // necessario para nao ocorrer o ExpressionChangedAfterItHasBeenCheckedError
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._form = value;
            this.emitForm();
        }));
    }
    /**
     * @return {?}
     */
    get form() {
        return this._form || (/** @type {?} */ ({}));
    }
    /**
     * @private
     * @return {?}
     */
    emitForm() {
        if (!this.groupForm && this.formOutput.observers.length) {
            this.formOutput.emit(this.form);
        }
    }
}
ThfDynamicFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-dynamic-form',
                template: "\n<ng-container *ngIf=\"groupForm; then reuseFormTemplate; else uniqueFormTemplate\"></ng-container>\n\n<ng-template #reuseFormTemplate>\n\n  <thf-dynamic-form-fields [t-fields]=\"fields\" [t-value]=\"value\"></thf-dynamic-form-fields>\n\n</ng-template>\n\n<ng-template #uniqueFormTemplate>\n\n  <form #dynamicForm=\"ngForm\">\n\n    <thf-dynamic-form-fields [t-fields]=\"fields\" [t-value]=\"value\"></thf-dynamic-form-fields>\n\n  </form>\n\n</ng-template>\n"
            }] }
];
ThfDynamicFormComponent.propDecorators = {
    form: [{ type: ViewChild, args: ['dynamicForm', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} smColumns
 * @param {?} mdColumns
 * @param {?} lgColumns
 * @param {?} xlColumns
 * @param {?} gridColumns
 * @return {?}
 */
function getGridColumnsClasses(smColumns, mdColumns, lgColumns, xlColumns, gridColumns) {
    /** @type {?} */
    const systemGrid = {
        sm: smColumns || gridColumns || 12,
        md: mdColumns || gridColumns || 6,
        lg: lgColumns || gridColumns || 4,
        xl: xlColumns || gridColumns || 3
    };
    return `thf-sm-${systemGrid.sm} thf-md-${systemGrid.md} thf-lg-${systemGrid.lg} thf-xl-${systemGrid.xl}`;
}
/**
 * @param {?} field
 * @return {?}
 */
function isVisibleField(field) {
    /** @type {?} */
    const containsVisible = 'visible' in field;
    return containsVisible ? field.visible : true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfDynamicFieldType = {
    /** Valor booleano. */
    Boolean: 'boolean',
    /** Valor numérico que contém casas decimais e milhar. */
    Currency: 'currency',
    /** Valor para data. */
    Date: 'date',
    /** Valor para data e hora. */
    DateTime: 'datetime',
    /** Utilizado para informar/exibir hora. */
    Time: 'time',
    /** Valor númerico. */
    Number: 'number',
    /** Texto. */
    String: 'string',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfDynamicFormFieldsBaseComponent {
    /**
     * @param {?} titleCasePipe
     */
    constructor(titleCasePipe) {
        this.titleCasePipe = titleCasePipe;
        this._value = {};
        this.visibleFields = [];
    }
    // array de objetos que implementam a interface ThfDynamicFormField, que serão exibidos no componente.
    /**
     * @param {?} value
     * @return {?}
     */
    set fields(value) {
        this._fields = Array.isArray(value) ? [...value] : [];
    }
    /**
     * @return {?}
     */
    get fields() {
        return this._fields;
    }
    // valor que será utilizado para iniciar valor no componente.
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value && isTypeof(value, 'object') ? value : {};
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @param {?} compareTo
     * @return {?}
     */
    compareTo(value, compareTo) {
        return value === compareTo;
    }
    // retorna um array com os objetos configurados e visiveis.
    /**
     * @protected
     * @return {?}
     */
    getVisibleFields() {
        /** @type {?} */
        const visibleFields = [];
        this.fields.forEach((/**
         * @param {?} field
         * @return {?}
         */
        field => {
            if (this.existsProperty(visibleFields, field.property)) {
                this.printError(`"thf-dynamic-form" property "${field.property}" está duplicado. Interface: ThfDynamicFormField.`);
                return;
            }
            if (!field['property']) {
                this.printError('"thf-dynamic-form" É obrigatório ser especificado um property.');
                return;
            }
            if (isVisibleField(field)) {
                visibleFields.push(this.createField(field));
            }
        }));
        return visibleFields;
    }
    // converte um array em string para um array de objetos que contem label e value.
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    convertOptions(options) {
        /** @type {?} */
        const everyOptionString = options.every((/**
         * @param {?} option
         * @return {?}
         */
        option => typeof option === 'string'));
        if (everyOptionString) {
            return options.map((/**
             * @param {?} value
             * @return {?}
             */
            value => ({ label: value, value })));
        }
        return options;
    }
    // cria um novo objeto com as classes de grid system, com control (tipo do componente) e label default.
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    createField(field) {
        /** @type {?} */
        const control = this.getComponentControl(field);
        /** @type {?} */
        const options = !!field.options ? this.convertOptions(field.options) : undefined;
        /** @type {?} */
        const componentClass = getGridColumnsClasses(field.gridSmColumns, field.gridMdColumns, field.gridLgColumns, field.gridXlColumns, field.gridColumns);
        return Object.assign({ label: this.titleCasePipe.transform(field.property) }, field, { componentClass,
            control,
            options });
    }
    /**
     * @private
     * @param {?} fields
     * @param {?} property
     * @return {?}
     */
    existsProperty(fields, property) {
        return fields.some((/**
         * @param {?} field
         * @return {?}
         */
        field => {
            return field.property === property;
        }));
    }
    // recupera o componente de acordo com algumas regras do field.
    /**
     * @private
     * @param {?=} field
     * @return {?}
     */
    getComponentControl(field = (/** @type {?} */ ({}))) {
        /** @type {?} */
        const type = field && field.type ? field.type.toLocaleLowerCase() : 'string';
        if (this.isNumberType(field, type)) {
            return 'number';
        }
        else if (this.isCurrencyType(field, type)) {
            return 'decimal';
        }
        else if (this.isSelect(field)) {
            return 'select';
        }
        else if (this.isRadioGroup(field)) {
            return 'radioGroup';
        }
        else if (this.isCheckboxGroup(field)) {
            return 'checkboxGroup';
        }
        else if (this.isMultiselect(field)) {
            return 'multiselect';
        }
        else if (this.compareTo(type, ThfDynamicFieldType.Boolean)) {
            return 'switch';
        }
        else if (this.compareTo(type, ThfDynamicFieldType.Date) || this.compareTo(type, ThfDynamicFieldType.DateTime)) {
            return 'datepicker';
        }
        else if (this.compareTo(type, ThfDynamicFieldType.Time)) {
            field.mask = field.mask || '99:99';
            return 'input';
        }
        else if (this.isCombo(field)) {
            return 'combo';
        }
        else if (this.isLookup(field)) {
            return 'lookup';
        }
        else if (this.isTextarea(field)) {
            return 'textarea';
        }
        else if (this.isPassword(field)) {
            return 'password';
        }
        return 'input';
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isCheckboxGroup(field) {
        const { optionsService, optionsMulti, options } = field;
        return !optionsService && optionsMulti && !!options && options.length <= 3;
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isCombo(field) {
        const { optionsService } = field;
        return !!optionsService && isTypeof(optionsService, 'string');
    }
    /**
     * @private
     * @param {?} field
     * @param {?} type
     * @return {?}
     */
    isCurrencyType(field, type) {
        const { mask, pattern } = field;
        return this.compareTo(type, ThfDynamicFieldType.Currency) && (!mask && !pattern);
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isLookup(field) {
        const { searchService } = field;
        return !!searchService && isTypeof(searchService, 'string');
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isMultiselect(field) {
        const { optionsService, optionsMulti, options } = field;
        return !optionsService && optionsMulti && !!options && options.length > 3;
    }
    /**
     * @private
     * @param {?} field
     * @param {?} type
     * @return {?}
     */
    isNumberType(field, type) {
        const { mask, pattern } = field;
        return this.compareTo(type, ThfDynamicFieldType.Number) && (!mask && !pattern);
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isPassword(field) {
        const { secret } = field;
        return secret;
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isRadioGroup(field) {
        const { optionsMulti, options } = field;
        return !optionsMulti && !!options && options.length <= 3;
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isSelect(field) {
        const { optionsMulti, options } = field;
        return !optionsMulti && !!options && options.length > 3;
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    isTextarea(field) {
        const { rows } = field;
        return rows && rows >= 3;
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    printError(error) {
        console.error(error);
    }
}
ThfDynamicFormFieldsBaseComponent.propDecorators = {
    fields: [{ type: Input, args: ['t-fields',] }],
    value: [{ type: Input, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente de criação dos campos dinâmicos.
 */
class ThfDynamicFormFieldsComponent extends ThfDynamicFormFieldsBaseComponent {
    /**
     * @param {?} titleCasePipe
     */
    constructor(titleCasePipe) {
        super(titleCasePipe);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.fields) {
            this.visibleFields = this.getVisibleFields();
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    trackBy(index) {
        return index;
    }
}
ThfDynamicFormFieldsComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-dynamic-form-fields',
                template: "<div class=\"thf-row\" *ngIf=\"visibleFields && visibleFields.length > 0\">\n  <ng-container *ngFor=\"let field of visibleFields; trackBy: trackBy\">\n\n    <thf-divider *ngIf=\"field?.divider?.trim()\" class=\"thf-sm-12\" [t-label]=\"field.divider\">\n    </thf-divider>\n\n    <thf-datepicker *ngIf=\"compareTo(field.control, 'datepicker')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      t-clean\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-max-date]=\"field.maxValue\"\n      [t-min-date]=\"field.minValue\"\n      [t-required]=\"field.required\">\n    </thf-datepicker>\n\n    <thf-input *ngIf=\"compareTo(field.control, 'input')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      t-clean\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-mask]=\"field.mask\"\n      [t-maxlength]=\"field.maxLength\"\n      [t-minlength]=\"field.minLength\"\n      [t-pattern]=\"field.pattern\"\n      [t-required]=\"field.required\">\n      </thf-input>\n\n    <thf-number *ngIf=\"compareTo(field.control, 'number')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      t-clean\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-min]=\"field.minValue\"\n      [t-max]=\"field.maxValue\"\n      [t-maxlength]=\"field.maxLength\"\n      [t-minlength]=\"field.minLength\"\n      [t-required]=\"field.required\">\n    </thf-number>\n\n    <thf-decimal *ngIf=\"compareTo(field.control, 'decimal')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      t-clean\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-required]=\"field.required\">\n    </thf-decimal>\n\n    <thf-select *ngIf=\"compareTo(field.control, 'select')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-options]=\"field.options\"\n      [t-required]=\"field.required\">\n    </thf-select>\n\n    <thf-radio-group *ngIf=\"compareTo(field.control, 'radioGroup')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      t-columns=\"3\"\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-options]=\"field.options\"\n      [t-required]=\"field.required\">\n    </thf-radio-group>\n\n    <thf-switch *ngIf=\"compareTo(field.control, 'switch')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-label-off]=\"field.booleanFalse\"\n      [t-label-on]=\"field.booleanTrue\">\n    </thf-switch>\n\n    <thf-combo *ngIf=\"compareTo(field.control, 'combo')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      [t-disabled]=\"field.disabled\"\n      [t-filter-service]=\"field.optionsService\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-required]=\"field.required\">\n    </thf-combo>\n\n    <thf-lookup *ngIf=\"compareTo(field.control, 'lookup')\"\n      name=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      t-field-label=\"label\"\n      t-field-value=\"value\"\n      [ngClass]=\"field.componentClass\"\n      [t-columns]=\"field.columns\"\n      [t-disabled]=\"field.disabled\"\n      [t-filter-service]=\"field.searchService\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-required]=\"field.required\">\n    </thf-lookup>\n\n    <thf-checkbox-group *ngIf=\"compareTo(field.control, 'checkboxGroup')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      t-columns=\"3\"\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-options]=\"field.options\"\n      [t-required]=\"field.required\">\n    </thf-checkbox-group>\n\n    <thf-multiselect *ngIf=\"compareTo(field.control, 'multiselect')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-options]=\"field.options\"\n      [t-required]=\"field.required\">\n    </thf-multiselect>\n\n    <thf-textarea *ngIf=\"compareTo(field.control, 'textarea')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-maxlength]=\"field.maxLength\"\n      [t-minlength]=\"field.minLength\"\n      [t-required]=\"field.required\"\n      [t-rows]=\"field.rows\">\n    </thf-textarea>\n\n    <thf-password *ngIf=\"compareTo(field.control, 'password')\"\n      [name]=\"field.property\"\n      [(ngModel)]=\"value[field.property]\"\n      [ngClass]=\"field.componentClass\"\n      t-clean\n      [t-disabled]=\"field.disabled\"\n      [t-help]=\"field.help\"\n      [t-label]=\"field.label\"\n      [t-maxlength]=\"field.maxLength\"\n      [t-minlength]=\"field.minLength\"\n      [t-required]=\"field.required\">\n  </thf-password>\n\n  </ng-container>\n</div>\n",
                viewProviders: [{ provide: ControlContainer, useExisting: NgForm }]
            }] }
];
/** @nocollapse */
ThfDynamicFormFieldsComponent.ctorParameters = () => [
    { type: TitleCasePipe }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 *
 * Componente para listar dados dinamicamente a partir de uma lista de objetos.
 *
 * > Por padrão esse componente cria `thf-info` para exibição, é possível criar `thf-tag` passando a propriedade { tag: true }.
 *
 */
class ThfDynamicViewBaseComponent {
    /**
     * @param {?} currencyPipe
     * @param {?} datePipe
     * @param {?} decimalPipe
     * @param {?} timePipe
     * @param {?} titleCasePipe
     */
    constructor(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe) {
        this.currencyPipe = currencyPipe;
        this.datePipe = datePipe;
        this.decimalPipe = decimalPipe;
        this.timePipe = timePipe;
        this.titleCasePipe = titleCasePipe;
        this._fields = [];
        this._showAllValue = false;
        this._value = {};
        this.visibleFields = [];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Lista de objetos que implementam a interface `ThfDynamicView`.
     *
     * > Ex: `[ { property: 'age' } ]`
     *
     * Regras de tipagem e formatação dos valores exibidos:
     *
     * - Caso o *type* informado seja *currency* e não seja informado o *format* o mesmo recebe "'BRL', 'symbol', '1.2-2'"
     * como formato padrão.
     * - Caso o *type* informado seja *date* e não seja informado o *format* o mesmo recebe 'dd/MM/yyyy' como formato padrão.
     * - Caso o *type* informado seja *dateTime* e não seja informado o *format* o mesmo recebe 'dd/MM/yyyy HH:mm:ss' como formato padrão.
     * - Caso o *type* informado seja *number* e não seja informado o *format* o mesmo não será formatado.
     * - Caso o *type* informado seja *time* e não seja informado o *format* o mesmo recebe 'HH:mm:ss.ffffff' como formato padrão.
     *
     * > As propriedades informadas serão exibidas mesmo não contendo valor de referência no objeto da propriedade `t-value`.
     *
     * \@default `[]`
     * @param {?} fields
     * @return {?}
     */
    set fields(fields) {
        this._fields = Array.isArray(fields) ? [...fields] : [];
    }
    /**
     * @return {?}
     */
    get fields() {
        return this._fields;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica se exibirá todas as informações contidas dentro do objeto informado na propriedade `t-value`.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set showAllValue(value) {
        this._showAllValue = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get showAllValue() {
        return this._showAllValue;
    }
    /**
     * \@description
     *
     * Objeto que será utilizado para exibir as informações dinâmicas, o valor será recuperado através do atributo *property*
     * dos objetos contidos na propridade `t-fields`.
     *
     * > Ex: `{ age: '35' }`
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value && isTypeof(value, 'object') ? value : {};
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    // retorna os fields com os valores recuperados do objeto value.
    /**
     * @protected
     * @return {?}
     */
    getConfiguredFields() {
        /** @type {?} */
        const newFields = [];
        this.fields.forEach((/**
         * @param {?} field
         * @return {?}
         */
        field => {
            if (isVisibleField(field)) {
                newFields.push(this.createField(field));
            }
        }));
        return newFields;
    }
    // retorna fields ligado ao value mais os atributos do value que não possuiam fields.
    /**
     * @protected
     * @return {?}
     */
    getMergedFields() {
        /** @type {?} */
        const mergedFields = [...this.getConfiguredFields()];
        this.getValueFields().forEach((/**
         * @param {?} valueField
         * @return {?}
         */
        valueField => {
            /** @type {?} */
            const fieldIndex = mergedFields.findIndex((/**
             * @param {?} field
             * @return {?}
             */
            field => field.property === valueField.property));
            /** @type {?} */
            const property = valueField.property;
            if (fieldIndex === -1) {
                mergedFields.push(this.createField({ property }));
            }
        }));
        return mergedFields;
    }
    // retorna o objeto value como fields.
    /**
     * @protected
     * @return {?}
     */
    getValueFields() {
        return Object.keys(this.value).map((/**
         * @param {?} property
         * @return {?}
         */
        property => {
            return this.createField({ property });
        }));
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    createField(field) {
        /** @type {?} */
        const property = field.property;
        /** @type {?} */
        const value = this.transformValue(field.type, this.value[property], field.format);
        /** @type {?} */
        const classesGridColumns = getGridColumnsClasses(field.gridSmColumns, field.gridMdColumns, field.gridLgColumns, field.gridXlColumns, field.gridColumns);
        return Object.assign({ property,
            value, label: this.titleCasePipe.transform(property), cssClass: classesGridColumns }, field);
    }
    /**
     * @private
     * @param {?} type
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    transformValue(type, value, format) {
        /** @type {?} */
        let transformedValue = value;
        switch (type) {
            case 'currency':
                transformedValue = this.currencyPipe.transform(value, format || 'BRL', 'symbol', '1.2-2');
                break;
            case 'date':
                transformedValue = this.datePipe.transform(value, format || 'dd/MM/yyyy');
                break;
            case 'dateTime':
                transformedValue = this.datePipe.transform(value, format || 'dd/MM/yyyy HH:mm:ss');
                break;
            case 'number':
                transformedValue = this.decimalPipe.transform(value, format);
                break;
            case 'time':
                transformedValue = this.timePipe.transform(value, format || 'HH:mm:ss.ffffff');
                break;
        }
        return transformedValue;
    }
}
ThfDynamicViewBaseComponent.propDecorators = {
    fields: [{ type: Input, args: ['t-fields',] }],
    showAllValue: [{ type: Input, args: ['t-show-all-value',] }],
    value: [{ type: Input, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfDynamicViewBaseComponent
 *
 * \@example
 *
 * <example name="thf-dynamic-view-basic" title="Totvs Dynamic View Basic">
 *  <file name="sample-thf-dynamic-view-basic/sample-thf-dynamic-view-basic.component.html"> </file>
 *  <file name="sample-thf-dynamic-view-basic/sample-thf-dynamic-view-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-dynamic-view-employee" title="Totvs Dynamic View - Employee">
 *  <file name="sample-thf-dynamic-view-employee/sample-thf-dynamic-view-employee.component.html"> </file>
 *  <file name="sample-thf-dynamic-view-employee/sample-thf-dynamic-view-employee.component.ts"> </file>
 * </example>
 */
class ThfDynamicViewComponent extends ThfDynamicViewBaseComponent {
    /**
     * @param {?} currencyPipe
     * @param {?} datePipe
     * @param {?} decimalPipe
     * @param {?} timePipe
     * @param {?} titleCasePipe
     */
    constructor(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe) {
        super(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.fields || changes.value || changes.showAllValue) {
            this.visibleFields = this.getVisibleFields();
        }
    }
    /**
     * @private
     * @return {?}
     */
    getVisibleFields() {
        if (this.showAllValue) {
            return this.getMergedFields();
        }
        return this.value && this.fields.length ? this.getConfiguredFields() : this.getValueFields();
    }
}
ThfDynamicViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-dynamic-view',
                template: "<div class=\"thf-row\" *ngIf=\"visibleFields.length\">\n\n  <ng-template ngFor let-field [ngForOf]=\"visibleFields\">\n\n    <thf-divider *ngIf=\"field?.divider?.trim()\" class=\"thf-sm-12\" [t-label]=\"field.divider\">\n    </thf-divider>\n\n    <ng-container *ngTemplateOutlet=\"!field.tag ? thfInfo : thfTag; context: { $implicit: field }\">\n    </ng-container>\n\n  </ng-template>\n\n</div>\n\n<ng-template #thfInfo let-field>\n  <thf-info [ngClass]=\"field.cssClass\"\n    [t-label]=\"field.label\"\n    [t-value]=\"field.value\">\n  </thf-info>\n</ng-template>\n\n<ng-template #thfTag let-field>\n  <thf-tag [ngClass]=\"field.cssClass\"\n    [t-label]=\"field.label\"\n    [t-value]=\"field.value\">\n  </thf-tag>\n</ng-template>\n"
            }] }
];
/** @nocollapse */
ThfDynamicViewComponent.ctorParameters = () => [
    { type: CurrencyPipe },
    { type: DatePipe },
    { type: DecimalPipe },
    { type: ThfTimePipe },
    { type: TitleCasePipe }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfDynamicModule {
}
ThfDynamicModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ThfDividerModule,
                    ThfInfoModule,
                    ThfFieldModule,
                    ThfTagModule,
                    ThfTimeModule
                ],
                declarations: [
                    ThfDynamicFormComponent,
                    ThfDynamicFormFieldsComponent,
                    ThfDynamicViewComponent
                ],
                exports: [
                    ThfDynamicFormComponent,
                    ThfDynamicViewComponent
                ],
                providers: [CurrencyPipe, DatePipe, DecimalPipe, ThfTimePipe, TitleCasePipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfGridCellActionComponent {
    constructor() {
        this.position = '';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDownContent(event) {
        // console.log('onKeyDownContent: ', event);
        // ENTER
        if (event.keyCode === 13) {
            event.preventDefault();
            // this.openActions(this.value);
            return;
        }
    }
}
ThfGridCellActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-grid-cell-action',
                template: "<div>\n  <div #contentElement [id]=\"position\"\n    class=\"thf-grid-cell-action-content\"\n    tabindex=\"0\"\n    (keydown)=\"onKeyDownContent($event)\">\n    <span>{{ value || '&nbsp;' }}</span>\n  </div>\n</div>\n\n",
                styles: [".thf-grid-cell-action-content{border-bottom:1px solid #eceeee;border-left:none;border-right:1px solid #eceeee;border-top:none;font-family:NunitoSans;font-size:14px;height:44px;line-height:1.71;margin:0;max-height:44px;max-width:56px;min-height:44px;min-width:56px;padding:10px 16px;text-align:center;width:56px}.thf-grid-cell-action-content:focus{border:none;outline:#0c9abe solid 1px}"]
            }] }
];
/** @nocollapse */
ThfGridCellActionComponent.ctorParameters = () => [];
ThfGridCellActionComponent.propDecorators = {
    position: [{ type: Input, args: ['t-position',] }],
    value: [{ type: Input, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfGridCellComponent {
    /**
     * @param {?} changeDetectorRef
     */
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        this._value = '';
        this.edit = false;
        this.editValue = '';
        this.align = 'left';
        this.freeze = false;
        this.tabIndex = -1;
        this.position = '';
        this.readonly = false;
        this.required = false;
        this.valueChange = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        this._width = value;
        if (this.freeze && !this._width) {
            this._width = 100;
        }
    }
    /**
     * @return {?}
     */
    get width() {
        return this._width ? `${this._width}px` : '100%';
    }
    // @Input('t-value') value?: string;
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
        this.valueChange.emit(this._value);
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDownContent(event) {
        // console.log('onKeyDownContent: ', event);
        // BACKSPACE / DELETE
        if ((!event.ctrlKey) && ((event.keyCode === 8) || (event.keyCode === 46))) {
            if (this.readonly) {
                return;
            }
            event.preventDefault();
            this.value = '';
            return;
        }
        // ENTER
        if (event.keyCode === 13) {
            event.preventDefault();
            this.onEditCell(this.value);
            return;
        }
        // A..Z - 0..9
        if ((event.keyCode >= 65) && (event.keyCode <= 90) || (event.keyCode >= 48) && (event.keyCode <= 57)) {
            event.preventDefault();
            this.onEditCell(event.key);
            return;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dblclick(event) {
        // console.log('dblclick: ', event);
        event.preventDefault();
        this.onEditCell(this.value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBlurInput(event) {
        // console.log('onBlurInput: ', event);
        this.value = this.editValue;
        this.editValue = undefined;
        this.edit = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDownInput(event) {
        // console.log('onKeyDownInput: ', event);
        // ENTER
        if (event.keyCode === 13) {
            this.value = this.editValue;
            this.editValue = undefined;
            this.edit = false;
            this.changeDetectorRef.detectChanges();
            this.contentElement.nativeElement.focus();
        }
        // ESCAPE
        if (event.keyCode === 27) {
            this.editValue = undefined;
            this.edit = false;
            this.changeDetectorRef.detectChanges();
            this.contentElement.nativeElement.focus();
            event.stopPropagation();
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    onEditCell(value) {
        if (this.readonly) {
            return;
        }
        this.editValue = value;
        this.edit = true;
        this.changeDetectorRef.detectChanges();
        this.inputElement.nativeElement.focus();
    }
}
ThfGridCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-grid-cell',
                template: "<div>\n  <ng-container *ngIf=\"edit; then input; else content\"></ng-container>\n\n  <ng-template #content>\n    <div #contentElement\n      [id]=\"position\"\n      class=\"thf-grid-cell-content thf-grid-cell-{{ align }} {{ !value && required ? 'thf-grid-cell-required' : '' }}\"\n      (keydown)=\"onKeyDownContent($event)\"\n      tabindex=\"{{ readonly ? -1 : 0 }}\"\n      (dblclick)=dblclick($event)>\n      <span>{{ value || '&nbsp;' }}</span>\n    </div>\n  </ng-template>\n\n  <ng-template #input>\n    <input\n      [id]=\"position\"\n      #inputElement class=\"thf-grid-cell-input\"\n      [(ngModel)]=\"editValue\"\n      (keydown.arrowup)=\"$event.stopPropagation()\"\n      (keydown.arrowdown)=\"$event.stopPropagation()\"\n      (keydown.arrowleft)=\"$event.stopPropagation()\"\n      (keydown.arrowright)=\"$event.stopPropagation()\"\n      (keydown)=\"onKeyDownInput($event)\"\n      (blur)=\"onBlurInput($event)\">\n\n    <!-- <thf-input\n      #inputElement class=\"thf-grid-cell-input\"\n      [(ngModel)]=\"editValue\"\n      (keydown)=\"onKeyDownInput($event)\"\n      (t-blur)=\"onBlurInput($event)\">\n    </thf-input> -->\n  </ng-template>\n</div>\n\n",
                styles: [".thf-grid-cell-content,.thf-grid-cell-input{border-bottom:1px solid #eceeee;border-left:none;border-right:1px solid #eceeee;border-top:none;font-family:NunitoSans;font-size:14px;height:44px;line-height:1.71;margin:0;overflow:hidden;padding:10px 16px;text-align:left;text-overflow:ellipsis;white-space:nowrap}.thf-grid-cell-center{text-align:center}.thf-grid-cell-right{text-align:right}.thf-grid-cell-content:focus{border:none;outline:#0c9abe solid 1px}.thf-grid-cell-required{border:1px dashed red}.thf-grid-cell-input{border:1px solid #0c9abe;box-shadow:0 0 4px 4px rgba(0,0,0,.1);outline:0;position:relative;min-width:100%;max-width:100%;width:100%}"]
            }] }
];
/** @nocollapse */
ThfGridCellComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
ThfGridCellComponent.propDecorators = {
    align: [{ type: Input, args: ['t-align',] }],
    freeze: [{ type: Input, args: ['t-freeze',] }],
    tabIndex: [{ type: Input, args: ['t-tab-index',] }],
    position: [{ type: Input, args: ['t-position',] }],
    width: [{ type: Input, args: ['t-width',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    required: [{ type: Input, args: ['t-required',] }],
    valueChange: [{ type: Output, args: ['t-valueChange',] }],
    value: [{ type: Input, args: ['t-value',] }],
    inputElement: [{ type: ViewChild, args: ['inputElement', { static: true },] }],
    contentElement: [{ type: ViewChild, args: ['contentElement', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Componente grid.
 *
 * Ações / atalhos:
 *
 * - ARROW-UP: Navega para celula superior / Na ultima linha adiciona uma linha em branco no grid;
 * - ARROW-DOWN: Navega para celula inferior;
 * - ARROW-RIGHT: Navega para celula direita;
 * - ARROW-LEFT: Navega para celula esquerda;
 * - TAB: Navega para próxima celula;
 * - SHIFT+TAB: Navega para celula anterior;
 * - CTRL+DEL: Remove linha;
 * - DEL/BACKSPACE: Limpa celula;
 * - ENTER: Edita linha com valor atual/Confirma edição da celula;
 * - DOUBLE-CLICK: Edita linha com valor atual;
 * - ESC: Cancela edição da celula / Cancela inserção de linhas em branco;
 * - A..Z/0..9: Inicia edição com valor em branco.
 *
 * \@example
 *
 * <example name="thf-grid-basic" title="Totvs Grid Basic">
 *  <file name="sample-thf-grid-basic/sample-thf-grid-basic.component.html"> </file>
 *  <file name="sample-thf-grid-basic/sample-thf-grid-basic.component.ts"> </file>
 * </example>
 */
class ThfGridComponent {
    /**
     * @param {?} changeDetectorRef
     * @param {?} elRef
     * @param {?} renderer
     */
    constructor(changeDetectorRef, elRef, renderer) {
        this.changeDetectorRef = changeDetectorRef;
        this.elRef = elRef;
        this.lastCell = '0-0';
        this.lastRow = 0;
        this.lastColumn = 0;
        this.currencyCell = '0-0';
        this.currencyRow = 0;
        this.currencyColumn = 0;
        this.logger = false;
        this.width = '100%';
        this.widthFreeze = 0;
        this.widthActions = 0;
        this._columns = [];
        /**
         * \@description
         *
         * Ações disparadas quando uma linha do grid é manipulada.
         */
        this.rowActions = {};
        /**
         * Lista com os dados que serão exibidos no grid.
         */
        this.data = [];
        this.debounceResize();
        this.resizeListener = renderer.listen('window', 'resize', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.debounceResize();
        }));
    }
    /**
     * Colunas exibidas no grid.
     * @param {?} value
     * @return {?}
     */
    set columns(value) {
        this._columns = [...value];
        this._columns.forEach((/**
         * @param {?} column
         * @return {?}
         */
        column => {
            column.label = column.label || column.property;
            if (column.freeze === true) {
                column.cssWidth = `${column.width || 100}px`;
            }
            else {
                column.cssWidth = column.width ? `${column.width}px` : '100%';
            }
        }));
    }
    /**
     * @return {?}
     */
    get columns() {
        return this._columns.filter((/**
         * @param {?} column
         * @return {?}
         */
        column => column.freeze !== true && column.action !== true));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.resizeListener) {
            this.resizeListener();
        }
    }
    /**
     * @private
     * @return {?}
     */
    debounceResize() {
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const widthTableWrapper = this.tableWrapper.nativeElement.offsetWidth;
            this.width = `${widthTableWrapper - (this.widthFreeze + 8) - this.widthActions}px`;
        }), 100);
    }
    /**
     * @return {?}
     */
    get freezeColumns() {
        /** @type {?} */
        const freezeColumns = this._columns.filter((/**
         * @param {?} column
         * @return {?}
         */
        column => column.freeze === true));
        this.widthFreeze = freezeColumns.reduce((/**
         * @param {?} prev
         * @param {?} current
         * @return {?}
         */
        (prev, current) => prev + (current.width || 100)), 0);
        return freezeColumns;
    }
    /**
     * @return {?}
     */
    get actionColumns() {
        /** @type {?} */
        const actionsColumns = this._columns.filter((/**
         * @param {?} column
         * @return {?}
         */
        column => column.action === true));
        this.widthActions = actionsColumns.length > 0 ? 56 : 0;
        return actionsColumns;
    }
    /**
     * @param {?} event
     * @param {?} row
     * @return {?}
     */
    cancelRow(event, row) {
        /** @type {?} */
        const el = event.path.find((/**
         * @param {?} element
         * @return {?}
         */
        element => element.id));
        if (!el) {
            return;
        }
        const [x] = (el.id).split('-');
        if (this.isEmptyRow(x)) {
            if (!this.removeRow(event, row)) {
                return;
            }
            this.currencyObj = Object.assign({}, this.data[this.currencyRow - 1]);
        }
        else {
            this.data[+x - 1] = Object.assign({}, this.currencyObj);
            setTimeout((/**
             * @return {?}
             */
            () => this.selectCell(this.currencyRow, this.currencyColumn)));
        }
    }
    /**
     * @param {?} event
     * @param {?} row
     * @return {?}
     */
    removeRow(event, row) {
        if (this.rowActions.beforeRemove && !this.rowActions.beforeRemove(Object.assign({}, row))) {
            return false;
        }
        /** @type {?} */
        const index = this.data.indexOf(row);
        this.data.splice(index, 1);
        this.changeDetectorRef.detectChanges();
        if ((this.data.length === 0) || (index === this.data.length)) {
            this.selectCell(this.currencyRow - 1, this.currencyColumn);
        }
        else {
            this.selectCell(this.currencyRow, this.currencyColumn);
        }
        return true;
    }
    /**
     * @param {?} event
     * @param {?} direction
     * @return {?}
     */
    tableKeydown(event, direction) {
        let [row, col] = event.target.id.split('-');
        row = +row;
        col = +col;
        /** @type {?} */
        let prow = +row;
        /** @type {?} */
        let pcol = +col;
        // event.preventDefault();
        // event.stopPropagation();
        // debugger;
        if (direction === 'down') {
            if (row <= this.data.length) {
                prow++;
            }
            if (row === this.data.length) {
                if (row === 0 || !this.isEmptyRow(row)) {
                    if (this.saveRow(row)) {
                        if (!this.insertRow()) {
                            return;
                        }
                    }
                    else {
                        return;
                    }
                }
                else {
                    prow--;
                }
            }
        }
        else if ((direction === 'up') && (row > 0)) {
            prow--;
        }
        else if ((direction === 'left') && (col > 0)) {
            pcol--;
        }
        else if ((direction === 'right') && (col < this._columns.length - 1)) {
            pcol++;
        }
        else if (direction === 'next') {
            if (col < this._columns.length - 1) {
                pcol++;
                event.preventDefault();
            }
            else if (row < this.data.length) {
                pcol = 0;
                prow++;
                event.preventDefault();
            }
        }
        else if (direction === 'prior') {
            if (col > 0) {
                pcol--;
                event.preventDefault();
            }
            else if (row > 0) {
                pcol = this._columns.length - 1;
                prow--;
                event.preventDefault();
            }
        }
        if (this.currencyCell === `${prow}-${pcol}`) {
            // console.log('vazou');
            return;
        }
        // debugger;
        if (prow !== this.currencyRow && row > 0 && this.data.length >= row) {
            if (!this.isEmptyRow(row)) {
                if (!this.saveRow(row)) {
                    return;
                }
            }
            else {
                if (!this.removeRow(event, row)) {
                    return;
                }
            }
        }
        if (this.currencyRow !== prow) {
            this.currencyObj = Object.assign({}, this.data[prow - 1]);
            // console.log('mudou de linha');
        }
        this.lastCell = event.target.id;
        this.lastRow = row;
        this.lastColumn = col;
        this.selectCell(prow, pcol);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    tableClick(event) {
        /** @type {?} */
        const el = event.path.find((/**
         * @param {?} element
         * @return {?}
         */
        element => element.id));
        if (!el) {
            this.selectCell(this.currencyRow, this.currencyColumn);
            return;
        }
        if (this.currencyCell === el.id) {
            return;
        }
        const [row, col] = (el.id).split('-');
        /** @type {?} */
        const prow = +row;
        /** @type {?} */
        const pcol = +col;
        if (prow !== this.currencyRow) {
            if (this.currencyRow > 0) {
                if (!this.isEmptyRow(this.currencyRow)) {
                    if (!this.saveRow(this.currencyRow)) {
                        this.selectCell(this.currencyRow, this.currencyColumn);
                        return;
                    }
                }
                else {
                    if (!this.removeRow(event, row)) {
                        return;
                    }
                }
            }
            this.currencyObj = Object.assign({}, this.data[prow - 1]);
            // console.log('>>>>>>> ', prow - 1);
        }
        this.lastCell = this.currencyCell;
        this.lastRow = this.currencyRow;
        this.lastColumn = this.currencyColumn;
        this.currencyCell = el.id;
        this.currencyRow = prow;
        this.currencyColumn = pcol;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    saveRow(row) {
        // console.log(this.data[row - 1]);
        // console.log(this.data[row - 1]);
        /** @type {?} */
        const obj = this.data[row - 1];
        if (!Object.keys(obj).some((/**
         * @param {?} prop
         * @return {?}
         */
        prop => obj[prop] !== this.currencyObj[prop]))) {
            // console.log('tudo igual');
            return true;
        }
        if (this.rowActions.beforeSave && !this.rowActions.beforeSave(obj, this.currencyObj)) {
            return false;
        }
        /** @type {?} */
        const requireds = [];
        this.columns.forEach((/**
         * @param {?} column
         * @return {?}
         */
        column => {
            if (column.required === true && !obj[column.property]) {
                requireds.push(column.property);
            }
        }));
        return requireds.length === 0;
    }
    /**
     * @return {?}
     */
    insertRow() {
        /** @type {?} */
        const obj = {};
        if (this.rowActions.beforeInsert && !this.rowActions.beforeInsert(obj)) {
            return false;
        }
        // this.currencyObj = Object.assign({}, obj);
        this.data.push(obj);
        this.changeDetectorRef.detectChanges();
        return true;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    isEmptyRow(row) {
        /** @type {?} */
        const obj = this.data[row - 1];
        if (!obj) { // title
            return false;
        }
        /** @type {?} */
        const filled = Object.keys(obj).some((/**
         * @param {?} property
         * @return {?}
         */
        property => obj[property]));
        return !filled;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    selectCell(row, col) {
        /** @type {?} */
        const nextCell = this.elRef.nativeElement.querySelector(`[id='${row}-${col}']`);
        if (nextCell) {
            this.currencyCell = `${row}-${col}`;
            this.currencyRow = row;
            this.currencyColumn = col;
            nextCell.focus();
        }
    }
}
ThfGridComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-grid',
                template: "<div class=\"thf-grid-wrapper thf-grid-row-wrapper\" #wrapper>\n\n  <div *ngIf=\"logger\">\n    lastCell: {{ lastCell }} | currencyCell: {{ currencyCell }} <br>\n    lastRow: {{ lastRow }} | currencyRow: {{ currencyRow }} <br>\n    lastColumn: {{ lastColumn }} | currencyColumn: {{ currencyColumn }} <br>\n    <hr>\n    currencyObj: {{ currencyObj | json }}\n    <hr>\n  </div>\n\n  <div class=\"thf-grid\">\n    <div class=\"thf-grid-body\">\n      <div class=\"thf-grid-row\"\n        #table\n        (keydown.arrowup)=\"tableKeydown($event, 'up')\"\n        (keydown.arrowdown)=\"tableKeydown($event, 'down')\"\n        (keydown.arrowleft)=\"tableKeydown($event, 'left')\"\n        (keydown.arrowright)=\"tableKeydown($event, 'right')\"\n        (keydown.tab)=\"tableKeydown($event, 'next')\"\n        (keydown.shift.tab)=\"tableKeydown($event, 'prior')\"\n        (click)=\"tableClick($event)\"\n        (contextmenu)=\"tableClick($event)\"\n        (dblclick)=\"tableClick($event)\">\n\n        <div class=\"thf-grid-cell thf-grid-cell-freeze\" *ngIf=\"freezeColumns.length > 0\">\n          <ng-container *ngTemplateOutlet=\"divFreezeColumns\"></ng-container>\n        </div>\n\n        <div class=\"thf-grid-cell thf-grid-cell-normal\"\n          [style.width]=\"width\" [style.max-width]=\"width\" [style.min-width]=\"width\">\n          <ng-container *ngTemplateOutlet=\"divColumns\"></ng-container>\n        </div>\n\n        <div class=\"thf-grid-cell thf-grid-cell-action\" *ngIf=\"actionColumns.length > 0\">\n          <ng-container *ngTemplateOutlet=\"divActionColumns\"></ng-container>\n        </div>\n\n      </div>\n    </div>\n  </div>\n\n  <!-- <div class=\"thf-grid-footer-wrapper\">\n    <div class=\"thf-grid-footer\">\n      <div class=\"links\"><a href=\"#\">RODAP\u00C9</a></div>\n    </div>\n  </div> -->\n\n</div>\n\n<!-- Coluna com as colunas congeladas -->\n<ng-template #divFreezeColumns>\n  <div class=\"thf-grid thf-grid-freeze\">\n    <div class=\"thf-grid-header-group\">\n      <div class=\"thf-grid-row\">\n        <thf-grid-head *ngFor=\"let column of freezeColumns; index as i\" class=\"thf-grid-title\"\n          [style.width]=\"column.cssWidth\" [style.max-width]=\"column.cssWidth\" [style.min-width]=\"column.cssWidth\"\n          t-freeze=\"true\"\n          t-position=\"{{ '0-' + i }}\"\n          [t-width]=\"column.width\"\n          [t-align]=\"column.align\"\n          [t-title]=\"column.label\">\n        </thf-grid-head>\n      </div>\n    </div>\n\n    <div class=\"thf-grid-body\">\n      <div class=\"thf-grid-row\" *ngFor=\"let row of data; index as j\"\n        (keydown.control.delete)=\"removeRow($event, row)\"\n        (keydown.esc)=\"cancelRow($event, row)\">\n        <thf-grid-cell *ngFor=\"let column of freezeColumns; index as i\" class=\"thf-grid-cell\"\n          [style.width]=\"column.cssWidth\" [style.max-width]=\"column.cssWidth\" [style.min-width]=\"column.cssWidth\"\n          t-freeze=\"true\"\n          [t-align]=\"column.align\"\n          [t-readonly]=\"column.readonly\"\n          [t-required]=\"column.required\"\n          t-position=\"{{ (j + 1) + '-' + i }}\"\n          [t-width]=\"column.width\"\n          [(t-value)]=\"row[column.property]\">\n        </thf-grid-cell>\n      </div>\n    </div>\n  </div>\n</ng-template>\n<!-- FIM: Coluna com as colunas congeladas -->\n\n<!-- Coluna com as colunas nornais -->\n<ng-template #divColumns>\n  <div class=\"thf-grid thf-grid-normal\">\n    <div class=\"thf-grid-header-group\">\n      <div class=\"thf-grid-row\">\n        <thf-grid-head *ngFor=\"let column of columns; index as i\" class=\"thf-grid-title\"\n          [style.width]=\"column.cssWidth\" [style.max-width]=\"column.cssWidth\" [style.min-width]=\"column.cssWidth\"\n          [t-align]=\"column.align\"\n          t-position=\"{{ '0-' + (i + freezeColumns.length) }}\"\n          [t-title]=\"column.label\"\n          [t-width]=\"column.width\">\n        </thf-grid-head>\n      </div>\n    </div>\n\n    <div class=\"thf-grid-body\">\n      <div class=\"thf-grid-row\" *ngFor=\"let row of data; index as j\"\n        (keydown.control.delete)=\"removeRow($event, row)\"\n        (keydown.esc)=\"cancelRow($event, row)\">\n        <thf-grid-cell *ngFor=\"let column of columns; index as i\" class=\"thf-grid-cell\"\n          [style.width]=\"column.cssWidth\" [style.max-width]=\"column.cssWidth\" [style.min-width]=\"column.cssWidth\"\n          [t-align]=\"column.align\"\n          [t-readonly]=\"column.readonly\"\n          [t-required]=\"column.required\"\n          t-position=\"{{ (j + 1) + '-' + (i + freezeColumns.length) }}\"\n          [(t-value)]=\"row[column.property]\"\n          [t-width]=\"column.width\">\n        </thf-grid-cell>\n      </div>\n    </div>\n  </div>\n</ng-template>\n<!-- FIM: Coluna com as colunas nornais -->\n\n<!-- Coluna com as colunas de a\u00E7\u00E3o -->\n<ng-template #divActionColumns>\n    <div class=\"thf-grid thf-grid-actions\">\n      <div class=\"thf-grid-header-group\">\n        <div class=\"thf-grid-row\">\n          <thf-grid-head *ngFor=\"let column of actionColumns; index as i\" class=\"thf-grid-title\"\n            t-position=\"{{ '0-' + (i + freezeColumns.length + columns.length) }}\"\n            [t-title]=\"column.label\"\n            [t-align]=\"column.align\">\n          </thf-grid-head>\n        </div>\n      </div>\n\n      <div class=\"thf-grid-body\">\n        <div class=\"thf-grid-row\" *ngFor=\"let row of data; index as j\"\n          (keydown.control.delete)=\"removeRow($event, row)\"\n          (keydown.esc)=\"cancelRow($event, row)\">\n          <thf-grid-cell-action *ngFor=\"let column of actionColumns; index as i\" class=\"thf-grid-cell\"\n            t-position=\"{{ (j + 1) + '-' + (i + freezeColumns.length + columns.length) }}\"\n            [t-value]=\"row[column.property]\">\n          </thf-grid-cell-action>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n  <!-- FIM: Coluna com as colunas de a\u00E7\u00E3o -->\n",
                styles: [".thf-grid-wrapper{overflow:auto;border:1px solid #eceeee}.thf-grid{display:table;border-right:none;border-bottom:none}.thf-grid-cell-normal::-webkit-scrollbar,.thf-grid-row-wrapper::-webkit-scrollbar{border-radius:2px;height:4px;opacity:.5;width:4px}.thf-grid-cell-normal::-webkit-scrollbar-thumb,.thf-grid-row-wrapper::-webkit-scrollbar-thumb{background-color:#0c9abe}.thf-grid .fixed{display:table}.thf-grid-header-group{display:table-header-group}.thf-grid-body{display:table-row-group}.thf-grid-row{display:table-row}.thf-grid-cell,.thf-grid-title{display:table-cell;border:none}.thf-grid-cell-freeze{border-right:2px solid #ceeaf2}.thf-grid-cell-action{color:#00f;border-left:2px solid #ceeaf2}.thf-grid-actions,.thf-grid-freeze,.thf-grid-normal{width:100%}.thf-grid-cell-normal{overflow:auto}.thf-grid-footer{display:table-footer-group}.thf-grid-footer-wrapper{border:1px solid #eceeee;border-top:none}"]
            }] }
];
/** @nocollapse */
ThfGridComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Renderer2 }
];
ThfGridComponent.propDecorators = {
    tableElement: [{ type: ViewChild, args: ['table', { static: true },] }],
    tableWrapper: [{ type: ViewChild, args: ['wrapper', { static: true },] }],
    rowActions: [{ type: Input, args: ['t-row-actions',] }],
    columns: [{ type: Input, args: ['t-columns',] }],
    data: [{ type: Input, args: ['t-data',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfGridHeadComponent {
    /**
     * @param {?} changeDetectorRef
     */
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.align = 'left';
        this.boolean = false;
        this.position = '';
        this.tabIndex = -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        this._width = value;
    }
    /**
     * @return {?}
     */
    get width() {
        return this._width ? `${this._width}px` : '100%';
    }
}
ThfGridHeadComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-grid-head',
                template: "<div>\n  <div [id]=\"position\"\n    class=\"thf-grid-head-content thf-grid-head-{{ align }}\"\n    tabindex=\"{{ title ? 0 : -1 }}\">\n    <span>{{ title || '&nbsp;' }}</span>\n  </div>\n</div>\n\n",
                styles: [".thf-grid-head-content{border-bottom:2px solid #ceeaf2;border-left:none;border-right:1px solid #eceeee;border-top:none;color:#0c9abe;font-family:NunitoSans-bold;font-size:14px;height:44px;line-height:1.71;margin:0;max-height:44px;min-height:44px;overflow:hidden;padding:10px 16px;text-align:left;text-overflow:ellipsis;white-space:nowrap}.thf-grid-head-center{text-align:center}.thf-grid-head-right{text-align:right}.thf-grid-head-content:focus{border:1px solid #0c9abe;outline:0}"]
            }] }
];
/** @nocollapse */
ThfGridHeadComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
ThfGridHeadComponent.propDecorators = {
    align: [{ type: Input, args: ['t-align',] }],
    boolean: [{ type: Input, args: ['t-freeze',] }],
    position: [{ type: Input, args: ['t-position',] }],
    tabIndex: [{ type: Input, args: ['t-tab-index',] }],
    width: [{ type: Input, args: ['t-width',] }],
    title: [{ type: Input, args: ['t-title',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-grid.
 */
class ThfGridModule {
}
ThfGridModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ThfFieldModule
                ],
                declarations: [
                    ThfGridCellActionComponent,
                    ThfGridCellComponent,
                    ThfGridComponent,
                    ThfGridHeadComponent
                ],
                exports: [
                    ThfGridComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfListViewLiteralsDefault = {
    en: (/** @type {?} */ ({
        hideDetails: 'Hide details',
        loadMoreData: 'Load more data',
        noData: 'No data found',
        selectAll: 'Select all',
        showDetails: 'Show details'
    })),
    es: (/** @type {?} */ ({
        hideDetails: 'Ocultar detalles',
        loadMoreData: 'Cargar más resultados',
        noData: 'Datos no encontrados',
        selectAll: 'Seleccionar todos',
        showDetails: 'Mostrar detalles'
    })),
    pt: (/** @type {?} */ ({
        hideDetails: 'Ocultar detalhes',
        loadMoreData: 'Carregar mais resultados',
        noData: 'Nenhum dado encontrado',
        selectAll: 'Selecionar todos',
        showDetails: 'Exibir detalhes'
    }))
};
/**
 * \@description
 *
 * Componente de lista que recebe um array de objetos e renderiza de forma dinâmica os dados de
 * acordo com a necessidade de cada tela e deve ser utilizado em conjunto com as diretivas de *templates*
 *  **[t-list-view-content-template](/documentation/thf-list-view-content-template)** e
 * **[t-list-view-detail-template](/documentation/thf-list-view-detail-template)**.
 *
 * O componente disponibiliza uma área específica para exibição informações adicionais,
 * através da diretiva **[t-list-view-detail-template](/documentation/thf-list-view-detail-template)**.
 */
class ThfListViewBaseComponent {
    constructor() {
        this.selectAll = false;
        this.showHeader = false;
        /**
         * Recebe uma ação, que será executada quando clicar no botão "Carregar mais resultados".
         *
         * > Caso nenhuma ação for definida o mesmo não ficará visível.
         */
        this.showMore = new EventEmitter();
        /**
         * Ação que será executada ao clicar no título.
         *
         * Ao ser disparado, o método inserido na ação irá receber como parâmetro o item da lista clicado.
         */
        this.titleAction = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Lista de ações que serão exibidas no componente.
     * @param {?} value
     * @return {?}
     */
    set actions(value) {
        this._actions = Array.isArray(value) ? value : [];
    }
    /**
     * @return {?}
     */
    get actions() {
        return this._actions;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a altura do `thf-list-view` em *pixels*.
     * @param {?} height
     * @return {?}
     */
    set height(height) {
        this._height = height;
    }
    /**
     * @return {?}
     */
    get height() {
        return this._height;
    }
    /**
     * \@description
     *
     * Esconde o *checkbox* para seleção de todos os itens.
     *
     * \@default `false`
     * @param {?} hideSelectAll
     * @return {?}
     */
    set hideSelectAll(hideSelectAll) {
        this._hideSelectAll = convertToBoolean(hideSelectAll);
        this.showMainHeader();
    }
    /**
     * @return {?}
     */
    get hideSelectAll() {
        return this._hideSelectAll;
    }
    /**
     * Lista de itens que serão exibidos no componente.
     * @param {?} value
     * @return {?}
     */
    set items(value) {
        this._items = Array.isArray(value) ? value : [];
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-list-view`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfListViewLiterals = {
     *    hideDetail: 'Ocultar detalhes completamente',
     *    loadMoreData: 'Mais dados',
     *    showDetail: 'Mostrar mais detalhes',
     *    selectAll: 'Selecionar todos os itens'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfListViewLiterals = {
     *    showDetail: 'Mostrar mais detalhes'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-list-view
     *   [t-literals]="customLiterals">
     * </thf-list-view>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfListViewLiteralsDefault[thfLocaleDefault], thfListViewLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfListViewLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfListViewLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Habilita um *checkbox* para cada item da lista. Todos os items possuem a propriedade dinâmica `$selected` para identificar se o
     * item está selecionado, por exemplo:
     *
     * ```
     *  item.$selected
     *
     *  // ou
     *
     *  item['$selected']
     * ```
     *
     * \@default `false`
     * @param {?} select
     * @return {?}
     */
    set select(select) {
        this._select = convertToBoolean(select);
        this.showMainHeader();
    }
    /**
     * @return {?}
     */
    get select() {
        return this._select;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o botão `Carregar Mais Resultados` será desabilitado.
     * @param {?} value
     * @return {?}
     */
    set showMoreDisabled(value) {
        this._showMoreDisabled = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get showMoreDisabled() {
        return this._showMoreDisabled;
    }
    /**
     * @param {?} listViewAction
     * @param {?} item
     * @return {?}
     */
    onClickAction(listViewAction, item) {
        /** @type {?} */
        const cleanItem = this.deleteInternalAttrs(item);
        if (listViewAction.action) {
            listViewAction.action(cleanItem);
        }
    }
    /**
     * @return {?}
     */
    onShowMore() {
        this.showMore.emit();
    }
    /**
     * @param {?} listItem
     * @return {?}
     */
    runTitleAction(listItem) {
        /** @type {?} */
        const itemWithPublicProperties = this.deleteInternalAttrs(listItem);
        this.titleAction.emit(itemWithPublicProperties);
    }
    /**
     * @return {?}
     */
    selectAllListItems() {
        if (!this.hideSelectAll) {
            this.selectAll = !this.selectAll;
            this.items.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                item.$selected = this.selectAll;
            }));
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    selectListItem(row) {
        row.$selected = !row.$selected;
        this.selectAll = this.checkIfItemsAreSelected(this.items);
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    deleteInternalAttrs(item) {
        /** @type {?} */
        const itemCopy = item ? Object.assign({}, item) : undefined;
        for (const key in itemCopy) {
            if (itemCopy.hasOwnProperty(key) && key.startsWith('$')) {
                delete itemCopy[key];
            }
        }
        return itemCopy;
    }
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    checkIfItemsAreSelected(items) {
        /** @type {?} */
        const someCheckedOrIndeterminate = (/**
         * @param {?} item
         * @return {?}
         */
        item => item.$selected || item.$selected === null);
        /** @type {?} */
        const everyChecked = (/**
         * @param {?} item
         * @return {?}
         */
        item => item.$selected);
        if (items.every(everyChecked)) {
            return true;
        }
        if (items.some(someCheckedOrIndeterminate)) {
            return null;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    showMainHeader() {
        this.showHeader = !!(this.select && !this.hideSelectAll && this.items && this.items.length);
    }
}
ThfListViewBaseComponent.propDecorators = {
    actions: [{ type: Input, args: ['t-actions',] }],
    height: [{ type: Input, args: ['t-height',] }],
    hideSelectAll: [{ type: Input, args: ['t-hide-select-all',] }],
    items: [{ type: Input, args: ['t-items',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    propertyLink: [{ type: Input, args: ['t-property-link',] }],
    propertyTitle: [{ type: Input, args: ['t-property-title',] }],
    select: [{ type: Input, args: ['t-select',] }],
    showMoreDisabled: [{ type: Input, args: ['t-show-more-disabled',] }],
    showMore: [{ type: Output, args: ['t-show-more',] }],
    titleAction: [{ type: Output, args: ['t-title-action',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfListViewComponent
 *
 * \@description
 *
 * Esta diretiva permite que sejam apresentadas informações essenciais de cada item.
 *
 * Deve-se utilizar como parâmetro a referência do item e/ou índice, sendo por padrão o item.
 *  - Item: `item` determina o item da linha corrente.
 *  - Índice: `index` determina o índice da linha corrente.
 *
 * Esta diretiva pode ser usada de duas formas: explícita ou *syntax sugar*. Veja a seguir ambos, respectivamente:
 *
 * ```
 * ...
 * <thf-list-view
 *   t-property-title="name"
 *   [t-items]="[{id: 1, name: "Register", email: register\@totvs.com}]">
 *
 *   <ng-template t-list-view-content-template let-item let-code="index">
 *     <div class="thf-row">
 *       <thf-info class="thf-md-6" t-label="Code" [t-value]="code"></thf-info>
 *       <thf-info class="thf-md-6" t-label="Email" [t-value]="item.email"></thf-info>
 *     </div>
 *   </ng-template>
 *
 * </thf-list-view>
 *
 * ...
 * ```
 *
 * ```
 * ...
 * <thf-list-view
 *    t-property-title="name"
 *    [t-items]="[{id: 1, name: "Register", email: register\@totvs.com}]">
 *
 *    <div *t-list-view-content-template="let item, let i=index" class="thf-row">
 *      <thf-info class="thf-md-12" t-label="Email" [t-value]="item.email"></thf-info>
 *    </div>
 * </thf-list-view>
 * ...
 *
 * ```
 *
 * A diretiva **t-list-view-content-template**, possibilita também alterar o título dos itens. Para isto,
 * é necessário atribuir a referência da função que faz a alteração, à propriedade `t-title`,
 * a mesma deve retornar um valor do tipo *string*. Veja o exemplo a seguir:
 *
 * ```
 * ...
 * \@Component({
 *    selector: 'app-root',
 *    template: `
 *      ...
 *      <thf-list-view
 *        [t-items]="items">
 *        <ng-template t-list-view-content-template let-item [t-title]="customTitle">
 *          <div class="thf-row">
 *            <thf-info class="thf-md-12" t-label="Customer" [t-value]="item.customer"></thf-info>
 *          </div>
 *        </ng-template>
 *      ...
 *    `
 * })
 * export class AppComponent {
 *    public items = [{
 *      code: 1200,
 *      product: 'Rice',
 *      customer: 'Supermarket 1',
 *    }, {
 *      code: 1355,
 *      product: 'Bean',
 *      customer: 'Supermarket 2'
 *    }];
 *
 *    customTitle(item) {
 *      return `${item.code} - ${item.product}`;
 *    }
 * }
 * ```
 */
class ThfListViewContentTemplateDirective {
    // Necessário manter templateRef para o funcionamento do row template.
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ThfListViewContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[t-list-view-content-template]'
            },] }
];
/** @nocollapse */
ThfListViewContentTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
ThfListViewContentTemplateDirective.propDecorators = {
    title: [{ type: Input, args: ['t-title',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfListViewComponent
 *
 * \@description
 *
 * Esta diretiva permite que sejam apresentadas informações adicionais de cada item, construindo um
 * botão `Exibir detalhes` abaixo do conteúdo principal do item.
 *
 * Deve-se utilizar como parâmetro a referência do item e/ou índice, sendo por padrão o item.
 *  - Item: `item` determina o item da linha corrente.
 *  - Índice: `index` determina o índice da linha corrente.
 *
 * Esta diretiva pode ser usada de duas formas: explícita ou *syntax sugar*. Veja a seguir ambos, respectivamente:
 *
 * ```
 * ...
 * <thf-list-view
 *   t-property-title="name"
 *   [t-items]="items">
 *
 *   <ng-template t-list-view-detail-template let-item let-code="index">
 *     <div class="thf-row">
 *       <thf-info class="thf-md-6" t-label="Code" [t-value]="code"></thf-info>
 *       <thf-info class="thf-md-12" t-label="Email" [t-value]="item.email"></thf-info>
 *     </div>
 *   </ng-template>
 *
 * </thf-list-view>
 *
 * ...
 * ```
 *
 * ```
 * ...
 * <thf-list-view
 *    t-property-title="name"
 *    [t-items]="items">
 *    <div *t-list-view-detail-template="let item, let i=index" class="thf-row">
 *      <thf-info class="thf-md-12" t-label="Email" [t-value]="item.email"></thf-info>
 *    </div>
 * </thf-list-view>
 * ...
 *
 * ```
 */
class ThfListViewDetailTemplateDirective {
    // Necessário manter templateRef para o funcionamento do row template.
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ThfListViewDetailTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[t-list-view-detail-template]'
            },] }
];
/** @nocollapse */
ThfListViewDetailTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
ThfListViewDetailTemplateDirective.propDecorators = {
    showDetail: [{ type: Input, args: ['t-show-detail',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfListViewBaseComponent
 *
 * \@example
 *
 * <example name="thf-list-view-basic" title="Totvs List View Basic">
 *  <file name="sample-thf-list-view-basic/sample-thf-list-view-basic.component.html"> </file>
 *  <file name="sample-thf-list-view-basic/sample-thf-list-view-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-list-view-labs" title="Totvs List View Labs">
 *  <file name="sample-thf-list-view-labs/sample-thf-list-view-labs.component.html"> </file>
 *  <file name="sample-thf-list-view-labs/sample-thf-list-view-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-list-view-hiring-processes" title="Totvs List View - Hiring Processes">
 *  <file name="sample-thf-list-view-hiring-processes/sample-thf-list-view-hiring-processes.component.html"> </file>
 *  <file name="sample-thf-list-view-hiring-processes/sample-thf-list-view-hiring-processes.component.ts"> </file>
 *  <file name="sample-thf-list-view-hiring-processes/sample-thf-list-view-hiring-processes.service.ts"> </file>
 * </example>
 */
class ThfListViewComponent extends ThfListViewBaseComponent {
    /**
     * @param {?} changeDetector
     * @param {?} differs
     */
    constructor(changeDetector, differs) {
        super();
        this.changeDetector = changeDetector;
        this.differ = differs.find([]).create(null);
    }
    /**
     * @return {?}
     */
    get hasContentTemplate() {
        return !!this.listViewContentTemplate;
    }
    /**
     * @return {?}
     */
    get hasDetailTemplate() {
        return !!this.listViewDetailTemplate;
    }
    /**
     * @return {?}
     */
    get displayShowMoreButton() {
        return this.items && this.items.length > 0 && this.showMore.observers.length > 0;
    }
    /**
     * @return {?}
     */
    get showButtonsActions() {
        return this.visibleActions && this.visibleActions.length > 0 && this.visibleActions.length <= 2;
    }
    /**
     * @return {?}
     */
    get showPopupActions() {
        return this.visibleActions && this.visibleActions.length > 2;
    }
    /**
     * @return {?}
     */
    get titleHasAction() {
        return this.titleAction.observers.length > 0;
    }
    /**
     * @return {?}
     */
    get visibleActions() {
        return this.actions && this.actions.filter((/**
         * @param {?} action
         * @return {?}
         */
        action => action.visible !== false));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.initShowDetail();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.checkItemsChange();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    checkTitleType(item) {
        if (this.propertyLink && item[this.propertyLink]) {
            return item[this.propertyLink].startsWith('http') ? 'externalLink' : 'internalLink';
        }
        return 'noLink';
    }
    /**
     * @param {?} item
     * @return {?}
     */
    getItemTitle(item) {
        return this.hasContentTemplate && this.listViewContentTemplate.title ?
            this.listViewContentTemplate.title(item) : item[this.propertyTitle];
    }
    /**
     * @return {?}
     */
    hasItems() {
        return this.items && this.items.length > 0;
    }
    /**
     * @param {?} listViewAction
     * @param {?} item
     * @return {?}
     */
    returnBooleanValue(listViewAction, item) {
        return isTypeof(listViewAction.disabled, 'function') ? ((/** @type {?} */ (listViewAction))).disabled(item) : listViewAction.disabled;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    trackBy(index) {
        return index;
    }
    /**
     * @param {?} item
     * @param {?} targetRef
     * @return {?}
     */
    togglePopup(item, targetRef) {
        this.popupTarget = targetRef;
        this.changeDetector.detectChanges();
        this.thfPopupComponent.toggle(item);
    }
    /**
     * @private
     * @return {?}
     */
    checkItemsChange() {
        /** @type {?} */
        const changesItems = this.differ.diff(this.items);
        if (changesItems && this.selectAll) {
            this.selectAll = null;
        }
        if (changesItems && this.items && this.items.length && this.select && !this.hideSelectAll) {
            this.showHeader = true;
        }
    }
    /**
     * @private
     * @return {?}
     */
    initShowDetail() {
        if (this.items && this.items.length > 0 && this.hasDetailTemplate && this.listViewDetailTemplate.showDetail) {
            this.items.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => item.$showDetail = this.listViewDetailTemplate.showDetail(item)));
        }
    }
}
ThfListViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-list-view',
                template: "\n<div\n  [class.thf-list-view-main-container-header]=\"showHeader\"\n  [class.thf-list-view-main-container]=\"!showHeader\"\n  [style.height.px]=\"height\">\n\n  <div *ngIf=\"showHeader\" class=\"thf-list-view-main-header\">\n    <div class=\"thf-checkbox-group-item\">\n      <div class=\"thf-list-view-main-select\">\n        <input class=\"thf-input thf-checkbox-group-input\" type=\"checkbox\"\n          [class.thf-checkbox-group-input-checked]=\"selectAll\"\n          [class.thf-checkbox-group-input-indeterminate]=\"selectAll === null\">\n        <label\n          class=\"thf-checkbox-group-label thf-clickable\"\n          (click)=\"selectAllListItems()\">\n          {{ literals.selectAll }}\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"thf-list-view-main-content\">\n    <div class=\"thf-list-view\" *ngIf=\"!hasItems()\">\n      <div class=\"thf-list-view-container-no-data thf-text-center\">\n        <span> {{ literals.noData }} </span>\n      </div>\n    </div>\n\n    <ng-container *ngFor=\"let item of items; let index = index; trackBy: trackBy\">\n      <div class=\"thf-list-view\">\n        <div class=\"thf-list-view-container\">\n          <div class=\"thf-list-view-header\">\n            <div class=\"thf-list-view-title\" [ngSwitch]=\"checkTitleType(item)\">\n              <div *ngIf=\"select\" class=\"thf-list-view-select\">\n                <input class=\"thf-input thf-checkbox-group-input\" type=\"checkbox\"\n                  [class.thf-checkbox-group-input-checked]=\"item.$selected\">\n                <label class=\"thf-checkbox-group-label thf-clickable\" (click)=\"selectListItem(item)\"></label>\n              </div>\n              <a *ngSwitchCase=\"'externalLink'\"\n                class=\"thf-list-view-title-link\"\n                target=\"_blank\"\n                [href]=\"item[propertyLink]\"\n                (click)=\"runTitleAction(item)\">\n                {{ getItemTitle(item) }}\n              </a>\n              <a *ngSwitchCase=\"'internalLink'\"\n                class=\"thf-list-view-title-link\"\n                [routerLink]=\"item[propertyLink]\"\n                (click)=\"runTitleAction(item)\">\n                {{ getItemTitle(item) }}\n              </a>\n              <span *ngSwitchCase=\"'noLink'\"\n                class=\"thf-list-view-title-no-link\"\n                [class.thf-list-view-title-link]=\"titleHasAction\"\n                (click)=\"titleHasAction && runTitleAction(item)\">\n                {{ getItemTitle(item) }}\n              </span>\n            </div>\n\n            <div *ngIf=\"showButtonsActions\" class=\"thf-list-view-actions\">\n              <thf-button *ngFor=\"let action of visibleActions\"\n                t-small=\"true\"\n                [t-disabled]=\"returnBooleanValue(action, item)\"\n                [t-icon]=\"action.icon\"\n                [t-label]=\"action.label\"\n                [t-type]=\"action.type\"\n                (t-click)=\"onClickAction(action, item)\">\n              </thf-button>\n            </div>\n\n            <div *ngIf=\"showPopupActions\" class=\"thf-list-view-more-actions\">\n              <span #popupTarget\n                class=\"thf-icon thf-icon-more thf-list-view-more-icon thf-clickable\"\n                (click)=\"togglePopup(item, popupTarget)\">\n              </span>\n            </div>\n\n          </div>\n\n          <div *ngIf=\"hasContentTemplate\" class=\"thf-list-view-content\">\n            <ng-template\n              [ngTemplateOutlet]=\"listViewContentTemplate.templateRef\"\n              [ngTemplateOutletContext]=\"{ $implicit: item, index: index }\">\n            </ng-template>\n          </div>\n\n          <div @showHideDetail *ngIf=\"hasDetailTemplate && item.$showDetail\" class=\"thf-list-view-detail\">\n            <ng-template\n              [ngTemplateOutlet]=\"listViewDetailTemplate.templateRef\"\n              [ngTemplateOutletContext]=\"{ $implicit: item, index: index }\">\n            </ng-template>\n          </div>\n        </div>\n\n        <div *ngIf=\"hasDetailTemplate\" class=\"thf-list-view-detail-button\">\n          <span class=\"thf-clickable\" (click)=\"item.$showDetail = !item.$showDetail\">\n            {{ item.$showDetail ? literals.hideDetails : literals.showDetails }}\n          </span>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n\n<div *ngIf=\"displayShowMoreButton\" class=\"thf-mb-2 thf-text-center\">\n  <thf-button\n    [t-disabled]=\"showMoreDisabled\"\n    [t-label]=\"literals.loadMoreData\"\n    (t-click)=\"onShowMore()\">\n  </thf-button>\n</div>\n\n<thf-popup #popup [t-actions]=\"actions\" [t-target]=\"popupTarget\">\n</thf-popup>\n",
                animations: [
                    trigger('showHideDetail', [
                        state('*', style({ 'overflow-y': 'visible' })),
                        state('void', style({ 'overflow-y': 'hidden' })),
                        transition('* => void', [
                            style({ height: '*', 'overflow-y': 'hidden' }),
                            animate(100, style({ height: 0 }))
                        ]),
                        transition('void => *', [
                            style({ height: '0' }),
                            animate(100, style({ height: '*' }))
                        ])
                    ])
                ]
            }] }
];
/** @nocollapse */
ThfListViewComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IterableDiffers }
];
ThfListViewComponent.propDecorators = {
    listViewContentTemplate: [{ type: ContentChild, args: [ThfListViewContentTemplateDirective, { static: true },] }],
    listViewDetailTemplate: [{ type: ContentChild, args: [ThfListViewDetailTemplateDirective, { static: true },] }],
    thfPopupComponent: [{ type: ViewChild, args: ['popup', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente `thf-list-view`.
 *
 * > Para o correto funcionamento do componente `thf-list-view`, deve ser importado o módulo `BrowserAnimationsModule` no
 * > módulo principal da sua aplicação.
 *
 * Módulo da aplicação:
 * ```
 * import { BrowserAnimationsModule } from '\@angular/platform-browser/animations';
 * import { ThfModule } from '\@totvs/thf-ui';
 * ...
 *
 * \@NgModule({
 *   imports: [
 *     BrowserModule,
 *     BrowserAnimationsModule,
 *     ...
 *     ThfModule
 *   ],
 *   declarations: [
 *     AppComponent,
 *     ...
 *   ],
 *   providers: [],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule { }
 * ```
 */
class ThfListViewModule {
}
ThfListViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    ThfButtonModule,
                    ThfPopupModule
                ],
                declarations: [
                    ThfListViewComponent,
                    ThfListViewContentTemplateDirective,
                    ThfListViewDetailTemplateDirective
                ],
                exports: [
                    ThfListViewComponent,
                    ThfListViewContentTemplateDirective,
                    ThfListViewDetailTemplateDirective
                ],
                providers: [],
                schemas: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_BADGE_COLORS = [
    'color-01',
    'color-02',
    'color-03',
    'color-04',
    'color-05',
    'color-06',
    'color-07',
    'color-08',
    'color-09',
    'color-10',
    'color-11',
    'color-12',
];
/** @type {?} */
const THF_BADGE_COLOR_DEFAULT = 'color-07';
/**
 * \@description
 *
 * \@docsPrivate
 *
 * Componente utilizado no `thf-menu` para exibir por exemplo a quantidade de tarefas pendentes.
 */
class ThfBadgeBaseComponent {
    /**
     * \@optional
     *
     * \@description
     *
     * Define a cor de fundo do componente e aceita os valores:
     *
     * <span class="dot thf-color-01"></span> `color-01`
     *
     * <span class="dot thf-color-02"></span> `color-02`
     *
     * <span class="dot thf-color-03"></span> `color-03`
     *
     * <span class="dot thf-color-04"></span> `color-04`
     *
     * <span class="dot thf-color-05"></span> `color-05`
     *
     * <span class="dot thf-color-06"></span> `color-06`
     *
     * <span class="dot thf-color-07"></span> `color-07`
     *
     * <span class="dot thf-color-08"></span> `color-08`
     *
     * <span class="dot thf-color-09"></span> `color-09`
     *
     * <span class="dot thf-color-10"></span> `color-10`
     *
     * <span class="dot thf-color-11"></span> `color-11`
     *
     * <span class="dot thf-color-12"></span> `color-12`
     *
     * \@default `color-07`
     * @param {?} value
     * @return {?}
     */
    set color(value) {
        this._color = THF_BADGE_COLORS.includes(value) ? value : THF_BADGE_COLOR_DEFAULT;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * \@description
     *
     * Número exibido no componente, caso o mesmo seja maior que 99 o valor exibido será 99+.
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = convertToInt(value);
        this.setBadgeValue(this._value);
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setBadgeValue(value) {
        /** @type {?} */
        const validRangeValue = (value || value === 0) && (value >= 0 && value < 100);
        this.badgeValue = validRangeValue ? value.toString() : value > 99 ? '99+' : undefined;
    }
}
ThfBadgeBaseComponent.propDecorators = {
    color: [{ type: Input, args: ['t-color',] }],
    value: [{ type: Input, args: ['t-value',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfBadgeBaseComponent
 *
 * \@docsPrivate
 */
class ThfBadgeComponent extends ThfBadgeBaseComponent {
}
ThfBadgeComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-badge',
                template: "<div class=\"thf-badge thf-{{ color }}\">\n  <span class=\"thf-badge-value\">{{ badgeValue }}</span>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-badge.
 */
class ThfBadgeModule {
}
ThfBadgeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ThfBadgeComponent
                ],
                exports: [
                    ThfBadgeComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfMenuLiteralsDefault = {
    en: { itemNotFound: 'Item not found.' },
    es: { itemNotFound: 'Elemento no encontrado.' },
    pt: { itemNotFound: 'Item não encontrado.' }
};
/**
 * \@description
 *
 * Este é um componente de menu lateral que é utilizado para navegação nas páginas de uma aplicação.
 *
 * O componente thf-menu recebe uma lista de objetos do tipo `MenuItem` com as informações dos itens de menu como
 * textos, links para redirecionamento, ações, até 4 níveis de menu e ícones para o primeiro nível de menu.
 * @abstract
 */
class ThfMenuBaseComponent {
    /**
     * @param {?} menuService
     */
    constructor(menuService) {
        this.menuService = menuService;
        this._collapsed = false;
        this._filter = false;
        this._maxLevel = 4;
        this._menus = [];
        this.literals = Object.assign({}, thfMenuLiteralsDefault[thfLocaleDefault], thfMenuLiteralsDefault[browserLanguage()]);
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Colapsa (retrai) o menu e caso receba o valor `false` expande o menu.
     *
     * > Utilize esta propriedade para iniciar o menu colapsado.
     *
     * > Ao utilizar os métodos [`colapse`](documentation/thf-menu#colapseMethod), [`expand`](documentation/thf-menu#expandMethod) e
     * [`toggle`](documentation/thf-menu#toggleMethod) o valor desta propriedade não é alterado.
     *
     * **Importante:**
     *
     * > O menu será colapsado/expandido apenas se todos os itens de menu tiverem valor nas propriedades `icon` e `shortLabel`.
     *
     * \@default `false`
     * @param {?} collapsed
     * @return {?}
     */
    set collapsed(collapsed) {
        this._collapsed = convertToBoolean(collapsed);
        this.validateCollapseClass();
    }
    /**
     * @return {?}
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * Lista dos itens do menu. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio.
     * @param {?} menus
     * @return {?}
     */
    set menus(menus) {
        this._menus = Array.isArray(menus) ? menus : [];
    }
    /**
     * @return {?}
     */
    get menus() {
        return this._menus;
    }
    /**
     * @return {?}
     */
    get maxLevel() {
        return this._maxLevel;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Habilita um campo para pesquisa no menu.
     * A pesquisa é realizada em todos os níveis do menu e busca apenas pelos itens que contém uma ação e/ou link definidos,
     * ou também, pode ser realizada através de um serviço definido na propriedade `t-service`.
     *
     * > O campo de pesquisa é desabilitado se o menu estiver colapsado.
     *
     * \@default `false`
     * @param {?} filter
     * @return {?}
     */
    set filter(filter) {
        this._filter = (/** @type {?} */ (filter)) === '' ? true : convertToBoolean(filter);
        this.filteredItems = [...this._menus];
    }
    /**
     * @return {?}
     */
    get filter() {
        return this._filter;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Nesta propriedade deve ser informada a URL do serviço em que será utilizado para realizar o filtro de itens do
     * menu quando realizar uma busca. Caso haja a necessidade de customização, pode ser informado um
     * serviço implementando a interface `ThfMenuFilter`.
     *
     * Caso utilizada uma URL, o serviço deve retornar os dados conforme o
     * [Guia de implementação de API da Totvs](http://tdn.totvs.com/display/public/INT/Guia+de+implementacao+das+APIs+TOTVS).
     *
     * Quando utilizada uma URL de serviço, será realizado um *GET* na URL informada, passando o valor digitado
     * no parâmetro `search`, veja exemplo:
     *
     * > O filtro no serviço será realizado caso contenha no mínimo três caracteres no campo de busca, por exemplo `tot`.
     *
     * ```
     * <thf-menu t-service="/api/v1/fnd/menu">
     * </thf-menu>
     *
     * Requisição: GET /api/v1/fnd/menu?search=contas
     * ```
     *
     * > É necessário que propriedade `t-filter` esteja habilitada.
     * @param {?} value
     * @return {?}
     */
    set service(value) {
        this._service = value || undefined;
        this.configService(this.service);
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Deve ser informado um objeto que deseja-se utilizar na requisição de filtro dos itens de menu.
     *
     * Caso utilizado um serviço customizado, implementando a interface `ThfMenuFilter`, o valor desta propriedade
     * será passado como parâmetro, na função `getFilteredData`.
     *
     * Quando utilizada uma URL de serviço, será realizado um *GET* na URL informada, passando os valores informados
     * nesta propriedade em conjunto com o parâmetro `search`, veja exemplo:
     *
     * ```
     * <thf-menu t-service="/api/v1/fnd/menu" [t-params]="{ company: 1, user: 297767512 }">
     * </thf-menu>
     *
     * Requisição: GET /api/v1/fnd/menu?search=contas&company=1&user=297767512
     * ```
     * @param {?} value
     * @return {?}
     */
    set params(value) {
        this._params = value && isTypeof(value, 'object') ? value : undefined;
    }
    /**
     * @return {?}
     */
    get params() {
        return this._params;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Caminho para a logomarca, que será exibida quando o componente estiver expandido, localizada na parte superior.
     *
     * > **Importante:**
     * - Caso esta propriedade estiver indefinida ou inválida o espaço para logomarca será removido.
     * - Como boa prática, indica-se utilizar imagens com até `24px` de altura e `224px` de largura,
     * caso ultrapassar esses valores a imagem será readequada no espaço disponível.
     * @param {?} value
     * @return {?}
     */
    set logo(value) {
        this._logo = isTypeof(value, 'string') && value.trim() ? value : undefined;
    }
    /**
     * @return {?}
     */
    get logo() {
        return this._logo;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Caminho para a logomarca, que será exibida quando o componente estiver colapsado, localizada na parte superior.
     *
     * > **Importante:**
     * - Caso esta propriedade estiver indefinida ou inválida passa a assumir o valor informado na propriedade `t-logo` e na ausência desta o
     * espaço para logomarca será removido.
     * - Como boa prática, indica-se utilizar imagens com até `48px` de altura e `48px` de largura,
     * caso ultrapassar esses valores a imagem será readequada no espaço disponível.
     * - Caso não informar um valor, esta propriedade passa a assumir o valor informado na propriedade `t-logo`.
     * @param {?} value
     * @return {?}
     */
    set shortLogo(value) {
        this._shortLogo = isTypeof(value, 'string') && value.trim() ? value : undefined;
    }
    /**
     * @return {?}
     */
    get shortLogo() {
        return this._shortLogo;
    }
    /**
     * @private
     * @param {?} service
     * @return {?}
     */
    configService(service) {
        if (typeof service === 'string' && service.trim()) {
            // service url
            this.menuService.configProperties(service);
            this.filterService = this.menuService;
        }
        else if (typeof service === 'object' && service.getFilteredData) {
            // custom service
            this.filterService = service;
        }
        else {
            this.filterService = undefined;
        }
    }
    /**
     * @protected
     * @return {?}
     */
    setMenuExtraProperties() {
        this.allowIcons = !!this.menus.length;
        this.allowCollapseMenu = !!this.menus.length;
        this.menus.forEach((/**
         * @param {?} menuItem
         * @return {?}
         */
        menuItem => {
            this._level = 1;
            this.allowIcons = this.allowIcons ? validValue(menuItem.icon) : false;
            this.allowCollapseMenu = this.allowCollapseMenu && this.allowIcons ? validValue(menuItem.shortLabel) : false;
            this.removeBadgeAlert(menuItem);
            this.setMenuItemProperties(menuItem);
            if (menuItem.subItems) {
                this._level++;
                this.processSubItems(menuItem);
            }
        }));
    }
    /**
     * @protected
     * @param {?} menuItem
     * @return {?}
     */
    setMenuItemProperties(menuItem) {
        menuItem['id'] = menuItem['id'] || v4();
        menuItem['level'] = this._level;
        menuItem['type'] = this.setMenuType(menuItem);
    }
    /**
     * @protected
     * @param {?} menus
     * @return {?}
     */
    validateMenus(menus) {
        menus.forEach((/**
         * @param {?} menu
         * @return {?}
         */
        menu => this.validateMenu(menu)));
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    processSubItems(menu) {
        menu.subItems.forEach((/**
         * @param {?} menuItem
         * @param {?} index
         * @param {?} menuItems
         * @return {?}
         */
        (menuItem, index, menuItems) => {
            /** @type {?} */
            const previousItem = menuItems[index - 1];
            if (previousItem && previousItem.subItems) {
                this._level = previousItem['level'];
            }
            if (this._level <= this.maxLevel) {
                this.setMenuItemProperties(menuItem);
                if (menuItem.subItems) {
                    this._level++;
                    this.processSubItems(menuItem);
                }
            }
            if (!menu['badgeAlert']) {
                menu = this.setMenuBadgeAlert(menu, menuItem);
            }
        }));
        menu.subItems = Object.assign([], menu.subItems);
    }
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    removeBadgeAlert(menuItem) {
        if (menuItem['badgeAlert']) {
            delete menuItem['badgeAlert'];
        }
        if (menuItem.subItems) {
            menuItem.subItems.forEach((/**
             * @param {?} subItem
             * @return {?}
             */
            subItem => this.removeBadgeAlert(subItem)));
        }
    }
    /**
     * @private
     * @param {?} parent
     * @param {?} child
     * @return {?}
     */
    setMenuBadgeAlert(parent, child) {
        /** @type {?} */
        const childHasSubItems = child.subItems && child.subItems.length;
        /** @type {?} */
        const childHasBadgeAlert = child['badgeAlert'];
        /** @type {?} */
        const childHasBadge = child.badge && convertToInt(child.badge.value) >= 0;
        parent['badgeAlert'] = childHasBadgeAlert || (childHasBadge && !childHasSubItems);
        return parent;
    }
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    setMenuType(menuItem) {
        if (menuItem.subItems && menuItem.subItems.length > 0 && this._level < this.maxLevel) {
            return 'subItems';
        }
        if (!menuItem.link) {
            return 'noLink';
        }
        if (isExternalLink(menuItem.link)) {
            return 'externalLink';
        }
        return 'internalLink';
    }
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    validateMenu(menuItem) {
        if (!menuItem.label || menuItem.label.trim() === '') {
            throw new Error('O atributo ThfMenuItem.label não pode ser vazio.');
        }
        else if (menuItem.subItems) {
            menuItem.subItems.forEach((/**
             * @param {?} subItem
             * @return {?}
             */
            subItem => {
                this.validateMenu(subItem);
            }));
        }
    }
}
ThfMenuBaseComponent.propDecorators = {
    collapsed: [{ type: Input, args: ['t-collapsed',] }],
    menus: [{ type: Input, args: ['t-menus',] }],
    filter: [{ type: Input, args: ['t-filter',] }],
    service: [{ type: Input, args: ['t-service',] }],
    params: [{ type: Input, args: ['t-params',] }],
    logo: [{ type: Input, args: ['t-logo',] }],
    shortLogo: [{ type: Input, args: ['t-short-logo',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfMenuComponent
 *
 * \@description
 *
 * Esta diretiva permite adicionar um conteúdo personalizado entre a logo e o campo de filtro do cabeçalho do
 * [`thf-menu`](/documentation/thf-menu).
 *
 * Para personalizar o conteúdo do cabeçalho deve-se utilizar a diretiva `t-menu-header-template` dentro da *tag* do
 * [`thf-menu`](/documentation/thf-menu). Podendo ser utilizada de duas formas:
 *
 * Com `ng-template`
 * ```
 * ...
 * <thf-menu [t-menus]="menus">
 *   <ng-template t-menu-header-template>
 *     ...
 *   </ng-template>
 * </thf-menu>
 * ...
 * ```
 *
 * ou com *syntax sugar*
 * ```
 * ...
 * <thf-menu [t-menus]="menus">
 *   <div *t-menu-header-template>
 *     ...
 *   </div>
 * </thf-menu>
 * ...
 * ```
 *
 * > Quando o menu estiver colapsado ou tela for _mobile_ o conteúdo personalizado não será exibido.
 */
class ThfMenuHeaderTemplateDirective {
    // Necessário manter templateRef para o funcionamento do row template.
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ThfMenuHeaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[t-menu-header-template]'
            },] }
];
/** @nocollapse */
ThfMenuHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço que implementa a comunicação entre os items do thf-menu.
 */
class ThfMenuItemsService {
    constructor() {
        this.subjectParent = new Subject();
        this.subjectChild = new Subject();
    }
    // Envia informações do click do thf-menu-item para o thf-menu
    /**
     * @param {?} menu
     * @return {?}
     */
    sendToParentMenuClicked(menu) {
        this.subjectChild.next(menu);
    }
    // Recebe do thf-menu-item sua informação de click.
    /**
     * @return {?}
     */
    receiveFromChildMenuClicked() {
        return this.subjectChild.asObservable();
    }
    // Envia para os thf-menu-item a resposta do processamento de click de um thf-menu-item.
    /**
     * @param {?} menu
     * @return {?}
     */
    sendToChildMenuClicked(menu) {
        this.subjectParent.next(menu);
    }
    // Recebe do thf-menu as informações processadas do click de um thf-menu-item.
    /**
     * @return {?}
     */
    receiveFromParentMenuClicked() {
        return this.subjectParent.asObservable();
    }
}
ThfMenuItemsService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço que implementa a interface `ThfMenuFilter`, utilizado para fazer requisições ao serviço informado pelo usuário,
 * caso for uma URL, no componente `thf-menu`.
 */
class ThfMenuService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
    }
    /**
     * @return {?}
     */
    get url() { return this._url; }
    /**
     * @param {?} url
     * @return {?}
     */
    configProperties(url) {
        this._url = url;
    }
    /**
     * @param {?} search
     * @param {?=} params
     * @return {?}
     */
    getFilteredData(search, params) {
        /** @type {?} */
        const filterParams = Object.assign({ search }, params);
        return this.http.get(this.url, { params: filterParams })
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => response && response.items)));
    }
}
ThfMenuService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfMenuService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfMenuDebounceTime = 400;
/** @type {?} */
const thfMenuMinLength = 3;
/** @type {?} */
const thfMenuRootLevel = 1;
/**
 * \@docsExtends ThfMenuBaseComponent
 *
 * \@description
 *
 * Aparece completo em telas com largura maior que 1200px, caso contrário o menu é escondido e chamado por meio de um botão.
 *
 * O menu também pode ser colapsado. Essa opção é habilitada quando todos os itens de primeiro nível possuírem ícones e textos curtos.
 * Se colapsado, somente os itens de primeiro nível serão exibidos e, caso o item selecionado possua sub-níveis,
 * então o menu alternará novamente para o estado aberto.
 *
 * Existe a possibilidade de customizar a logomarca, que é exibida na parte superior do componente.
 *
 * E para adicionar um conteúdo personalizado entre a logomarca e o campo de filtro,
 * basta adicionar este conteúdo com a diretiva [**t-menu-header-template**](/documentation/thf-menu-header-template).
 *
 * Caso utilizar o filtro de menus, é possível realizar buscas em serviço, apenas informando a URL do serviço ou a instância de
 * um serviço customizado implementando a interface `ThfMenuFilter`.
 *
 * Para o menu funcionar corretamente é necessário importar o `RouterModule` e `Routes` do módulo principal de
 *  sua aplicação:
 *
 * ````
 * import { RouterModule, Routes } from '\@angular/router';
 *
 * ...
 *
 * \@NgModule({
 *   imports: [
 *     RouterModule,
 *     Routes,
 *     ...
 *     ThfModule,
 *     ...
 *   ],
 *   declarations: [
 *     AppComponent
 *   ],
 *   providers: [],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule { }
 * ```
 *
 * Além disso é necessário criar um módulo configurando as rotas da aplicação.
 *
 * ```
 * import { NgModule } from '\@angular/core';
 *
 * import { RouterModule, Routes } from '\@angular/router';
 *
 * import { HelloWorldComponent } from './hello-world/hello-world.component';
 *
 * const routes: Routes = [
 *   {path: 'hello-world', component: HelloWorldComponent}
 * ];
 *
 * \@NgModule({
 *   imports: [RouterModule.forRoot(routes, {useHash: true})],
 *   exports: [RouterModule]
 * })
 * export class AppRoutingModule {}
 * ```
 *
 * \@example
 *
 * <example name="thf-menu-basic" title="Totvs Menu Basic">
 *   <file name="sample-thf-menu-basic/sample-thf-menu-basic.component.html"> </file>
 *   <file name="sample-thf-menu-basic/sample-thf-menu-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-menu-labs" title="Totvs Menu Labs">
 *   <file name="sample-thf-menu-labs/sample-thf-menu-labs.component.html"> </file>
 *   <file name="sample-thf-menu-labs/sample-thf-menu-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-menu-human-resources" title="Totvs Menu - Human Resources">
 *   <file name="sample-thf-menu-human-resources/sample-thf-menu-human-resources.component.html"> </file>
 *   <file name="sample-thf-menu-human-resources/sample-thf-menu-human-resources.component.ts"> </file>
 *   <file name="sample-thf-menu-human-resources/sample-thf-menu-human-resources.service.ts"> </file>
 * </example>
 */
class ThfMenuComponent extends ThfMenuBaseComponent {
    /**
     * @param {?} viewRef
     * @param {?} element
     * @param {?} renderer
     * @param {?} router
     * @param {?} menuItemsService
     * @param {?} changeDetector
     * @param {?} menuService
     */
    constructor(viewRef, element, renderer, router, menuItemsService, changeDetector, menuService) {
        super(menuService);
        this.element = element;
        this.renderer = renderer;
        this.router = router;
        this.menuItemsService = menuItemsService;
        this.changeDetector = changeDetector;
        this.filterLoading = false;
        this.mobileOpened = false;
        this.noData = false;
        this.filteringItems = false;
        this.menuInitialized = false;
        this.menuPrevious = null;
        this.parentRef = viewRef['_view']['component'];
    }
    /**
     * @private
     * @return {?}
     */
    get isActiveItemMenuSubMenu() {
        return this.activeMenuItem['level'] > this.groupedMenuItem['level'];
    }
    /**
     * @return {?}
     */
    get enableCollapse() {
        return this.isCollapsed && !this.collapsedMobile;
    }
    /**
     * @return {?}
     */
    get enableCollapseButton() {
        return this.allowCollapseMenu && !this.collapsed && !this.mobileOpened;
    }
    /**
     * @return {?}
     */
    get hasFooter() {
        return this.allowCollapseMenu && !this.mobileOpened && this.enableCollapseButton || (this.collapsed && !this.collapsedMobile);
    }
    /**
     * @return {?}
     */
    get isCollapsed() {
        return this.allowCollapseMenu && this.collapsed;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.filteringItems && this.filter) {
            return;
        }
        /** @type {?} */
        const menuCurrent = JSON.stringify(this.menus);
        if (this.menuPrevious !== menuCurrent || !this.menuInitialized) {
            this.updateMenu();
            this.validateCollapseClass();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.itemSubscription.unsubscribe();
        this.routeSubscription.unsubscribe();
        if (this.resizeListener) {
            this.resizeListener();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscribeToMenuItem();
        this.subscribeToRoute();
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const urlRouter = this.checkingRouterChildrenFragments();
            this.checkActiveMenuByUrl(urlRouter);
        }));
    }
    /**
     * @param {?} urlPath
     * @param {?} menus
     * @return {?}
     */
    activateMenuByUrl(urlPath, menus) {
        if (menus) {
            return menus.some((/**
             * @param {?} menu
             * @return {?}
             */
            menu => {
                /** @type {?} */
                const formattedLink = getFormattedLink(menu.link);
                if (formattedLink === urlPath) {
                    this.linkActive = formattedLink;
                    this.activateMenuItem(menu);
                    return true;
                }
                else {
                    return this.activateMenuByUrl(urlPath, menu.subItems);
                }
            }));
        }
    }
    /**
     * @param {?} urlPath
     * @return {?}
     */
    checkActiveMenuByUrl(urlPath) {
        if (!this.linkActive || this.linkActive !== urlPath) {
            this.activateMenuByUrl(urlPath, this.menus);
        }
    }
    /**
     * <a id="colapseMethod"></a>
     *
     * *Método para colapsar (retrair) o menu.
     * @return {?}
     */
    collapse() {
        this.validateToggleMenu(true);
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    debounceFilter(filter) {
        clearTimeout(this.timeoutFilter);
        this.timeoutFilter = setTimeout((/**
         * @return {?}
         */
        () => {
            this.filterProcess(filter);
        }), thfMenuDebounceTime);
    }
    /**
     * <a id="expandMethod"></a>
     *
     * *Método para expandir (aumentar) o menu.
     * @return {?}
     */
    expand() {
        this.validateToggleMenu(false);
    }
    /**
     * @return {?}
     */
    subscribeToMenuItem() {
        this.itemSubscription = this.menuItemsService.receiveFromChildMenuClicked().subscribe((/**
         * @param {?} menu
         * @return {?}
         */
        (menu) => {
            this.clickMenuItem(menu);
        }));
    }
    /**
     * @return {?}
     */
    subscribeToRoute() {
        this.routeSubscription = this.router.events.subscribe((/**
         * @param {?} val
         * @return {?}
         */
        val => {
            if (val instanceof NavigationEnd || val instanceof NavigationCancel) {
                /** @type {?} */
                const urlRouter = this.checkingRouterChildrenFragments();
                this.checkActiveMenuByUrl(urlRouter);
            }
        }));
    }
    /**
     * <a id="toggleMethod"></a>
     * *Método que colapsa e expande o menu alternadamente.
     *
     * > *Os métodos apenas vão colapsar/expandir o menu se:
     *  - Todos os itens de menu tiverem valor nas propriedades `icon` e `shortLabel`.
     * @return {?}
     */
    toggle() {
        this.validateToggleMenu(!this.collapsed);
    }
    /**
     * @return {?}
     */
    toggleMenuMobile() {
        this.mobileOpened = !this.mobileOpened;
        this.collapsedMobile = this.collapsed && this.mobileOpened;
        this.validateCollapseClass(this.collapsedMobile);
        if (isMobile()) {
            return;
        }
        if (this.mobileOpened) {
            this.createResizeListener();
        }
    }
    /**
     * @private
     * @return {?}
     */
    activateCollapseSubMenuItem() {
        this.clearGroupMenuIfFirstLevel(this.activeMenuItem);
        if (!this.collapsed && this.activeMenuItem['level'] > thfMenuRootLevel && this.isActiveItemMenuSubMenu) {
            this.openParentMenu(this.activeMenuItem);
        }
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    activateMenuItem(menu) {
        this.activeMenuItem = menu;
        this.linkActive = menu.link;
        if (this.activeMenuItem['level'] > thfMenuRootLevel) {
            this.openParentMenu(this.activeMenuItem);
        }
        else {
            this.groupedMenuItem = null;
        }
        this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, grouped: this.groupedMenuItem, activatedByRoute: true });
    }
    /**
     * @private
     * @param {?} menus
     * @return {?}
     */
    areSubMenus(menus) {
        return menus.every((/**
         * @param {?} menu
         * @return {?}
         */
        menu => menu['level'] > thfMenuRootLevel));
    }
    /**
     * @private
     * @return {?}
     */
    checkingRouterChildrenFragments() {
        /** @type {?} */
        const childrenPrimary = this.router.parseUrl(this.router.url).root.children['primary'];
        return childrenPrimary ? `/${childrenPrimary.segments.map((/**
         * @param {?} it
         * @return {?}
         */
        it => it.path)).join('/')}` : '';
    }
    /**
     * @private
     * @param {?} activeMenuItem
     * @return {?}
     */
    clearGroupMenuIfFirstLevel(activeMenuItem) {
        if (activeMenuItem['level'] === thfMenuRootLevel) {
            this.groupedMenuItem = undefined;
        }
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    clickMenuItem(menu) {
        if (menu.action) {
            this.executeMenuAction(menu);
        }
        if (menu['type'] === 'externalLink') {
            openExternalLink(menu.link);
        }
        else if (menu['type'] === 'internalLink') {
            this.activateMenuItem(menu);
        }
        else if (menu['type'] === 'subItems') {
            if (this.filteringItems) {
                this.filteringItems = false;
            }
            this.groupMenuItem(menu);
        }
        if (menu['type'] !== 'subItems') {
            this.mobileOpened = false;
        }
    }
    /**
     * @private
     * @param {?=} menuItem
     * @return {?}
     */
    convertToMenuItemFiltered(menuItem = { label: '', link: '' }) {
        const { label, link } = menuItem;
        /** @type {?} */
        const menuItemFiltered = { label, link };
        this.setMenuItemProperties(menuItemFiltered);
        return menuItemFiltered;
    }
    /**
     * @private
     * @return {?}
     */
    createResizeListener() {
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.toggleResize();
            this.resizeListener();
        }));
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    executeMenuAction(menu) {
        if (typeof menu.action === 'string') {
            this.parentRef[menu.action](menu);
        }
        else {
            menu.action.call(this.parentRef, menu);
        }
    }
    /**
     * @private
     * @param {?} filter
     * @return {?}
     */
    filterItems(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const trimFilter = filter && filter.trim();
            if (trimFilter) {
                this.filteredItems = [];
                this.filteredItems = this.filterService ? yield this.filterOnService(trimFilter) : this.filterLocalItems(trimFilter);
                this.filteringItems = true;
            }
            else {
                this.filteredItems = [...this.menus];
                this.filteringItems = false;
            }
        });
    }
    /**
     * @private
     * @param {?} filter
     * @return {?}
     */
    filterLocalItems(filter) {
        /** @type {?} */
        const filteredItems = [];
        this.findItems(this.menus, filter.toLowerCase(), filteredItems);
        return filteredItems;
    }
    /**
     * @private
     * @param {?} filter
     * @return {?}
     */
    filterProcess(filter) {
        this.filterLoading = true;
        this.filterItems(filter).then((/**
         * @return {?}
         */
        () => {
            this.filterLoading = false;
            this.showNoData();
            this.changeDetector.detectChanges();
            this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, grouped: this.groupedMenuItem });
        })).catch((/**
         * @param {?} error
         * @return {?}
         */
        error => {
            this.filterLoading = false;
            Promise.reject(error);
        }));
    }
    /**
     * @private
     * @param {?=} search
     * @return {?}
     */
    filterOnService(search = '') {
        return __awaiter(this, void 0, void 0, function* () {
            if (search.length >= thfMenuMinLength) {
                return yield this.filterService.getFilteredData(search, this.params)
                    .pipe(map((/**
                 * @param {?} menuItemsFiltered
                 * @return {?}
                 */
                menuItemsFiltered => menuItemsFiltered.map((/**
                 * @param {?} menuItem
                 * @return {?}
                 */
                menuItem => this.convertToMenuItemFiltered(menuItem))))))
                    .toPromise();
            }
            else {
                return this.filteredItems;
            }
        });
    }
    /**
     * @private
     * @param {?} menus
     * @param {?} filter
     * @param {?} filteredItems
     * @return {?}
     */
    findItems(menus, filter, filteredItems) {
        menus.forEach((/**
         * @param {?} menu
         * @return {?}
         */
        menu => {
            if ((menu.label.toLowerCase().includes(filter) && !menu.subItems) ||
                (menu.subItems && this.findItems(menu.subItems, filter, filteredItems))) {
                filteredItems.push(menu);
            }
        }));
    }
    /**
     * @private
     * @param {?} menus
     * @param {?} menuItem
     * @return {?}
     */
    findParent(menus, menuItem) {
        /** @type {?} */
        const getParent = (/**
         * @param {?} menuItems
         * @param {?} id
         * @return {?}
         */
        function (menuItems, id) {
            if (menuItems) {
                for (let index = 0; index < menuItems.length; index++) {
                    /** @type {?} */
                    const menu = menuItems[index];
                    if (menu.subItems && menu.subItems.find((/**
                     * @param {?} subItem
                     * @return {?}
                     */
                    subItem => subItem['id'] === id))) {
                        return menu;
                    }
                    /** @type {?} */
                    const found = getParent(menu.subItems, id);
                    if (found) {
                        return found;
                    }
                }
            }
        });
        return getParent(menus, menuItem['id']);
    }
    /**
     * @private
     * @param {?} menus
     * @param {?} menu
     * @return {?}
     */
    findRootParent(menus, menu) {
        /** @type {?} */
        const findParent = this.findParent;
        /** @type {?} */
        const getRootParent = (/**
         * @param {?} menuItems
         * @param {?} menuItem
         * @return {?}
         */
        function (menuItems, menuItem) {
            /** @type {?} */
            let parent = findParent(menuItems, menuItem);
            if (parent['level'] !== thfMenuRootLevel) {
                parent = getRootParent(menuItems, parent);
            }
            return parent;
        });
        return getRootParent(menus, menu);
    }
    /**
     * @private
     * @param {?} menus
     * @param {?} activeMenuItem
     * @param {?} groupedMenuItem
     * @return {?}
     */
    getActiveMenuParent(menus, activeMenuItem, groupedMenuItem) {
        if (this.areSubMenus([groupedMenuItem, activeMenuItem])) {
            return this.findRootParent(menus, activeMenuItem);
        }
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    groupMenuItem(menu) {
        if (this.collapsed) {
            this.toggleMenuCollapse();
        }
        menu['isOpened'] = !menu['isOpened'];
        this.groupedMenuItem = menu;
        if (this.activeMenuItem && menu['isOpened']
            && this.isActiveItemMenuSubMenu
            && this.isRootMenuEqualGroupedMenu(this.menus, this.activeMenuItem, menu)) {
            this.activateMenuItem(this.activeMenuItem);
        }
        this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, grouped: this.groupedMenuItem });
    }
    /**
     * @private
     * @param {?} menus
     * @param {?} activeMenuItem
     * @param {?} groupedMenuItem
     * @return {?}
     */
    isRootMenuEqualGroupedMenu(menus, activeMenuItem, groupedMenuItem) {
        /** @type {?} */
        const activeMenuRootParent = this.findRootParent(menus, activeMenuItem);
        return activeMenuRootParent['id'] === groupedMenuItem['id'];
    }
    /**
     * @private
     * @param {?} childMenu
     * @return {?}
     */
    openParentMenu(childMenu) {
        /** @type {?} */
        const parent = this.findParent(this.menus, childMenu);
        parent['isOpened'] = true;
        this.groupedMenuItem = parent;
    }
    /**
     * @private
     * @return {?}
     */
    showNoData() {
        this.noData = this.filteredItems.length === 0;
    }
    /**
     * @private
     * @return {?}
     */
    toggleGroupedMenuItem() {
        this.groupedMenuItem['isOpened'] = !this.collapsed && this.allowCollapseMenu;
    }
    /**
     * @private
     * @param {?=} collapsed
     * @return {?}
     */
    toggleMenuCollapse(collapsed = false) {
        this.collapsed = collapsed;
        if (this.groupedMenuItem && this.activeMenuItem) {
            this.groupedMenuItem = this.getActiveMenuParent(this.menus, this.activeMenuItem, this.groupedMenuItem) || this.groupedMenuItem;
            this.toggleGroupedMenuItem();
        }
        if (this.activeMenuItem) {
            this.activateCollapseSubMenuItem();
            this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, grouped: this.groupedMenuItem, activatedByRoute: true });
        }
        this.updateMenu();
    }
    /**
     * @private
     * @return {?}
     */
    toggleResize() {
        if (this.mobileOpened) {
            this.mobileOpened = false;
            this.collapsedMobile = false;
            this.validateCollapseClass(this.collapsedMobile);
        }
    }
    /**
     * @private
     * @param {?} collapsed
     * @return {?}
     */
    validateToggleMenu(collapsed) {
        if (!this.allowCollapseMenu) {
            return;
        }
        this.toggleMenuCollapse(collapsed);
    }
    /**
     * @private
     * @return {?}
     */
    updateMenu() {
        this.menuInitialized = true;
        this.setMenuExtraProperties();
        this.filteredItems = [...this.menus];
        this.menuPrevious = JSON.stringify(this.menus);
        this.validateMenus(this.menus);
    }
    /**
     * @protected
     * @param {?=} collapsedMobile
     * @return {?}
     */
    validateCollapseClass(collapsedMobile) {
        /** @type {?} */
        const wrapper = this.element.nativeElement.parentNode;
        this.renderer[this.isCollapsed && !collapsedMobile ? 'addClass' : 'removeClass'](wrapper, 'thf-collapsed-menu');
    }
}
ThfMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-menu',
                template: "<div *ngIf=\"mobileOpened\" class=\"thf-menu-overlay\" (click)=\"toggleMenuMobile()\"></div>\n<div class=\"thf-menu-mobile thf-clickable\" (click)=\"toggleMenuMobile()\">\n  <span class=\"thf-icon thf-icon-menu\"></span>\n</div>\n\n<div class=\"thf-menu\" [ngClass]=\"{ 'thf-menu-animation' : mobileOpened }\">\n\n  <div class=\"thf-menu-header\">\n    <div *ngIf=\"logo || (shortLogo && enableCollapse)\" class=\"thf-menu-header-container-logo\">\n      <a href=\"./\">\n        <img\n          [ngClass]=\"enableCollapse ? 'thf-menu-short-logo' : 'thf-menu-logo'\"\n          [src]=\"enableCollapse ? shortLogo || logo : logo\">\n      </a>\n    </div>\n\n    <div *ngIf=\"!enableCollapse && menuHeaderTemplate\" class=\"thf-menu-header-template\">\n      <ng-container *ngTemplateOutlet=\"menuHeaderTemplate.templateRef\"></ng-container>\n    </div>\n\n    <thf-menu-filter *ngIf=\"filter && !enableCollapse\"\n      [t-loading]=\"filterLoading\"\n      (t-filter)=\"debounceFilter($event)\">\n    </thf-menu-filter>\n  </div>\n\n  <nav class=\"thf-menu-body\">\n\n    <!-- Inner e outer para esconder scroll -->\n    <div class=\"thf-menu-outer\">\n      <div class=\"thf-menu-inner\">\n\n        <div *ngIf=\"noData\" class=\"thf-menu-item-wrapper\">\n          <div class=\"thf-menu-item-first\">\n            <div class=\"thf-menu-icon-container thf-menu-item-no-data\">\n              <span class=\"thf-icon thf-icon-info thf-menu-icon-item thf-lg-2\"></span>\n              <div class=\"thf-lg-10 thf-menu-icon-label\"> {{literals.itemNotFound}} </div>\n            </div>\n          </div>\n        </div>\n\n        <div *ngFor=\"let menu of filteredItems, let menuIndex = index;\" class=\"thf-menu-item-wrapper\">\n          <thf-menu-item\n            [class.thf-menu-item-first]=\"menuIndex === 0\"\n            [t-action]=\"menu.action\"\n            [t-badge-alert]=\"menu.badgeAlert\"\n            [t-badge-color]=\"menu.badge ? menu.badge.color : undefined\"\n            [t-badge-value]=\"menu.badge ? menu.badge.value : undefined\"\n            [t-collapsed-menu]=\"enableCollapse\"\n            [t-icon]=\"allowIcons ? menu.icon : null\"\n            [t-id]=\"menu.id\"\n            [t-label]=\"menu.label\"\n            [t-level]=\"menu.level\"\n            [t-link]=\"menu.link\"\n            [t-short-label]=\"menu.shortLabel\"\n            [t-sub-items]=\"menu.subItems\"\n            [t-type]=\"menu.type\">\n          </thf-menu-item>\n        </div>\n      </div>\n    </div>\n  </nav>\n\n  <div *ngIf=\"hasFooter\" class=\"thf-menu-footer\">\n    <a\n      class=\"thf-menu-collapse-button-icon thf-clickable\"\n      (click)=\"toggle()\">\n\n      <span class=\"thf-icon\"\n        [class.thf-icon-menu-close]=\"enableCollapseButton\"\n        [class.thf-icon-menu-open]=\"enableCollapse\">\n      </span>\n    </a>\n  </div>\n</div>\n",
                providers: [ThfMenuItemsService, ThfMenuService]
            }] }
];
/** @nocollapse */
ThfMenuComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: Renderer2 },
    { type: Router },
    { type: ThfMenuItemsService },
    { type: ChangeDetectorRef },
    { type: ThfMenuService }
];
ThfMenuComponent.propDecorators = {
    menuHeaderTemplate: [{ type: ContentChild, args: [ThfMenuHeaderTemplateDirective, { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que apresenta o campo de pesquisa no thf-menu.
 */
class ThfMenuFilterComponent {
    constructor() {
        // Variável necessária para o thf-clean identificar que deve ser criado.
        this.clean = true;
        this.filter = new EventEmitter();
    }
    /**
     * @param {?} search
     * @return {?}
     */
    filterItems(search) {
        this.filter.emit(search);
    }
}
ThfMenuFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-menu-filter',
                template: "<div class=\"thf-menu-filter-container\">\n\n  <input #inputFilter\n    type=\"text\"\n    class=\"thf-menu-filter\"\n    placeholder=\"Pesquisar\"\n    (keyup)=\"filterItems(inputFilter.value)\">\n\n  <div class=\"thf-menu-filter-search-icon-container\">\n    <span *ngIf=\"!loading\" class=\"thf-icon thf-menu-filter-icon thf-icon-search\"></span>\n    <span *ngIf=\"loading\" class=\"thf-icon thf-menu-filter-icon thf-loading-icon\"></span>\n  </div>\n  <div class=\"thf-menu-filter-close-icon-container\">\n    <thf-clean [t-element-ref]=\"inputFilterElement\" (t-change-event)=\"filterItems(inputFilter.value)\"></thf-clean>\n  </div>\n\n</div>\n"
            }] }
];
ThfMenuFilterComponent.propDecorators = {
    loading: [{ type: Input, args: ['t-loading',] }],
    inputFilterElement: [{ type: ViewChild, args: ['inputFilter', { read: ElementRef, static: true },] }],
    filter: [{ type: Output, args: ['t-filter',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// valor para que caibam 3 linhas de `label`
/** @type {?} */
const thfMenuItemSubItemSize = 98;
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que implementa cada item do thf-menu.
 */
class ThfMenuItemComponent {
    /**
     * @param {?} menuItemsService
     */
    constructor(menuItemsService) {
        this.menuItemsService = menuItemsService;
        this._isSelected = false;
        this._isSubItem = false;
        this.maxHeight = 0;
    }
    // Valor do badge.
    /**
     * @param {?} badgeValue
     * @return {?}
     */
    set badgeValue(badgeValue) {
        this._badgeValue = convertToInt(badgeValue);
    }
    /**
     * @return {?}
     */
    get badgeValue() {
        return this._badgeValue;
    }
    // Indica se o item está selecionado.
    /**
     * @param {?} value
     * @return {?}
     */
    set isSelected(value) {
        this._isSelected = convertToBoolean(value);
        this.isSelectedSubItem = this.isSelected && this.isSubItem;
    }
    /**
     * @return {?}
     */
    get isSelected() {
        return this._isSelected;
    }
    // Indica se o item é um sub item
    /**
     * @param {?} value
     * @return {?}
     */
    set isSubItem(value) {
        this._isSubItem = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get isSubItem() {
        return this._isSubItem;
    }
    // Lista de sub-items.
    /**
     * @param {?} subitems
     * @return {?}
     */
    set subItems(subitems) {
        this._subItems = subitems;
        if (this.isOpened) {
            this.calcMenuSubItemsMaxHeight();
        }
    }
    /**
     * @return {?}
     */
    get subItems() {
        return this._subItems;
    }
    /**
     * @return {?}
     */
    get canShowBadge() {
        return this.type !== 'subItems' && (this.badgeValue || this.badgeValue === 0) && this.badgeValue >= 0;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.itemSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // subscribe to menu component messages
        this.itemSubscription = this.menuItemsService.receiveFromParentMenuClicked().subscribe((/**
         * @param {?} menu
         * @return {?}
         */
        menu => {
            this.processMenuItem(menu);
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clickMenuItem(event) {
        if (!(event.ctrlKey || event.metaKey)) {
            event.preventDefault();
            // Emmit to parent
            this.menuItemsService.sendToParentMenuClicked({
                link: this.link,
                action: this.action,
                id: this.id,
                icon: this.icon,
                label: this.label,
                level: this.level,
                subItems: this.subItems,
                isSelected: this.isSelected,
                isOpened: this.isOpened,
                shortLabel: this.shortLabel,
                type: this.type
            });
        }
    }
    /**
     * @private
     * @param {?} menuActive
     * @param {?} menuOpened
     * @param {?} hasSubItemOpened
     * @param {?} activatedByRoute
     * @return {?}
     */
    accordionAnimation(menuActive, menuOpened, hasSubItemOpened, activatedByRoute) {
        if (this.id === menuOpened['id']) {
            this.maxHeight = this.subItems.length * thfMenuItemSubItemSize;
        }
        if (hasSubItemOpened) {
            this.maxHeight = menuOpened['isOpened'] ?
                (this.maxHeight + menuOpened.subItems.length * thfMenuItemSubItemSize) :
                (this.maxHeight - menuOpened.subItems.length * thfMenuItemSubItemSize);
            if (activatedByRoute) {
                this.maxHeight = this.getMinimumHeight(0, this, menuActive);
            }
        }
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    activateMenu(menu) {
        this.isSelected = menu && this.id === menu.id;
    }
    /**
     * @private
     * @return {?}
     */
    calcMenuSubItemsMaxHeight() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const subItems = Array.from(this.menuSubItems.nativeElement.querySelectorAll('.thf-menu-item'));
            subItems.forEach((/**
             * @param {?} menuItem
             * @return {?}
             */
            (menuItem) => this.maxHeight += menuItem.offsetHeight));
        }));
    }
    /**
     * @private
     * @param {?} minimumHeight
     * @param {?} menuItem
     * @param {?} menuActive
     * @return {?}
     */
    getMinimumHeight(minimumHeight, menuItem, menuActive) {
        minimumHeight += thfMenuItemSubItemSize;
        if (menuItem.subItems && this.hasSubItem(menuItem.subItems, menuActive['id'])) {
            for (let index = 0; index < menuItem.subItems.length; index++) {
                minimumHeight = this.getMinimumHeight(minimumHeight, menuItem.subItems[index], menuActive);
            }
        }
        return minimumHeight;
    }
    /**
     * @private
     * @param {?} menuActive
     * @param {?} menuOpened
     * @param {?=} activatedByRoute
     * @return {?}
     */
    groupedMenu(menuActive, menuOpened, activatedByRoute = false) {
        /** @type {?} */
        const hasSubItemOpened = (menuOpened && this.id !== menuOpened['id']) ? this.hasSubItem(this.subItems, menuOpened['id']) : false;
        this.isOpened = this.isMenuOpened(menuOpened, hasSubItemOpened);
        this.isSelected = (menuActive && !this.isOpened) ? this.hasSubItem(this.subItems, menuActive['id']) : false;
        if (!this.isOpened) {
            this.maxHeight = 0;
            return;
        }
        this.accordionAnimation(menuActive, menuOpened, hasSubItemOpened, activatedByRoute);
    }
    /**
     * @private
     * @param {?} subItems
     * @param {?} id
     * @return {?}
     */
    hasSubItem(subItems, id) {
        if (subItems) {
            return subItems.some((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return item['id'] === id ? true : this.hasSubItem(item.subItems, id);
            }));
        }
    }
    /**
     * @private
     * @param {?} menuOpened
     * @param {?} hasSubItemOpened
     * @return {?}
     */
    isMenuOpened(menuOpened, hasSubItemOpened) {
        if (menuOpened) {
            return (this.id === menuOpened['id']) ? menuOpened['isOpened'] : hasSubItemOpened;
        }
        return false;
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    processMenuItem(menu) {
        if (this.type === 'internalLink') {
            this.activateMenu(menu.active);
            return;
        }
        if (this.type === 'subItems') {
            this.groupedMenu(menu.active, menu.grouped, menu.activatedByRoute);
            return;
        }
    }
}
ThfMenuItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-menu-item',
                template: "<!-- menu com link interno -->\n<a *ngIf=\"type === 'internalLink'\" class=\"thf-menu-item-link\" [routerLink]=\"link\">\n  <ng-container *ngTemplateOutlet=\"menuItemTemplate\"></ng-container>\n</a>\n<!-- menu com link externo -->\n<a *ngIf=\"type === 'externalLink'\" class=\"thf-menu-item-link\" [href]=\"link\">\n  <ng-container *ngTemplateOutlet=\"menuItemTemplate\"></ng-container>\n</a>\n<!-- menu sem link -->\n<a *ngIf=\"type === 'noLink'\" class=\"thf-menu-item-link\" href=\"javascript:;\">\n  <ng-container *ngTemplateOutlet=\"menuItemTemplate\"></ng-container>\n</a>\n<!-- menu com sub itens -->\n<div *ngIf=\"type === 'subItems'\" class=\"thf-menu-item-link thf-clickable\">\n  <ng-container *ngTemplateOutlet=\"menuItemTemplate;\"></ng-container>\n  <div #menuSubItems\n    class=\"thf-menu-sub-items\"\n    [hidden]=\"collapsedMenu\"\n    [style.maxHeight.px]=\"maxHeight\">\n    <div *ngFor=\"let subItem of subItems\">\n      <thf-menu-item\n        t-is-sub-item\n        [t-action]=\"subItem.action\"\n        [t-badge-alert]=\"subItem.badgeAlert\"\n        [t-badge-color]=\"subItem.badge ? subItem.badge.color : undefined\"\n        [t-badge-value]=\"subItem.badge ? subItem.badge.value : undefined\"\n        [t-id]=\"subItem.id\"\n        [t-label]=\"subItem.label\"\n        [t-level]=\"subItem.level\"\n        [t-link]=\"subItem.link\"\n        [t-sub-items]=\"subItem.subItems\"\n        [t-type]=\"subItem.type\">\n      </thf-menu-item>\n    </div>\n  </div>\n</div>\n\n<ng-template #menuItemTemplate>\n  <div class=\"thf-menu-item\"\n    [class.thf-menu-icon-container]=\"level === 1 && icon\"\n    [class.thf-menu-item-selected]=\"isSelected\"\n    [class.thf-menu-item-level-two]=\"level === 2\"\n    [class.thf-menu-item-level-three]=\"level === 3\"\n    [class.thf-menu-item-level-four]=\"level === 4\"\n    [class.thf-menu-item-grouper-up]=\"type === 'subItems' && isOpened\"\n    [class.thf-menu-item-grouper-down]=\"type === 'subItems' && !isOpened\"\n    [class.thf-menu-sub-item-selected]=\"isSelectedSubItem\"\n    (click)=\"clickMenuItem($event);\">\n    <thf-badge *ngIf=\"canShowBadge\"\n      [ngClass]=\"!collapsedMenu ? 'thf-menu-badge-align' : 'thf-menu-badge-align-collapsed'\"\n      [t-color]=\"badgeColor\"\n      [t-value]=\"badgeValue\">\n    </thf-badge>\n    <span *ngIf=\"level === 1 && icon\" class=\"thf-icon {{icon}} thf-menu-icon-item\"></span>\n    <div *ngIf=\"badgeAlert\"\n      class=\"thf-color-07\"\n      [ngClass]=\"!collapsedMenu ? 'thf-menu-badge-alert' : 'thf-menu-badge-alert-collapsed'\">\n    </div>\n    <span *ngIf=\"type === 'subItems' && !collapsedMenu\"\n      class=\"thf-icon thf-menu-group-icon\"\n      [class.thf-icon-arrow-up]=\"isOpened\"\n      [class.thf-icon-arrow-down]=\"!isOpened\">\n    </span>\n    <div [class.thf-menu-icon-label]=\"level === 1 && icon\">\n      {{ label }}\n    </div>\n    <div *ngIf=\"collapsedMenu\" class=\"thf-menu-short-label\">{{ shortLabel }}</div>\n  </div>\n</ng-template>\n"
            }] }
];
/** @nocollapse */
ThfMenuItemComponent.ctorParameters = () => [
    { type: ThfMenuItemsService }
];
ThfMenuItemComponent.propDecorators = {
    action: [{ type: Input, args: ['t-action',] }],
    badgeAlert: [{ type: Input, args: ['t-badge-alert',] }],
    badgeColor: [{ type: Input, args: ['t-badge-color',] }],
    badgeValue: [{ type: Input, args: ['t-badge-value',] }],
    collapsedMenu: [{ type: Input, args: ['t-collapsed-menu',] }],
    icon: [{ type: Input, args: ['t-icon',] }],
    id: [{ type: Input, args: ['t-id',] }],
    isOpened: [{ type: Input, args: ['t-is-opened',] }],
    isSelected: [{ type: Input, args: ['t-is-selected',] }],
    isSubItem: [{ type: Input, args: ['t-is-sub-item',] }],
    label: [{ type: Input, args: ['t-label',] }],
    level: [{ type: Input, args: ['t-level',] }],
    link: [{ type: Input, args: ['t-link',] }],
    shortLabel: [{ type: Input, args: ['t-short-label',] }],
    subItems: [{ type: Input, args: ['t-sub-items',] }],
    type: [{ type: Input, args: ['t-type',] }],
    menuSubItems: [{ type: ViewChild, args: ['menuSubItems', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-menu.
 */
class ThfMenuModule {
}
ThfMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    ThfBadgeModule,
                    ThfFieldModule
                ],
                declarations: [
                    ThfMenuComponent,
                    ThfMenuFilterComponent,
                    ThfMenuHeaderTemplateDirective,
                    ThfMenuItemComponent
                ],
                exports: [
                    ThfMenuComponent,
                    ThfMenuHeaderTemplateDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Este é um componente de menu lateral composto apenas por ícones e com um nível, utilizado para navegação
 * em páginas internas, externas da aplicação ou aciona uma ação.
 *
 * O componente `thf-menu-panel` recebe uma lista de objetos do tipo `MenuPanelItem` com as informações dos
 * itens de menu como textos, links para redirecionamento, ações e ícones.
 */
class ThfMenuPanelBaseComponent {
    /**
     * Lista dos itens do `thf-menu-panel`. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio.
     * @param {?} menus
     * @return {?}
     */
    set menus(menus) {
        this._menus = Array.isArray(menus) ? menus : [];
        this.setMenuExtraProperties(this._menus);
        this.validateMenus(this._menus);
    }
    /**
     * @return {?}
     */
    get menus() {
        return this._menus;
    }
    /**
     * @private
     * @param {?} menus
     * @return {?}
     */
    setMenuExtraProperties(menus) {
        menus.forEach((/**
         * @param {?} menuItem
         * @return {?}
         */
        menuItem => this.setMenuItemProperties((/** @type {?} */ (menuItem)))));
    }
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    setMenuItemProperties(menuItem) {
        menuItem.id = menuItem.id || v4();
        menuItem.type = this.setMenuType(menuItem);
    }
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    setMenuType(menuItem) {
        if (!menuItem.link) {
            return 'noLink';
        }
        if (isExternalLink(menuItem.link)) {
            return 'externalLink';
        }
        return 'internalLink';
    }
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    validateMenu(menuItem) {
        if (!menuItem.label) {
            throw new Error('O atributo ThfMenuPanelItem.label não pode ser vazio.');
        }
        if (!menuItem.icon) {
            throw new Error('O atributo ThfMenuPanelItem.icon não pode ser vazio.');
        }
    }
    /**
     * @private
     * @param {?} menus
     * @return {?}
     */
    validateMenus(menus) {
        menus.forEach((/**
         * @param {?} menu
         * @return {?}
         */
        menu => this.validateMenu(menu)));
    }
}
ThfMenuPanelBaseComponent.propDecorators = {
    menus: [{ type: Input, args: ['t-menus',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço que implementa a comunicação entre os items do thf-menu-panel.
 */
class ThfMenuPanelItemsService {
    constructor() {
        this.subjectChild = new Subject();
        this.subjectParent = new Subject();
    }
    // Recebe do thf-menu-panel-item sua informação de click.
    /**
     * @return {?}
     */
    receiveFromChildMenuClicked() {
        return this.subjectChild.asObservable();
    }
    // Recebe do thf-menu-panel as informações processadas do click de um thf-menu-panel-item.
    /**
     * @return {?}
     */
    receiveFromParentMenuClicked() {
        return this.subjectParent.asObservable();
    }
    // Envia informações do click do thf-menu-panel-item para o thf-menu
    /**
     * @param {?} menu
     * @return {?}
     */
    sendToParentMenuClicked(menu) {
        this.subjectChild.next(menu);
    }
    // Envia para os thf-menu-panel-item a resposta do processamento de click de um thf-menu-panel-item.
    /**
     * @param {?} menu
     * @return {?}
     */
    sendToChildMenuClicked(menu) {
        this.subjectParent.next(menu);
    }
}
ThfMenuPanelItemsService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfMenuPanelBaseComponent
 *
 * \@description
 *
 * Para o menu funcionar corretamente é necessário importar o `RouterModule` e `Routes` do módulo principal de
 *  sua aplicação:
 *
 * ````
 * import { RouterModule, Routes } from '\@angular/router';
 *
 * ...
 *
 * \@NgModule({
 *   imports: [
 *     RouterModule,
 *     Routes,
 *     ...
 *     ThfModule,
 *     ...
 *   ],
 *   declarations: [
 *     AppComponent
 *   ],
 *   providers: [],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule { }
 * ```
 *
 * Além disso é necessário criar um módulo configurando as rotas da aplicação.
 *
 * ```
 * import { NgModule } from '\@angular/core';
 *
 * import { RouterModule, Routes } from '\@angular/router';
 *
 * import { HelloWorldComponent } from './hello-world/hello-world.component';
 *
 * const routes: Routes = [
 *   {path: 'hello-world', component: HelloWorldComponent}
 * ];
 *
 * \@NgModule({
 *   imports: [RouterModule.forRoot(routes, {useHash: true})],
 *   exports: [RouterModule]
 * })
 * export class AppRoutingModule {}
 * ```
 *
 * \@example
 *
 * <example name="thf-menu-panel-basic" title="Totvs Menu Panel Basic">
 *   <file name="sample-thf-menu-panel-basic/sample-thf-menu-panel-basic.component.html"> </file>
 *   <file name="sample-thf-menu-panel-basic/sample-thf-menu-panel-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-menu-panel-labs" title="Totvs Menu Panel Labs">
 *   <file name="sample-thf-menu-panel-labs/sample-thf-menu-panel-labs.component.html"> </file>
 *   <file name="sample-thf-menu-panel-labs/sample-thf-menu-panel-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-menu-panel-customer" title="Totvs Menu Panel - Customers">
 *   <file name="sample-thf-menu-panel-customer/sample-thf-menu-panel-customer.component.html"> </file>
 *   <file name="sample-thf-menu-panel-customer/sample-thf-menu-panel-customer.component.ts"> </file>
 * </example>
 */
class ThfMenuPanelComponent extends ThfMenuPanelBaseComponent {
    /**
     * @param {?} viewRef
     * @param {?} location
     * @param {?} menuItemsService
     * @param {?} router
     */
    constructor(viewRef, location, menuItemsService, router) {
        super();
        this.location = location;
        this.menuItemsService = menuItemsService;
        this.router = router;
        this.parentRef = viewRef['_view']['component'];
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.itemSubscription.unsubscribe();
        this.routeSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscribeToMenuItem();
        this.subscribeToRoute();
    }
    /**
     * @private
     * @param {?} urlPath
     * @param {?} menus
     * @return {?}
     */
    activateMenuByUrl(urlPath, menus) {
        if (menus) {
            return menus.some((/**
             * @param {?} menu
             * @return {?}
             */
            menu => {
                if (getFormattedLink(menu.link) === urlPath) {
                    this.activateMenuItem(menu);
                    return true;
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    activateMenuItem(menu) {
        this.activeMenuItem = menu;
        this.linkActive = getFormattedLink(menu.link);
        this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, activatedByRoute: true });
    }
    /**
     * @private
     * @param {?} urlPath
     * @return {?}
     */
    checkActiveMenuByUrl(urlPath) {
        if (!this.linkActive || this.linkActive !== urlPath) {
            this.activateMenuByUrl(urlPath, this.menus);
        }
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    clickMenuItem(menu) {
        if (menu.action) {
            callFunction(menu.action, this.parentRef, menu);
        }
        if (menu.type === 'externalLink') {
            openExternalLink(menu.link);
        }
        else if (menu.type === 'internalLink') {
            this.activateMenuItem(menu);
        }
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToRoute() {
        this.routeSubscription = this.router.events.subscribe((/**
         * @param {?} rounterEvent
         * @return {?}
         */
        rounterEvent => {
            if (rounterEvent instanceof NavigationEnd) {
                this.checkActiveMenuByUrl(this.location.path());
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToMenuItem() {
        this.itemSubscription =
            this.menuItemsService.receiveFromChildMenuClicked().subscribe((/**
             * @param {?} menu
             * @return {?}
             */
            (menu) => this.clickMenuItem(menu)));
    }
}
ThfMenuPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-menu-panel',
                template: "<div class=\"thf-menu-panel\">\n  <div class=\"thf-menu-panel-logo-container\">\n    <a href=\"./\">\n      <div class=\"thf-menu-panel-logo\"></div>\n    </a>\n  </div>\n\n  <nav class=\"thf-menu-panel-container\">\n    <div class=\"thf-menu-panel-inner\">\n      <div *ngFor=\"let menu of menus, let menuIndex = index;\" class=\"thf-menu-panel-item-wrapper\">\n        <thf-menu-panel-item\n          [class.thf-menu-panel-item-first]=\"menuIndex === 0\"\n          [t-menu-item-internal]=\"menu\">\n        </thf-menu-panel-item>\n      </div>\n    </div>\n  </nav>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfMenuPanelComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Location },
    { type: ThfMenuPanelItemsService },
    { type: Router }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que implementa cada item do thf-menu-panel.
 */
class ThfMenuPanelItemComponent {
    /**
     * @param {?} menuItemsService
     */
    constructor(menuItemsService) {
        this.menuItemsService = menuItemsService;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.itemsSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // subscribe to menu component messages
        this.subscribeMenuClickedFromParent();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clickMenuItem(event) {
        if (!(event.ctrlKey || event.metaKey)) {
            event.preventDefault();
            // Emmit to parent
            this.menuItemsService.sendToParentMenuClicked(this.menuItemInternal);
        }
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    activateMenu(menu) {
        this.menuItemInternal.isSelected = this.menuItemInternal.id === menu.id;
    }
    /**
     * @private
     * @param {?} menu
     * @return {?}
     */
    processMenuItem(menu) {
        if (this.menuItemInternal.type === 'internalLink') {
            this.activateMenu(menu.active);
        }
    }
    /**
     * @private
     * @return {?}
     */
    subscribeMenuClickedFromParent() {
        this.itemsSubscription = this.menuItemsService.receiveFromParentMenuClicked().subscribe((/**
         * @param {?} menu
         * @return {?}
         */
        menu => {
            this.processMenuItem(menu);
        }));
    }
}
ThfMenuPanelItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-menu-panel-item',
                template: "<!-- menu com link interno -->\n<a *ngIf=\"menuItemInternal.type === 'internalLink'\" [routerLink]=\"menuItemInternal.link\">\n  <ng-container *ngTemplateOutlet=\"menuItemTemplate\"></ng-container>\n</a>\n\n<!-- menu com link externo -->\n<a *ngIf=\"menuItemInternal.type === 'externalLink'\" [href]=\"menuItemInternal.link\">\n  <ng-container *ngTemplateOutlet=\"menuItemTemplate\"></ng-container>\n</a>\n\n<!-- menu sem link -->\n<a *ngIf=\"menuItemInternal.type === 'noLink'\" href=\"javascript:;\">\n  <ng-container *ngTemplateOutlet=\"menuItemTemplate\"></ng-container>\n</a>\n\n<ng-template #menuItemTemplate>\n  <div class=\"thf-menu-panel-item\"\n    t-tooltip-position=\"right\"\n    [class.thf-menu-panel-item-selected]=\"menuItemInternal.isSelected\"\n    [t-tooltip]=\"menuItemInternal.label\"\n    (click)=\"clickMenuItem($event);\">\n    <span class=\"thf-icon {{menuItemInternal.icon}}\"></span>\n  </div>\n</ng-template>\n"
            }] }
];
/** @nocollapse */
ThfMenuPanelItemComponent.ctorParameters = () => [
    { type: ThfMenuPanelItemsService }
];
ThfMenuPanelItemComponent.propDecorators = {
    menuItemInternal: [{ type: Input, args: ['t-menu-item-internal',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-menu-panel.
 */
class ThfMenuPanelModule {
}
ThfMenuPanelModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    ThfFieldModule,
                    ThfTooltipModule
                ],
                declarations: [
                    ThfMenuPanelComponent,
                    ThfMenuPanelItemComponent
                ],
                exports: [
                    ThfMenuPanelComponent
                ],
                providers: [
                    ThfMenuPanelItemsService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarActionComponent {
    /**
     * @param {?} viewContainerRef
     * @param {?} router
     */
    constructor(viewContainerRef, router) {
        this.router = router;
        this.parentRef = viewContainerRef['_view']['component'];
    }
    /**
     * @return {?}
     */
    onActionClick() {
        if (this.action) {
            return callFunction(this.action, this.parentRef, this.param || this);
        }
        if (this.link) {
            return this.openUrl(this.link);
        }
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    openUrl(url) {
        if (isExternalLink(url)) {
            return openExternalLink(url);
        }
        if (url) {
            return this.router.navigate([url]);
        }
    }
}
ThfNavbarActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar-action',
                template: "<div tabindex=\"0\"\n  class=\"thf-navbar-action-content thf-clickable\"\n  (click)=\"onActionClick()\">\n\n  <span\n  class=\"thf-icon {{ icon }}\"\n  [t-tooltip]=\"tooltip\">\n  </span>\n\n</div>\n"
            }] }
];
/** @nocollapse */
ThfNavbarActionComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Router }
];
ThfNavbarActionComponent.propDecorators = {
    action: [{ type: Input, args: ['t-action',] }],
    icon: [{ type: Input, args: ['t-icon',] }],
    label: [{ type: Input, args: ['t-label',] }],
    link: [{ type: Input, args: ['t-link',] }],
    tooltip: [{ type: Input, args: ['t-tooltip-text',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarActionPopupComponent {
    /**
     * @return {?}
     */
    getLastIconAction() {
        if (this.iconActions && this.iconActions.length > 0) {
            return this.iconActions[this.iconActions.length - 1].icon;
        }
    }
}
ThfNavbarActionPopupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar-action-popup',
                template: "<div tabindex=\"0\" #target\n  class=\"thf-navbar-action-popup-content thf-clickable\"\n  (click)=\"popup.toggle()\">\n  <span class=\"thf-icon {{ getLastIconAction() }}\"></span>\n</div>\n\n<thf-popup #popup\n  [t-actions]=\"iconActions\"\n  [t-target]=\"target\">\n</thf-popup>\n"
            }] }
];
ThfNavbarActionPopupComponent.propDecorators = {
    iconActions: [{ type: Input, args: ['t-icon-actions',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarActionsComponent {
    /**
     * @param {?} actions
     * @return {?}
     */
    set iconActions(actions) {
        this._iconActions = actions.map((/**
         * @param {?} action
         * @return {?}
         */
        action => (Object.assign({}, action, { separator: true, url: action.link }))));
    }
    /**
     * @return {?}
     */
    get iconActions() {
        return this._iconActions;
    }
}
ThfNavbarActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar-actions',
                template: "<thf-navbar-action *ngFor=\"let iconAction of iconActions\"\n  class=\"thf-navbar-action\"\n  [t-action]=\"iconAction.action\"\n  [t-icon]=\"iconAction.icon\"\n  [t-label]=\"iconAction.label\"\n  [t-link]=\"iconAction.link\"\n  [t-tooltip-text]=\"iconAction.tooltip\">\n</thf-navbar-action>\n\n<thf-navbar-action-popup\n  class=\"thf-navbar-action-popup\"\n  [t-icon-actions]=\"iconActions\">\n</thf-navbar-action-popup>\n\n\n"
            }] }
];
ThfNavbarActionsComponent.propDecorators = {
    iconActions: [{ type: Input, args: ['t-icon-actions',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarActionsModule {
}
ThfNavbarActionsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfPopupModule,
                    ThfTooltipModule
                ],
                declarations: [
                    ThfNavbarActionComponent,
                    ThfNavbarActionPopupComponent,
                    ThfNavbarActionsComponent
                ],
                exports: [
                    ThfNavbarActionsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfNavbarLiteralsDefault = {
    en: (/** @type {?} */ ({
        navbarLinks: 'Navbar links'
    })),
    es: (/** @type {?} */ ({
        navbarLinks: 'Navbar links'
    })),
    pt: (/** @type {?} */ ({
        navbarLinks: 'Navbar links'
    }))
};
/**
 * \@description
 *
 * O componente `thf-navbar` é um cabeçalho fixo que permite apresentar uma lista de links para facilitar a navegação pelas
 * páginas da aplicação. Também possui ícones com ações.
 */
class ThfNavbarBaseComponent {
    constructor() {
        this._iconActions = [];
        this._items = [];
        this._shadow = false;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define uma lista de ações apresentadas em ícones no lado direito do `thf-navbar`.
     * @param {?} value
     * @return {?}
     */
    set iconActions(value) {
        this._iconActions = value || [];
    }
    /**
     * @return {?}
     */
    get iconActions() {
        return this._iconActions;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define uma lista de items do `thf-navbar`.
     * @param {?} value
     * @return {?}
     */
    set items(value) {
        this._items = value || [];
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com a literal usada na propriedade `t-literals`.
     *
     * Para customizar a literal, basta declarar um objeto do tipo `ThfNavbarLiterals` conforme exemplo abaixo:
     *
     * ```
     *  const customLiterals: ThfNavbarLiterals = {
     *    navbarLinks: 'Itens de navegação'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-navbar
     *   [t-literals]="customLiterals">
     * </thf-navbar>
     * ```
     *
     *  > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfNavbarLiteralsDefault[thfLocaleDefault], thfNavbarLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfNavbarLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfNavbarLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Aplica uma sombra na parte inferior do `thf-navbar`.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set shadow(value) {
        this._shadow = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get shadow() {
        return this._shadow;
    }
}
ThfNavbarBaseComponent.propDecorators = {
    iconActions: [{ type: Input, args: ['t-icon-actions',] }],
    items: [{ type: Input, args: ['t-items',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    logo: [{ type: Input, args: ['t-logo',] }],
    menu: [{ type: Input, args: ['t-menu',] }],
    shadow: [{ type: Input, args: ['t-shadow',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarItemComponent {
    constructor() {
        this.click = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get type() {
        if (isExternalLink(this.link)) {
            return 'externalLink';
        }
        return 'internalLink';
    }
    /**
     * @return {?}
     */
    itemClick() {
        if (this.action) {
            this.action({ label: this.label, link: this.link });
        }
        this.click.emit();
    }
}
ThfNavbarItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar-item',
                template: "<ng-container [ngSwitch]=\"type\">\n\n  <a *ngSwitchCase=\"'externalLink'\"\n    class=\"thf-navbar-item-link\"\n    [class.thf-clickable]=\"clickable\"\n    [href]=\"link\" \n    target=\"_blank\"\n    (click)=\"itemClick()\">{{ label }}</a>\n\n  <a *ngSwitchCase=\"'internalLink'\"\n    class=\"thf-navbar-item-link\"\n    [class.thf-clickable]=\"clickable\"\n    [routerLink]=\"link\"\n    (click)=\"itemClick()\">{{ label }}</a>\n\n</ng-container>\n"
            }] }
];
ThfNavbarItemComponent.propDecorators = {
    action: [{ type: Input, args: ['t-action',] }],
    clickable: [{ type: Input, args: ['t-clickable',] }],
    label: [{ type: Input, args: ['t-label',] }],
    link: [{ type: Input, args: ['t-link',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarItemsComponent {
    /**
     * @param {?} router
     */
    constructor(router) {
        this.router = router;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.routeSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscribeToRoute();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        this.selectedItem = item;
    }
    /**
     * @private
     * @param {?} urlRouter
     * @return {?}
     */
    checkActiveItemByUrl(urlRouter) {
        this.selectedItem = this.items.find((/**
         * @param {?} item
         * @return {?}
         */
        item => item.link === urlRouter));
    }
    /**
     * @private
     * @return {?}
     */
    checkRouterChildrenFragments() {
        /** @type {?} */
        const childrenPrimary = this.router.parseUrl(this.router.url).root.children['primary'];
        return childrenPrimary ? `/${childrenPrimary.segments.map((/**
         * @param {?} it
         * @return {?}
         */
        it => it.path)).join('/')}` : '';
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToRoute() {
        this.routeSubscription = this.router.events.subscribe((/**
         * @param {?} val
         * @return {?}
         */
        val => {
            if (val instanceof NavigationEnd || val instanceof NavigationCancel) {
                /** @type {?} */
                const urlRouter = this.checkRouterChildrenFragments();
                this.checkActiveItemByUrl(urlRouter);
            }
        }));
    }
}
ThfNavbarItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar-items',
                template: "<nav>\n  <ul class=\"thf-navbar-items-container\" #navbarItemsContainer>\n    <li *ngFor=\"let item of items\"\n      class=\"thf-navbar-item\"\n      [class.thf-navbar-item-selected]=\"selectedItem === item\">\n      <thf-navbar-item\n        [t-action]=\"item.action\"\n        [t-clickable]=\"selectedItem !== item\"\n        [t-label]=\"item.label\"\n        [t-link]=\"item.link\"\n        (t-click)=\"selectItem(item)\">\n      </thf-navbar-item>\n    </li>\n  </ul>\n</nav>\n"
            }] }
];
/** @nocollapse */
ThfNavbarItemsComponent.ctorParameters = () => [
    { type: Router }
];
ThfNavbarItemsComponent.propDecorators = {
    navbarItemsContainer: [{ type: ViewChild, args: ['navbarItemsContainer', { read: ElementRef, static: true },] }],
    allNavbarItems: [{ type: ViewChildren, args: [ThfNavbarItemComponent, { read: ElementRef },] }],
    items: [{ type: Input, args: ['t-items',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfNavbarBaseComponent
 */
class ThfNavbarComponent extends ThfNavbarBaseComponent {
    /**
     * @param {?} renderer
     * @param {?} builder
     * @param {?} changeDetector
     */
    constructor(renderer, builder, changeDetector) {
        super();
        this.renderer = renderer;
        this.builder = builder;
        this.changeDetector = changeDetector;
        this.showItemsNavigation = false;
        this.offset = 0;
        this.windowResizeListener = this.renderer.listen(window, 'resize', this.displayItemsNavigation.bind(this));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.displayItemsNavigation();
        this.menuWrapperAdjust();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.mediaQuery) {
            this.mediaQuery.removeListener();
        }
    }
    /**
     * @param {?} orientation
     * @return {?}
     */
    navigateItems(orientation) {
        orientation === 'left' ? this.navigateLeft() : this.navigateRight();
        this.animate(this.offset);
    }
    /**
     * @private
     * @return {?}
     */
    adjustNavbarMenu() {
        /** @type {?} */
        const navbarMenu = document.querySelector('thf-navbar thf-menu');
        /** @type {?} */
        const page = document.querySelector('.thf-page');
        /** @type {?} */
        const navbarLogo = document.querySelector('.thf-navbar-logo');
        navbarMenu.setAttribute('style', `display: none`);
        if (page) {
            page.setAttribute('style', 'margin-left: 0; width: 100%');
        }
        if (navbarLogo) {
            navbarLogo.setAttribute('style', `padding: 0 16px 0 0!important`);
        }
        this.mediaQuery.addListener((/**
         * @param {?} changed
         * @return {?}
         */
        changed => {
            if (changed.matches) {
                navbarMenu.setAttribute('style', `display: block`);
                if (page) {
                    page.setAttribute('style', 'margin-left: 256; width: calc(100% - 256px)');
                }
            }
            else {
                navbarMenu.setAttribute('style', `display: none`);
                if (page) {
                    page.setAttribute('style', 'margin-left: 0; width: 100%');
                }
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    adjustUserMenu() {
        /** @type {?} */
        const userMenuItems = this.menu.menus;
        this.mediaQuery.addListener((/**
         * @param {?} changed
         * @return {?}
         */
        changed => {
            if (changed.matches) {
                /** @type {?} */
                const subItems = [{ label: this.literals.navbarLinks, subItems: this.items }];
                this.menu.menus = [...subItems, ...this.menu.menus];
            }
            else {
                this.menu.menus = userMenuItems;
            }
        }));
    }
    /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    animate(offset) {
        /** @type {?} */
        const animation = this.buildTransitionAnimation(offset);
        this.player = animation.create(this.navbarItems.navbarItemsContainer.nativeElement);
        this.player.play();
    }
    /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    buildTransitionAnimation(offset) {
        return this.builder.build([
            animate('250ms ease', keyframes([style({ transform: `translateX(${offset}px)` })]))
        ]);
    }
    /**
     * @private
     * @return {?}
     */
    displayItemsNavigation() {
        this.navbarItemsWidth = this.navbarItemsElement.nativeElement.offsetWidth;
        this.allNavbarItemsWidth =
            this.navbarItems.allNavbarItems.reduce((/**
             * @param {?} previous
             * @param {?} current
             * @return {?}
             */
            (previous, current) => previous + current.nativeElement.offsetWidth), 0);
        this.showItemsNavigation = this.navbarItemsWidth < this.allNavbarItemsWidth + 88;
        this.changeDetector.detectChanges();
        if (this.offset !== 0) {
            this.offset = 0;
            this.animate(this.offset);
        }
    }
    /**
     * @private
     * @return {?}
     */
    menuWrapperAdjust() {
        /** @type {?} */
        const body = document.querySelector('body');
        body.setAttribute('style', `height: calc(100% - 56px)`);
        this.mediaQuery = window.matchMedia('(max-width: 768px)');
        !this.menu ? this.adjustNavbarMenu() : this.adjustUserMenu();
    }
    /**
     * @private
     * @return {?}
     */
    navigateRight() {
        /** @type {?} */
        const maxAllowedOffset = this.allNavbarItemsWidth - this.navbarItemsElement.nativeElement.offsetWidth;
        /** @type {?} */
        const itemBreakPoint = (this.offset * -1) + this.navbarItemsElement.nativeElement.offsetWidth;
        /** @type {?} */
        let movementInPixels = 0;
        this.navbarItems.allNavbarItems.some((/**
         * @param {?} navbarItem
         * @return {?}
         */
        navbarItem => {
            /** @type {?} */
            const finalPosition = navbarItem.nativeElement.offsetWidth + navbarItem.nativeElement.offsetLeft;
            if (itemBreakPoint < finalPosition) {
                movementInPixels = navbarItem.nativeElement.offsetLeft;
                return true;
            }
        }));
        this.offset = (movementInPixels * -1);
        if ((this.offset * -1) >= maxAllowedOffset) {
            this.offset = maxAllowedOffset * -1;
            this.disableRight = true;
        }
    }
    /**
     * @private
     * @return {?}
     */
    navigateLeft() {
        this.disableRight = false;
        /** @type {?} */
        let movementInPixels;
        this.navbarItems.allNavbarItems.some((/**
         * @param {?} navbarItem
         * @return {?}
         */
        navbarItem => {
            /** @type {?} */
            const navbarItemOffset = navbarItem.nativeElement.offsetLeft;
            if (navbarItemOffset >= (this.offset * -1)) {
                movementInPixels = navbarItemOffset - (this.navbarItemsElement.nativeElement.offsetWidth - navbarItem.nativeElement.offsetWidth);
                return true;
            }
        }));
        this.offset = (movementInPixels * -1);
        if (this.offset > 0) {
            this.offset = 0;
        }
    }
}
ThfNavbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar',
                template: "<header class=\"thf-navbar\"\n  [ngClass]=\"{'thf-navbar-shadow' : shadow}\">\n\n  <thf-navbar-logo\n    class=\"thf-navbar-logo\"\n    [t-logo]=\"logo\">\n  </thf-navbar-logo>\n\n  <thf-navbar-items\n    class=\"thf-navbar-items\"\n    [t-items]=\"items\">\n  </thf-navbar-items>\n\n  <thf-navbar-item-navigation *ngIf=\"showItemsNavigation\"\n    class=\"thf-navbar-item-navigation\"\n    [t-disable-left]=\"offset === 0\"\n    [t-disable-right]=\"disableRight && offset !== 0\"\n    (t-click)=\"navigateItems($event)\">\n  </thf-navbar-item-navigation>\n\n  <thf-navbar-actions\n    class=\"thf-navbar-actions\"\n    [t-icon-actions]=\"iconActions\">\n  </thf-navbar-actions>\n\n</header>\n\n<thf-menu *ngIf=\"!menu\"\n  [t-menus]=\"items\">\n</thf-menu>\n"
            }] }
];
/** @nocollapse */
ThfNavbarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: AnimationBuilder },
    { type: ChangeDetectorRef }
];
ThfNavbarComponent.propDecorators = {
    navbarItemsElement: [{ type: ViewChild, args: [ThfNavbarItemsComponent, { read: ElementRef, static: true },] }],
    navbarItems: [{ type: ViewChild, args: [ThfNavbarItemsComponent, { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarItemsModule {
}
ThfNavbarItemsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule
                ],
                declarations: [
                    ThfNavbarItemComponent,
                    ThfNavbarItemsComponent
                ],
                exports: [
                    ThfNavbarItemsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarItemNavigationComponent {
    constructor() {
        this.click = new EventEmitter();
    }
}
ThfNavbarItemNavigationComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar-item-navigation',
                template: "<div class=\"thf-navbar-item-navigation-icon\"\n  [ngClass]=\"{'thf-navbar-item-navigation-icon-disabled': disableLeft , 'thf-clickable': !disableLeft }\"\n  tabindex=\"0\"\n  (click)=\"disableLeft ? undefined : click.emit('left')\" >\n  <span class=\"thf-icon thf-icon-arrow-left\"></span>\n</div>\n<div class=\"thf-navbar-item-navigation-icon\"\n  [ngClass]=\"{'thf-navbar-item-navigation-icon-disabled': disableRight , 'thf-clickable': !disableRight }\"  \n  tabindex=\"0\"\n  (click)=\"disableRight ? undefined : click.emit('right')\">\n  <span class=\"thf-icon thf-icon-arrow-right\"></span>\n</div>\n"
            }] }
];
ThfNavbarItemNavigationComponent.propDecorators = {
    disableLeft: [{ type: Input, args: ['t-disable-left',] }],
    disableRight: [{ type: Input, args: ['t-disable-right',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarLogoComponent {
}
ThfNavbarLogoComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-navbar-logo',
                template: "<a href=\"./\">\n  <img *ngIf=\"logo\" class=\"thf-navbar-logo-image\" alt=\"logo\" [src]=\"logo\">\n</a>\n"
            }] }
];
ThfNavbarLogoComponent.propDecorators = {
    logo: [{ type: Input, args: ['t-logo',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNavbarModule {
}
ThfNavbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfNavbarActionsModule,
                    ThfNavbarItemsModule,
                    ThfMenuModule
                ],
                declarations: [
                    ThfNavbarComponent,
                    ThfNavbarItemNavigationComponent,
                    ThfNavbarLogoComponent
                ],
                exports: [
                    ThfNavbarComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * O componente **thf-page** é utilizado como container principal para os componentes thf-page-header, thf-page-content
 * e para as ações dos componentes thf-page-edit e thf-page-detail.
 *
 * Quando estiver sendo utilizado o componente thf-menu junto ao thf-page, ambos devem estar no mesmo nível
 * e inseridos em uma div com a classe **thf-wrapper**. Esta classe será responsável por fazer os cálculos
 * necessários de alinhamento dos componentes.
 *
 * O componente **thf-page** também pode ser utilizado sem o thf-menu e neste caso o corpo da página deve ser
 * definido com a altura de 100% para que o thf-page maximize seu tamanho.
 * ```
 * html, body {
 *   height:100%;
 * }
 * ```
 */
class ThfPageBaseComponent {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfPageBaseComponent
 */
class ThfPageComponent extends ThfPageBaseComponent {
}
ThfPageComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-page',
                template: "<div class=\"thf-page\">\n  <ng-content>\n  </ng-content>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * O componente **thf-page-content** é utilizado como o container para o conteúdo da página.
 */
class ThfPageContentBaseComponent {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfPageContentBaseComponent
 */
class ThfPageContentComponent extends ThfPageContentBaseComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super();
        this.renderer = renderer;
        this.contentOpacity = 0;
        this.height = '90%';
        this.overflowY = 'none';
        this.initializeListeners();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.recalculateHeaderSize();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @return {?}
     */
    recalculateHeaderSize() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const pageHeaderElement = document.querySelector('div.thf-page-header');
            this.setHeightContent(pageHeaderElement);
            this.contentOpacity = 1;
        }));
    }
    /**
     * @param {?} thfPageHeader
     * @return {?}
     */
    setHeightContent(thfPageHeader) {
        /** @type {?} */
        const bodyHeight = document.body.clientHeight;
        /** @type {?} */
        const pageHeaderHeight = thfPageHeader ? thfPageHeader.offsetTop + thfPageHeader.offsetHeight : 0;
        /** @type {?} */
        const newHeight = bodyHeight - pageHeaderHeight;
        this.height = `${newHeight}px`;
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.recalculateHeaderSize();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        this.resizeListener();
    }
}
ThfPageContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-page-content',
                template: "<div class=\"thf-page-content\"\n  [style.height]=\"height\"\n  [style.opacity]=\"contentOpacity\"\n  [style.overflow-y]=\"overflowY\">\n  <ng-content></ng-content>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfPageContentComponent.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-page-default` é utilizado como o container principal para as telas sem um template definido.
 * @abstract
 */
class ThfPageDefaultBaseComponent {
    constructor() {
        this._actions = [];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Nesta propriedade deve ser definido um array de objetos que implementam a interface `ThfPageAction`.
     * @param {?} actions
     * @return {?}
     */
    set actions(actions) {
        this._actions = Array.isArray(actions) ? actions : [];
        this.setDropdownActions();
    }
    /**
     * @return {?}
     */
    get actions() {
        return this._actions;
    }
    /**
     * Título da página.
     * @param {?} title
     * @return {?}
     */
    set title(title) {
        this._title = title;
        this.thfPageContent.recalculateHeaderSize();
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
}
ThfPageDefaultBaseComponent.propDecorators = {
    thfPageContent: [{ type: ViewChild, args: [ThfPageContentComponent, { static: true },] }],
    actions: [{ type: Input, args: ['t-actions',] }],
    breadcrumb: [{ type: Input, args: ['t-breadcrumb',] }],
    title: [{ type: Input, args: ['t-title',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfPageDefaultBaseComponent
 *
 * \@example
 *
 * <example name="thf-page-default-basic" title="Totvs Page Default Basic">
 *  <file name="sample-thf-page-default-basic/sample-thf-page-default-basic.component.html"> </file>
 *  <file name="sample-thf-page-default-basic/sample-thf-page-default-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-default-labs" title="Totvs Page Default Labs">
 *  <file name="sample-thf-page-default-labs/sample-thf-page-default-labs.component.html"> </file>
 *  <file name="sample-thf-page-default-labs/sample-thf-page-default-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-default-dashboard" title="Totvs Page Default - Dashboard">
 *  <file name="sample-thf-page-default-dashboard/sample-thf-page-default-dashboard.component.html"> </file>
 *  <file name="sample-thf-page-default-dashboard/sample-thf-page-default-dashboard.component.ts"> </file>
 *  <file name="sample-thf-page-default-dashboard/sample-thf-page-default-dashboard.service.ts"> </file>
 * </example>
 */
class ThfPageDefaultComponent extends ThfPageDefaultBaseComponent {
    /**
     * @param {?} viewRef
     * @param {?} renderer
     * @param {?} router
     */
    constructor(viewRef, renderer, router) {
        super();
        this.renderer = renderer;
        this.router = router;
        this.limitPrimaryActions = 3;
        this.maxWidthMobile = 480;
        this.parentRef = viewRef['_view']['component'];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setIsMobile();
        this.setDropdownActions();
        this.renderer.listen('window', 'resize', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.onResize(event);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.setDropdownActions();
    }
    /**
     * @param {?} action
     * @return {?}
     */
    actionIsDisabled(action) {
        return isTypeof(action.disabled, 'function') ? action.disabled(action) : action.disabled;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    callAction(item) {
        if (item.url) {
            this.router.navigate([item.url]);
        }
        else if (item.action) {
            callFunction(item.action, this.parentRef);
        }
    }
    /**
     * @return {?}
     */
    hasPageHeader() {
        return !!(this.title || (this.actions && this.actions.length) || (this.breadcrumb && this.breadcrumb.items.length));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        /** @type {?} */
        const width = ((/** @type {?} */ (event.target))).innerWidth;
        if (width < this.maxWidthMobile) {
            this.isMobile = true;
            this.limitPrimaryActions = 2;
            this.setDropdownActions();
        }
        else {
            this.isMobile = false;
            this.limitPrimaryActions = 3;
            this.setDropdownActions();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setIsMobile() {
        if (window.innerWidth < this.maxWidthMobile) {
            this.isMobile = true;
            this.limitPrimaryActions = 2;
        }
    }
    /**
     * @return {?}
     */
    setDropdownActions() {
        if (this.actions.length > this.limitPrimaryActions) {
            this.dropdownActions = this.actions.slice(this.limitPrimaryActions - 1);
        }
    }
}
ThfPageDefaultComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-page-default',
                template: "<thf-page>\n\n  <!-- HEADER -->\n  <thf-page-header\n    *ngIf=\"hasPageHeader()\"\n    [t-breadcrumb]=\"breadcrumb\"\n    [t-title]=\"title\">\n\n    <!-- OPERATIONS -->\n    <div class=\"thf-page-header-actions\">\n      <thf-dropdown *ngIf=\"actions.length > limitPrimaryActions\"\n        t-label=\"Outras a\u00E7\u00F5es\"\n        [t-actions]=\"dropdownActions\">\n      </thf-dropdown>\n\n      <thf-button *ngIf=\"actions.length === 3 && actions[2] && !isMobile\"\n        [t-disabled]=\"actionIsDisabled(actions[2])\"\n        [t-label]=\"actions[2].label\"\n        (t-click)=\"callAction(actions[2])\">\n      </thf-button>\n\n      <thf-button *ngIf=\"actions[1] && (actions.length === 2 || !isMobile)\"\n        [t-disabled]=\"actionIsDisabled(actions[1])\"\n        [t-label]=\"actions[1].label\"\n        (t-click)=\"callAction(actions[1])\">\n      </thf-button>\n\n      <thf-button *ngIf=\"actions[0]\"\n        t-type=\"primary\"\n        [t-disabled]=\"actionIsDisabled(actions[0])\"\n        [t-icon]=\"actions[0].icon\"\n        [t-label]=\"actions[0].label\"\n        (t-click)=\"callAction(actions[0])\">\n      </thf-button>\n    </div>\n\n  </thf-page-header>\n\n  <!-- CONTENT -->\n  <thf-page-content>\n    <ng-content></ng-content>\n  </thf-page-content>\n\n</thf-page>\n"
            }] }
];
/** @nocollapse */
ThfPageDefaultComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: Router }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfPageDetailLiteralsDefault = {
    en: (/** @type {?} */ ({
        back: 'Back',
        edit: 'Edit',
        remove: 'Remove'
    })),
    es: (/** @type {?} */ ({
        back: 'Volver',
        edit: 'Editar',
        remove: 'Eliminar'
    })),
    pt: (/** @type {?} */ ({
        back: 'Voltar',
        edit: 'Editar',
        remove: 'Remover'
    }))
};
/**
 * \@description
 *
 * O componente **thf-page-detail** é utilizado como container principal para a tela de detalhamento de um registro.
 * Por padrão possui 3 ações, cada ação na tela executa uma função no componente que está utilizando o thf-page-detail,
 * são elas:
 *  - Voltar (função: back);
 *  - Editar (função: edit);
 *  - Remover (função: remove);
 *
 * Caso não estiver implementado alguma função, listado anteriormente, o mesmo não será apresentado.
 */
class ThfPageDetailBaseComponent {
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-page-detail`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfPageDetailLiterals = {
     *    edit: 'Edição',
     *    remove: 'Exclusão',
     *    back: 'Menu'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfPageDetailLiterals = {
     *    remove: 'Excluir registro permanentemente'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-page-detail
     *   [t-literals]="customLiterals">
     * </thf-page-detail>
     * ```
     *
     *  > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfPageDetailLiteralsDefault[thfLocaleDefault], thfPageDetailLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfPageDetailLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfPageDetailLiteralsDefault[browserLanguage()];
    }
    /**
     * Título da página.
     * @param {?} title
     * @return {?}
     */
    set title(title) {
        this._title = title;
        this.thfPageContent.recalculateHeaderSize();
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
}
ThfPageDetailBaseComponent.propDecorators = {
    thfPageContent: [{ type: ViewChild, args: [ThfPageContentComponent, { static: true },] }],
    breadcrumb: [{ type: Input, args: ['t-breadcrumb',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    title: [{ type: Input, args: ['t-title',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description Verifica se existe a função dentro do contexto.
 *
 * @param {?} action Nome da função que será verificada a existência no parentContext.
 *
 * @param {?} parentContext Contexto da qual a função será verificada.
 * @return {?}
 */
function hasAction(action, parentContext) {
    return parentContext && parentContext[action];
}
/**
 * \@description Executa a função cujo o nome foi passado por parâmetro.
 *
 * @param {?} action Nome da função que será executada no parentContext.
 *
 * @param {?} parentContext Contexto da qual a função será executada.
 * @return {?}
 */
function callAction(action, parentContext) {
    if (hasAction(action, parentContext)) {
        parentContext[action]();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfPageDetailBaseComponent
 *
 * \@example
 *
 * <example name="thf-page-detail-basic" title="Totvs Page Detail Basic">
 *  <file name="sample-thf-page-detail-basic/sample-thf-page-detail-basic.component.html"> </file>
 *  <file name="sample-thf-page-detail-basic/sample-thf-page-detail-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-detail-labs" title="Totvs Page Detail Labs">
 *  <file name="sample-thf-page-detail-labs/sample-thf-page-detail-labs.component.html"> </file>
 *  <file name="sample-thf-page-detail-labs/sample-thf-page-detail-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-detail-user" title="Totvs Page Detail - User">
 *  <file name="sample-thf-page-detail-user/sample-thf-page-detail-user.component.html"> </file>
 *  <file name="sample-thf-page-detail-user/sample-thf-page-detail-user.component.ts"> </file>
 * </example>
 */
class ThfPageDetailComponent extends ThfPageDetailBaseComponent {
    /**
     * @param {?} viewRef
     */
    constructor(viewRef) {
        super();
        this.callActionFn = callAction;
        this.hasActionFn = hasAction;
        this.parentContext = viewRef['_view']['component'];
    }
    /**
     * @return {?}
     */
    hasAnyAction() {
        return this.hasActionFn('back', this.parentContext) ||
            this.hasActionFn('edit', this.parentContext) ||
            this.hasActionFn('remove', this.parentContext);
    }
    /**
     * @param {?} property
     * @return {?}
     */
    hasEditFn(property) {
        if (property === 'icon') {
            return this.hasActionFn('edit', this.parentContext) ? '' : 'thf-icon-delete';
        }
        else if (property === 'type') {
            return this.hasActionFn('edit', this.parentContext) ? 'default' : 'primary';
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} property
     * @return {?}
     */
    hasEditOrRemoveFn(property) {
        if (property === 'icon') {
            return this.hasActionFn('edit', this.parentContext) || this.hasActionFn('remove', this.parentContext) ? '' : 'thf-icon-arrow-left';
        }
        else if (property === 'type') {
            return this.hasActionFn('edit', this.parentContext) || this.hasActionFn('remove', this.parentContext) ? 'default' : 'primary';
        }
        else {
            return '';
        }
    }
    /**
     * @return {?}
     */
    hasPageHeader() {
        return !!(this.title || this.hasAnyAction() || (this.breadcrumb && this.breadcrumb.items.length));
    }
}
ThfPageDetailComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-page-detail',
                template: "<thf-page>\n  <!-- HEADER -->\n  <thf-page-header\n    *ngIf=\"hasPageHeader()\"\n    [t-breadcrumb]=\"breadcrumb\"\n    [t-title]=\"title\">\n\n    <!-- OPERATIONS -->\n    <div *ngIf=\"hasAnyAction()\" class=\"thf-page-header-actions\">\n      <thf-button *ngIf=\"hasActionFn('back', parentContext)\"\n        [t-icon]=\"hasEditOrRemoveFn('icon')\"\n        [t-label]=\"literals.back\"\n        [t-type]=\"hasEditOrRemoveFn('type')\"\n        (t-click)=\"callActionFn('back', parentContext)\">\n      </thf-button>\n\n      <thf-button *ngIf=\"hasActionFn('remove', parentContext)\"\n        [t-icon]=\"hasEditFn('icon')\"\n        [t-label]=\"literals.remove\"\n        [t-type]=\"hasEditFn('type')\"\n        (t-click)=\"callActionFn('remove', parentContext)\">\n      </thf-button>\n\n      <thf-button *ngIf=\"hasActionFn('edit', parentContext)\"\n        t-icon=\"thf-icon-edit\"\n        t-type=\"primary\"\n        [t-label]=\"literals.edit\"\n        (t-click)=\"callActionFn('edit', parentContext)\">\n      </thf-button>\n    </div>\n\n  </thf-page-header>\n\n  <!-- CONTENT -->\n  <thf-page-content>\n    <ng-content>\n    </ng-content>\n  </thf-page-content>\n\n</thf-page>\n"
            }] }
];
/** @nocollapse */
ThfPageDetailComponent.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfPageEditLiteralsDefault = {
    en: (/** @type {?} */ ({
        cancel: 'Cancel',
        save: 'Save',
        saveNew: 'Save and New'
    })),
    es: (/** @type {?} */ ({
        cancel: 'Cancelar',
        save: 'Guardar',
        saveNew: 'Guardar y Nuevo'
    })),
    pt: (/** @type {?} */ ({
        cancel: 'Cancelar',
        save: 'Salvar',
        saveNew: 'Salvar e Novo'
    }))
};
/**
 * \@description
 *
 * O componente **thf-page-edit** é utilizado como container principal para tela de edição ou adição de um
 * registro.
 * Por padrão possui 3 ações, cada ação na tela executa uma função no componente que está utilizando o thf-page-edit,
 * são elas:
 *  - Cancelar (função: cancel);
 *  - Salvar e Novo (função: saveNew);
 *  - Salvar (função: save);
 *
 * Caso não estiver implementado alguma função, listado anteriormente, o mesmo não será apresentado.
 *
 * Os botões "Salvar" e "Salvar e Novo" podem ser habilitados/desabilitados utilizando a propriedade t-disable-submit.
 * Esta propriedade pode ser utilizada para desabilitar os botões caso exista um formulário inválido na página ou alguma
 * regra de negócio não tenha sido atendida.
 */
class ThfPageEditBaseComponent {
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-page-edit`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfPageEditLiterals = {
     *    cancel: 'Voltar',
     *    save: 'Confirmar',
     *    saveNew: 'Confirmar e criar um novo'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfPageEditLiterals = {
     *    cancel: 'Cancelar processo'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-page-edit
     *   [t-literals]="customLiterals">
     * </thf-page-edit>
     * ```
     *
     *  > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfPageEditLiteralsDefault[thfLocaleDefault], thfPageEditLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfPageEditLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfPageEditLiteralsDefault[browserLanguage()];
    }
    /**
     * Título da página.
     * @param {?} title
     * @return {?}
     */
    set title(title) {
        this._title = title;
        this.thfPageContent.recalculateHeaderSize();
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
}
ThfPageEditBaseComponent.propDecorators = {
    thfPageContent: [{ type: ViewChild, args: [ThfPageContentComponent, { static: true },] }],
    breadcrumb: [{ type: Input, args: ['t-breadcrumb',] }],
    disableSubmit: [{ type: Input, args: ['t-disable-submit',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    title: [{ type: Input, args: ['t-title',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfPageEditBaseComponent
 *
 * \@example
 *
 * <example name="thf-page-edit-basic" title="Totvs Page Edit Basic">
 *  <file name="sample-thf-page-edit-basic/sample-thf-page-edit-basic.component.html"> </file>
 *  <file name="sample-thf-page-edit-basic/sample-thf-page-edit-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-edit-labs" title="Totvs Page Edit Labs">
 *  <file name="sample-thf-page-edit-labs/sample-thf-page-edit-labs.component.html"> </file>
 *  <file name="sample-thf-page-edit-labs/sample-thf-page-edit-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-edit-user" title="Totvs Page Edit - User">
 *  <file name="sample-thf-page-edit-user/sample-thf-page-edit-user.component.html"> </file>
 *  <file name="sample-thf-page-edit-user/sample-thf-page-edit-user.component.ts"> </file>
 * </example>
 */
class ThfPageEditComponent extends ThfPageEditBaseComponent {
    /**
     * @param {?} viewRef
     */
    constructor(viewRef) {
        super();
        this.hasAction = hasAction;
        this.callAction = callAction;
        this.parentContext = viewRef['_view']['component'];
    }
    /**
     * @param {?} icon
     * @return {?}
     */
    getIcon(icon) {
        if (icon === 'cancel') {
            return this.isPrimaryAction('cancel') ? 'thf-icon-close' : '';
        }
        if (icon === 'saveNew') {
            return this.isPrimaryAction('saveNew') ? 'thf-icon-ok' : '';
        }
        return '';
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getType(type) {
        /** @type {?} */
        const isCancelPrimaryAction = type === 'cancel' && this.isPrimaryAction('cancel');
        /** @type {?} */
        const isSaveNewPrimaryAction = type === 'saveNew' && this.isPrimaryAction('saveNew');
        return isCancelPrimaryAction || isSaveNewPrimaryAction ? 'primary' : 'default';
    }
    /**
     * @return {?}
     */
    hasAnyAction() {
        return hasAction('cancel', this.parentContext) || hasAction('saveNew', this.parentContext) || hasAction('save', this.parentContext);
    }
    /**
     * @return {?}
     */
    hasPageHeader() {
        return !!(this.title || this.hasAnyAction() || (this.breadcrumb && this.breadcrumb.items.length));
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    isPrimaryAction(action) {
        /** @type {?} */
        const hasSaveAction = !hasAction('save', this.parentContext);
        if (action === 'saveNew') {
            return hasSaveAction;
        }
        if (action === 'cancel') {
            return !hasAction('saveNew', this.parentContext) && hasSaveAction;
        }
        return false;
    }
}
ThfPageEditComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-page-edit',
                template: "<thf-page>\n  <!-- HEADER -->\n  <thf-page-header\n    *ngIf=\"hasPageHeader()\"\n    [t-breadcrumb]=\"breadcrumb\"\n    [t-title]=\"title\">\n\n    <!-- OPERATIONS -->\n    <div *ngIf=\"hasAnyAction()\" class=\"thf-page-header-actions\">\n      <thf-button\n        *ngIf=\"hasAction('cancel', parentContext)\"\n        [t-icon]=\"getIcon('cancel')\"\n        [t-label]=\"literals.cancel\"\n        [t-type]=\"getType('cancel')\"\n        (t-click)=\"callAction('cancel', parentContext)\">\n      </thf-button>\n\n      <thf-button\n        *ngIf=\"hasAction('saveNew', parentContext)\"\n        [t-disabled]=\"disableSubmit\"\n        [t-icon]=\"getIcon('saveNew')\"\n        [t-label]=\"literals.saveNew\"\n        [t-type]=\"getType('saveNew')\"\n        (t-click)=\"callAction('saveNew', parentContext)\">\n      </thf-button>\n\n      <thf-button\n        *ngIf=\"hasAction('save', parentContext)\"\n        t-icon=\"thf-icon-ok\"\n        t-type=\"primary\"\n        [t-disabled]=\"disableSubmit\"\n        [t-label]=\"literals.save\"\n        (t-click)=\"callAction('save', parentContext)\">\n      </thf-button>\n    </div>\n\n  </thf-page-header>\n\n  <!-- CONTENT -->\n  <thf-page-content>\n    <ng-content>\n    </ng-content>\n  </thf-page-content>\n\n</thf-page>\n"
            }] }
];
/** @nocollapse */
ThfPageEditComponent.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * O componente **thf-page-header** é responsável pelo título da página e container dos botões de ações dos componentes
 * thf-page-list e thf-page-base.
 */
class ThfPageHeaderBaseComponent {
    /**
     * Objeto com propriedades do breadcrumb.
     * @param {?} value
     * @return {?}
     */
    set breadcrumb(value) {
        this._breadcrumb = value;
    }
    /**
     * @return {?}
     */
    get breadcrumb() {
        return this._breadcrumb;
    }
}
ThfPageHeaderBaseComponent.propDecorators = {
    breadcrumb: [{ type: Input, args: ['t-breadcrumb',] }],
    title: [{ type: Input, args: ['t-title',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 * \@docsExtends ThfPageHeaderBaseComponent
 */
class ThfPageHeaderComponent extends ThfPageHeaderBaseComponent {
}
ThfPageHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-page-header',
                template: "<div class=\"thf-page-header\">\n  <!-- Breadcrumb -->\n  <div class=\"thf-page-header-breadcrumb\" *ngIf=\"breadcrumb && breadcrumb.items.length\">\n    <thf-breadcrumb\n      [t-favorite-service]=\"breadcrumb.favorite\"\n      [t-items]=\"breadcrumb.items\"\n      [t-params-service]=\"breadcrumb.params\">\n    </thf-breadcrumb>\n  </div> \n\n  <!-- Titulo -->\n  <h1 class=\"thf-page-header-title\" *ngIf=\"title\">\n    {{ title }}\n  </h1>\n\n  <!-- Opera\u00E7\u00F5es -->\n  <ng-content></ng-content>\n</div>\n"
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfPageListLiteralsDefault = {
    en: (/** @type {?} */ ({
        otherActions: 'Other actions'
    })),
    es: (/** @type {?} */ ({
        otherActions: 'Otras acciones'
    })),
    pt: (/** @type {?} */ ({
        otherActions: 'Outras ações'
    }))
};
/**
 * \@description
 *
 * O componente `thf-page-list` é utilizado como o container principal para as telas de listagem de dados,
 * podendo ser apresentado como lista ou tabela.
 *
 * Este componente possibilita realizar filtro dos dados, no qual permite que seja atribuido uma função que será executada no momento
 * da filtragem. Este comportamento pode ser acionado tanto ao *click* do ícone [thf-icon-search](/guides/icons)
 * quanto ao pressionar da tecla *ENTER* quando o foco estiver no campo de pesquisa.
 *
 * Para facilitar a manipulação e visualização dos filtros aplicados, é possível também utilizar o componente
 * [`thf-disclaimer-group`](/documentation/thf-disclaimer-group).
 * @abstract
 */
class ThfPageListBaseComponent extends ThfPageDefaultBaseComponent {
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto que implementa as propriedades da interface `ThfDisclaimerGroup`.
     * @param {?} value
     * @return {?}
     */
    set disclaimerGroup(value) {
        if (!value) {
            value = (/** @type {?} */ ({}));
        }
        this._disclaimerGroup = value;
    }
    /**
     * @return {?}
     */
    get disclaimerGroup() {
        return this._disclaimerGroup;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-page-list`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfPageListLiterals = {
     *    otherActions: 'Mais ações'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfPageListLiterals = {
     *    otherActions: 'Ações da página'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-page-list
     *   [t-literals]="customLiterals">
     * </thf-page-list>
     * ```
     *
     *  > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfPageListLiteralsDefault[thfLocaleDefault], thfPageListLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfPageListLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfPageListLiteralsDefault[browserLanguage()];
    }
}
ThfPageListBaseComponent.propDecorators = {
    breadcrumb: [{ type: Input, args: ['t-breadcrumb',] }],
    disclaimerGroup: [{ type: Input, args: ['t-disclaimer-group',] }],
    filter: [{ type: Input, args: ['t-filter',] }],
    literals: [{ type: Input, args: ['t-literals',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfPageListBaseComponent
 *
 * \@example
 *
 * <example name="thf-page-list-basic" title="Totvs Page List Basic">
 *  <file name="sample-thf-page-list-basic/sample-thf-page-list-basic.component.html"> </file>
 *  <file name="sample-thf-page-list-basic/sample-thf-page-list-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-list-labs" title="Totvs Page List Labs">
 *  <file name="sample-thf-page-list-labs/sample-thf-page-list-labs.component.html"> </file>
 *  <file name="sample-thf-page-list-labs/sample-thf-page-list-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-page-list-hiring-processes" title="Totvs Page List - Hiring Processes">
 *  <file name="sample-thf-page-list-hiring-processes/sample-thf-page-list-hiring-processes.component.html"> </file>
 *  <file name="sample-thf-page-list-hiring-processes/sample-thf-page-list-hiring-processes.component.ts"> </file>
 *  <file name="sample-thf-page-list-hiring-processes/sample-thf-page-list-hiring-processes.service.ts"> </file>
 * </example>
 */
class ThfPageListComponent extends ThfPageListBaseComponent {
    /**
     * @param {?} viewRef
     * @param {?} renderer
     * @param {?} router
     */
    constructor(viewRef, renderer, router) {
        super();
        this.renderer = renderer;
        this.router = router;
        this.limitPrimaryActions = 3;
        this.isRecalculate = true;
        this.maxWidthMobile = 480;
        this.callFunction = callFunction;
        this.parentRef = viewRef['_view']['component'];
        this.initializeListeners();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.advancedSearch = this.initFixedLiterals();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setIsMobile();
        this.setDropdownActions();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.setDropdownActions();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @param {?} action
     * @return {?}
     */
    actionIsDisabled(action) {
        return isTypeof(action.disabled, 'function') ? action.disabled(action) : action.disabled;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    callAction(item) {
        if (item.url) {
            this.router.navigate([item.url]);
        }
        else if (item.action) {
            callFunction(item.action, this.parentRef);
        }
    }
    /**
     * @return {?}
     */
    hasPageHeader() {
        return !!(this.title || (this.actions && this.actions.length) || (this.breadcrumb && this.breadcrumb.items.length));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        /** @type {?} */
        const width = ((/** @type {?} */ (event.target))).innerWidth;
        if (width < this.maxWidthMobile) {
            this.isMobile = true;
            this.limitPrimaryActions = 2;
            this.setDropdownActions();
        }
        else {
            this.isMobile = false;
            this.limitPrimaryActions = 3;
            this.setDropdownActions();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setIsMobile() {
        if (window.innerWidth < this.maxWidthMobile) {
            this.isMobile = true;
            this.limitPrimaryActions = 2;
        }
    }
    /**
     * @return {?}
     */
    setDropdownActions() {
        if (this.actions.length > this.limitPrimaryActions) {
            this.dropdownActions = this.actions.slice(this.limitPrimaryActions - 1);
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    callActionFilter(field) {
        this.callFunction(this.filter[field], this.parentRef);
    }
    /**
     * @return {?}
     */
    initFixedLiterals() {
        /** @type {?} */
        const locale = browserLanguage();
        /** @type {?} */
        const literal = {
            pt: {
                advancedSearch: 'Busca avançada'
            },
            en: {
                advancedSearch: 'Advanced search'
            },
            es: {
                advancedSearch: 'Búsqueda avanzada'
            }
        };
        return literal[locale].advancedSearch;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    onkeypress(key) {
        if (key === 13) {
            this.callActionFilter('action');
        }
    }
    /**
     * @param {?} newModel
     * @return {?}
     */
    changeModel(newModel) {
        this.parentRef[this.filter.ngModel] = newModel;
    }
    // Recebe evento change do disclaimer e recalcula tela
    /**
     * @param {?} disclaimers
     * @return {?}
     */
    onChangeDisclaimerGroup(disclaimers) {
        if ((disclaimers && disclaimers.length && this.isRecalculate) || (disclaimers.length === 0 && !this.isRecalculate)) {
            this.thfPageContent.recalculateHeaderSize();
            this.isRecalculate = !this.isRecalculate;
        }
        if (this.disclaimerGroup && this.disclaimerGroup.change) {
            this.disclaimerGroup.change(disclaimers);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initializeListeners() {
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.onResize(event);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        this.resizeListener();
    }
}
ThfPageListComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-page-list',
                template: "<thf-page>\n\n  <!-- HEADER -->\n  <thf-page-header\n    *ngIf=\"hasPageHeader()\"\n    [class.thf-page-list-header-padding]=\"filter && !actions.length\"\n    [t-breadcrumb]=\"breadcrumb\"\n    [t-title]=\"title\">\n\n    <!-- OPERATIONS -->\n    <div class=\"thf-page-list-operations\">\n      <div class=\"thf-page-list-actions\"\n        [class.thf-page-list-actions-padding]=\"filter\">\n        <thf-button *ngIf=\"actions[0]\"\n          t-type=\"primary\"\n          [t-disabled]=\"actionIsDisabled(actions[0])\"\n          [t-icon]=\"actions[0].icon\"\n          [t-label]=\"actions[0].label\"\n          (t-click)=\"callAction(actions[0])\">\n        </thf-button>\n\n        <thf-button *ngIf=\"actions[1] && (actions.length === 2 || !isMobile)\"\n          [t-disabled]=\"actionIsDisabled(actions[1])\"\n          [t-label]=\"actions[1].label\"\n          (t-click)=\"callAction(actions[1])\">\n        </thf-button>\n\n        <thf-button *ngIf=\"actions.length == 3 && actions[2] && !isMobile\"\n          [t-disabled]=\"actionIsDisabled(actions[2])\"\n          [t-label]=\"actions[2].label\"\n          (t-click)=\"callAction(actions[2])\">\n        </thf-button>\n\n        <thf-dropdown *ngIf=\"actions.length > limitPrimaryActions\"\n          [t-actions]=\"dropdownActions\"\n          [t-label]=\"literals.otherActions\">\n        </thf-dropdown>\n      </div>\n\n      <!-- FILTER -->\n      <div class=\"thf-page-list-filter-wrapper\" *ngIf=\"filter\">\n\n        <div class=\"thf-field-container-content thf-page-filter-content\">\n          <div class=\"thf-field-icon-container-right\">\n            <span class=\"thf-icon thf-icon-search thf-field-icon\"\n              (click)=\"callActionFilter('action')\">\n            </span>\n          </div>\n\n          <input class=\"thf-input thf-input-icon-right\"\n            name=\"model\"\n            type=\"text\"\n            [ngModel]=\"parentRef[filter.ngModel]\"\n            [placeholder]=\"filter.placeholder || ''\"\n            (keypress)=\"onkeypress($event.keyCode)\"\n            (ngModelChange)=\"changeModel($event)\">\n        </div>\n\n        <div class=\"thf-page-list-filter-search\" *ngIf=\"filter.advancedAction\">\n          <span class=\"thf-page-list-filter-search-link\"\n            tabindex=\"0\"\n            (click)=\"callActionFilter('advancedAction')\"\n            (keydown.enter)=\"callActionFilter('advancedAction')\">\n              {{advancedSearch}}\n          </span>\n        </div>\n\n      </div>\n    </div>\n\n    <!-- DISCLAIMER -->\n    <thf-disclaimer-group *ngIf=\"!!disclaimerGroup\"\n      [class.thf-page-list-disclaimer-group]=\"!!disclaimerGroup?.disclaimers?.length\"\n      [t-disclaimers]=\"disclaimerGroup?.disclaimers\"\n      [t-hide-remove-all]=\"disclaimerGroup?.hideRemoveAll\"\n      [t-title]=\"disclaimerGroup?.title\"\n      (t-change)=\"onChangeDisclaimerGroup($event)\">\n    </thf-disclaimer-group>\n\n  </thf-page-header>\n\n  <!-- CONTENT -->\n  <thf-page-content>\n    <ng-content></ng-content>\n  </thf-page-content>\n\n</thf-page>\n"
            }] }
];
/** @nocollapse */
ThfPageListComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: Router }
];
ThfPageListComponent.propDecorators = {
    thfPageContent: [{ type: ViewChild, args: [ThfPageContentComponent, { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo dos componentes thf-page-default, thf-page-edit, thf-page-list, thf-page-login e thf-page-detail.
 */
class ThfPageModule {
}
ThfPageModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    RouterModule,
                    ThfBreadcrumbModule,
                    ThfButtonModule,
                    ThfDisclaimerGroupModule,
                    ThfDropdownModule,
                    ThfFieldModule,
                    ThfModalModule
                ],
                declarations: [
                    ThfPageComponent,
                    ThfPageContentComponent,
                    ThfPageDefaultComponent,
                    ThfPageDetailComponent,
                    ThfPageEditComponent,
                    ThfPageHeaderComponent,
                    ThfPageListComponent
                ],
                exports: [
                    ThfPageDetailComponent,
                    ThfPageDefaultComponent,
                    ThfPageEditComponent,
                    ThfPageListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const THF_POPOVER_DEFAULT_POSITION = 'right';
/** @type {?} */
const THF_POPOVER_DEFAULT_TRIGGER = 'click';
/** @type {?} */
const THF_POPOVER_TRIGGERS = ['click', 'hover'];
/**
 * \@description
 *
 * O componente `thf-popover` é um container pequeno recomendado para incluir vários tipos de conteúdo como:
 * gráficos, textos, imagens e inputs. Ele abre sobreposto aos outros componentes.
 *
 * Para mostrar apenas pequenos textos recomenda-se o uso da diretiva
 * [**thf-tooltip**](https://thf.totvs.com.br/documentation/thf-tooltip?view=doc).
 *
 * Para conteúdos maiores recomenda-se o uso do [**thf-modal**](https://thf.totvs.com.br/documentation/thf-modal?view=doc).
 *
 * Ele contém um título e também é possível escolher as posições do popover em relação ao componente pai,
 * as posições permitidas são: `right`, `right-top`, `right-bottom`, `top`, `top-left`, `top-right`,
 * `left`, `left-top`, `left-bottom`, `bottom`, `bottom-left` e `bottom-right`.
 *
 * Também é possível escolher entre os dois eventos que podem abrir o *popover*.
 * Os eventos permitidos são: `click` e `hover`.
 *
 */
class ThfPopoverBaseComponent {
    constructor() {
        // Controla se o popover fica oculto ou visível, por padrão é oculto.
        this.isHidden = true;
        this._hideArrow = false;
        this._position = THF_POPOVER_DEFAULT_POSITION;
        this._trigger = THF_POPOVER_DEFAULT_TRIGGER;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita a seta do componente *popover*.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set hideArrow(value) {
        this._hideArrow = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get hideArrow() {
        return this._hideArrow;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a posição que o thf-popover abrirá em relação ao componente alvo. Sugere-se que seja
     * usada a orientação "right" (direita), porém o mesmo é flexível e será rotacionado
     * automaticamente para se adequar a tela, caso necessário.
     *
     * Posições válidas:
     * - `right`: Posiciona o thf-popover no lado direito do componente alvo.
     * - `right-bottom`: Posiciona o thf-popover no lado direito inferior do componente alvo.
     * - `right-top`: Posiciona o thf-popover no lado direito superior do componente alvo.
     * - `bottom`: Posiciona o thf-popover abaixo do componente alvo.
     * - `bottom-left`: Posiciona o thf-popover abaixo e à esquerda do componente alvo.
     * - `bottom-right`: Posiciona o thf-popover abaixo e à direita do componente alvo.
     * - `left`: Posiciona o thf-popover no lado esquerdo do componente alvo.
     * - `left-top`: Posiciona o thf-popover no lado esquerdo superior do componente alvo.
     * - `left-bottom`: Posiciona o thf-popover no lado esquerdo inferior do componente alvo.
     * - `top`: Posiciona o thf-popover acima do componente alvo.
     * - `top-right`: Posiciona o thf-popover acima e à direita do componente alvo.
     * - `top-left`: Posiciona o thf-popover acima e à esquerda do componente alvo.
     *
     *
     * \@default right
     * @param {?} value
     * @return {?}
     */
    set position(value) {
        this._position = THF_CONTROL_POSITIONS.includes(value) ? value : THF_POPOVER_DEFAULT_POSITION;
    }
    /**
     * @return {?}
     */
    get position() {
        return this._position;
    }
    /**
     * \@description
     *
     * Define o evento que abrirá o thf-popover.
     *
     * Valores válidos:
     *  - `click`: Abre ao clicar no componente alvo.
     *  - `hover`: Abre ao passar o mouse sobre o componente alvo.
     *
     * \@default click
     * \@optional
     * @param {?} value
     * @return {?}
     */
    set trigger(value) {
        this._trigger = THF_POPOVER_TRIGGERS.includes(value) ? value : THF_POPOVER_DEFAULT_TRIGGER;
    }
    /**
     * @return {?}
     */
    get trigger() {
        return this._trigger;
    }
}
ThfPopoverBaseComponent.propDecorators = {
    hideArrow: [{ type: Input, args: ['t-hide-arrow',] }],
    position: [{ type: Input, args: ['t-position',] }],
    target: [{ type: Input, args: ['t-target',] }],
    title: [{ type: Input, args: ['t-title',] }],
    trigger: [{ type: Input, args: ['t-trigger',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@docsExtends ThfPopoverBaseComponent
 *
 * \@example
 *
 * <example name="thf-popover-basic" title="Totvs Popover Basic">
 *   <file name="sample-thf-popover-basic/sample-thf-popover-basic.component.html"> </file>
 *   <file name="sample-thf-popover-basic/sample-thf-popover-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-popover-labs" title="Totvs Popover Labs">
 *   <file name="sample-thf-popover-labs/sample-thf-popover-labs.component.html"> </file>
 *   <file name="sample-thf-popover-labs/sample-thf-popover-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-popover-credit-card" title="Totvs Popover - Credit Card">
 *   <file name="sample-thf-popover-credit-card/sample-thf-popover-credit-card.component.html"> </file>
 *   <file name="sample-thf-popover-credit-card/sample-thf-popover-credit-card.component.ts"> </file>
 * </example>
 */
class ThfPopoverComponent extends ThfPopoverBaseComponent {
    /**
     * @param {?} renderer
     * @param {?} thfControlPosition
     */
    constructor(renderer, thfControlPosition) {
        super();
        this.renderer = renderer;
        this.thfControlPosition = thfControlPosition;
        this.arrowDirection = 'left';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initEventListenerFunction();
        /** @type {?} */
        const popoverOffset = 8;
        this.thfControlPosition.setElements(this.popoverElement.nativeElement, popoverOffset, this.target);
        this.setRendererListenInit();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @return {?}
     */
    close() {
        this.isHidden = true;
    }
    /**
     * @return {?}
     */
    debounceResize() {
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout((/**
         * @return {?}
         */
        () => {
            this.setPopoverPosition();
        }), 200);
    }
    /**
     * @return {?}
     */
    open() {
        this.addScrollEventListener();
        this.isHidden = false;
        this.setOpacity(0);
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.thfControlPosition.adjustPosition(this.position);
            this.arrowDirection = this.thfControlPosition.getArrowDirection();
            this.setOpacity(1);
        }));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setOpacity(value) {
        this.popoverElement.nativeElement.style.opacity = value;
    }
    /**
     * @return {?}
     */
    setPopoverPosition() {
        this.thfControlPosition.adjustPosition(this.position);
        this.arrowDirection = this.thfControlPosition.getArrowDirection();
    }
    /**
     * @return {?}
     */
    setRendererListenInit() {
        this.resizeListener = this.renderer.listen('window', 'resize', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (!this.isHidden) {
                this.debounceResize();
            }
        }));
        if (this.trigger === 'hover') {
            this.mouseEnterListener = this.renderer.listen(this.target.nativeElement, 'mouseenter', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                this.open();
            }));
            this.mouseLeaveListener = this.renderer.listen(this.target.nativeElement, 'mouseleave', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                this.close();
            }));
        }
        else {
            this.clickoutListener = this.renderer.listen('document', 'click', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                this.togglePopup(event);
            }));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    togglePopup(event) {
        if (!this.isHidden && !this.popoverElement.nativeElement.contains(event.target) &&
            !this.target.nativeElement.contains(event.target)) {
            this.close();
        }
        else if (this.target.nativeElement.contains(event.target)) {
            this.popoverElement.nativeElement.hidden ? this.open() : this.close();
        }
    }
    /**
     * @private
     * @return {?}
     */
    addScrollEventListener() {
        window.addEventListener('scroll', this.eventListenerFunction, true);
    }
    /**
     * @private
     * @return {?}
     */
    initEventListenerFunction() {
        this.eventListenerFunction = (/**
         * @return {?}
         */
        () => {
            this.setPopoverPosition();
        });
    }
    /**
     * @private
     * @return {?}
     */
    removeListeners() {
        if (this.clickoutListener) {
            this.clickoutListener();
        }
        if (this.mouseEnterListener) {
            this.mouseEnterListener();
        }
        if (this.mouseLeaveListener) {
            this.mouseLeaveListener();
        }
        this.resizeListener();
        window.removeEventListener('scroll', this.eventListenerFunction, true);
    }
}
ThfPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-popover',
                template: "<div [hidden]=\"isHidden\" class=\"thf-popover\" #popoverElement>\n\n  <div *ngIf=\"!hideArrow\" class=\"thf-popover-arrow thf-arrow-{{ arrowDirection }}\"></div>\n\n  <div class=\"thf-popover-content\">\n    <span *ngIf=\"title\" class=\"thf-popover-title\">{{ title }}</span>\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                providers: [ThfControlPositionService]
            }] }
];
/** @nocollapse */
ThfPopoverComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ThfControlPositionService }
];
ThfPopoverComponent.propDecorators = {
    popoverElement: [{ type: ViewChild, args: ['popoverElement', { read: ElementRef, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-popover.
 */
class ThfPopoverModule {
}
ThfPopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [ThfPopoverComponent],
                exports: [ThfPopoverComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para o conjunto de círculos que faz a passagem de itens do `thf-slide`.
 */
class ThfSlideCirclesComponent {
    constructor() {
        /**
         * Evento emitido ao clicar em um controle.
         */
        this.click = new EventEmitter();
    }
}
ThfSlideCirclesComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-slide-circles',
                template: "<div class=\"thf-slide-circles\">\n  <ng-container *ngFor=\"let item of items; let index = index;\">\n    <div\n      class=\"thf-slide-circle\"\n      [class.thf-slide-active-circle]=\"index === currentSlideIndex\"\n      (click)=\"click.emit(index)\">\n    </div>\n  </ng-container>\n</div>\n"
            }] }
];
ThfSlideCirclesComponent.propDecorators = {
    currentSlideIndex: [{ type: Input, args: ['t-current-slide-index',] }],
    items: [{ type: Input, args: ['t-items',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfSlideIntervalDefault = 4000;
/**
 * \@description
 *
 * Componente de slide para visualização e controle de elementos de forma cíclica. Exibe um conjunto de imagens ou dados que permitem
 * customizar sua visualização utilizando a diretiva **[t-slide-content-template](/documentation/thf-slide-content-template)**.
 *
 * #### Boas práticas:
 * - Utilizar imagens no slide, mesmo quando possui conteúdo personalizado.
 * - Evitar utilizar apenas um slide isolado, utilize pelo menos dois.
 * - Evitar utilizar mais de 5 slides, pois a ideia do componente é destacar apenas informações importantes.
 * @abstract
 */
class ThfSlideBaseComponent {
    constructor() {
        this._interval = thfSlideIntervalDefault;
    }
    /**
     * \@optional
     *
     * \@description
     * Altura do thf-slide, caso seja slide com template customizado, não assume o valor `default`.
     *
     * \@default `336`
     * @param {?} value
     * @return {?}
     */
    set height(value) {
        this._height = convertToInt(value);
        this.setSlideHeight(this.height);
    }
    /**
     * @return {?}
     */
    get height() {
        return this._height;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Valor em milissegundos que define o tempo de troca dos slides, caso o valor seja menor que `1000` os slides não trocam automaticamente.
     *
     * \@default `4000`
     * @param {?} value
     * @return {?}
     */
    set interval(value) {
        this._interval = convertToInt(value, thfSlideIntervalDefault);
        this._interval >= 1000 ? this.startInterval() : this.cancelInterval();
    }
    /**
     * @return {?}
     */
    get interval() {
        return this._interval;
    }
    /**
     * \@description
     *
     * Array de imagens ou dados para o slide, pode ser de três formas:
     *
     * - Array implementando objetos da interface `ThfSlideItem`:
     * ```
     * [{ image: '/assets/image-1', action: 'imageClick.bind(this)'}, { image: '/assets/image-2' }]
     * ```
     * - Array de `strings` com os caminhos das imagens:
     * ```
     * ['/assets/image-1', '/assets/image-2' ]
     * ```
     * - Array com lista de itens (para utilizar template):
     * ```
     * [{ label: '1', img: '/assets/image-1' }, { label: '2', img: '/assets/image-1' }]
     * ```
     *
     * > As setas de navegação e o controle com círculos apenas serão renderizados caso possua mais de um slide.
     * @param {?} value
     * @return {?}
     */
    set slides(value) {
        this._slides = value;
        this.setSlideItems(value);
        if (value && value.length) {
            this.startSlide();
        }
    }
    /**
     * @return {?}
     */
    get slides() {
        return this._slides;
    }
}
ThfSlideBaseComponent.propDecorators = {
    height: [{ type: Input, args: ['t-height',] }],
    interval: [{ type: Input, args: ['t-interval',] }],
    slides: [{ type: Input, args: ['t-slides',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfSlideComponent
 *
 * \@description
 *
 * Esta diretiva permite a customização de um slide.
 *
 * Deve-se utilizar como parâmetro a referência do item e/ou índice, sendo por padrão o item.
 *  - Item: `item` determina o item do slide corrente.
 *  - Índice: `index` determina o índice do slide corrente.
 *
 * Esta diretiva pode ser usada de duas formas: explícita ou *syntax sugar*. Veja a seguir ambos, respectivamente:
 *
 * ```
 * ...
 * <thf-slide
 *   [t-slides]="[{ id: 1, name: 'Register', email: 'register\@totvs.com' }]">
 *
 *   <ng-template t-slide-content-template let-item let-code="index">
 *     <div class="thf-row">
 *       <thf-info class="thf-md-6" t-label="Code" [t-value]="item.id"></thf-info>
 *       <thf-info class="thf-md-6" t-label="Email" [t-value]="item.email"></thf-info>
 *     </div>
 *   </ng-template>
 *
 * </thf-slide>
 *
 * ...
 * ```
 *
 * ```
 * ...
 * <thf-slide
 *    [t-slides]="[{ id: 1, name: 'Register', email: 'register\@totvs.com' }]">
 *
 *    <div *t-slide-content-template="let item, let i=index" class="thf-row">
 *      <thf-info class="thf-md-12" t-label="Email" [t-value]="item.email"></thf-info>
 *    </div>
 * </thf-slide>
 * ...
 *
 * ```
 */
class ThfSlideContentTemplateDirective {
    // Necessário manter templateRef para o funcionamento do row template.
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ThfSlideContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[t-slide-content-template]'
            },] }
];
/** @nocollapse */
ThfSlideContentTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para cada item do thf-slide.
 */
class ThfSlideItemComponent {
    constructor() {
        this.isIEOrEdge = isIEOrEdge();
    }
    /**
     * @return {?}
     */
    setLinkType() {
        if (!this.template && this.link) {
            return this.link.startsWith('http') ? 'externalLink' : 'internalLink';
        }
        return 'noLink';
    }
}
ThfSlideItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-slide-item',
                template: "<div #slideItem\n  class=\"thf-slide-item\"\n  [class.thf-slide-item-background-image]=\"!template && isIEOrEdge\"\n  [style.background-image]=\"!template && isIEOrEdge ? 'url(' + image + ')' : ''\"\n  [ngSwitch]=\"setLinkType()\">\n\n  <!-- slide com link interno -->\n  <a\n    *ngSwitchCase=\"'internalLink'\" \n    class=\"thf-slide-item-link\" \n    [routerLink]=\"link\">\n    <ng-container \n      [ngTemplateOutlet]=\"slideItemImage\" \n      [ngTemplateOutletContext]=\"{ item: { alt: alt, image: image }}\">\n    </ng-container>\n  </a>\n  <!-- slide com link externo -->\n  <a \n    *ngSwitchCase=\"'externalLink'\"\n    class=\"thf-slide-item-link\" \n    [href]=\"link\">\n    <ng-container \n      [ngTemplateOutlet]=\"slideItemImage\" \n      [ngTemplateOutletContext]=\"{ item: { alt: alt, image: image }}\">\n    </ng-container>\n  </a>\n  <!-- slide sem link -->\n  <a \n    *ngSwitchCase=\"'noLink'\"\n    [ngClass]=\"action ? 'thf-slide-item-link' : 'thf-slide-item-no-link'\"\n    (click)=\"action ? action(data) : undefined\">\n    <ng-container \n      [ngTemplateOutlet]=\"template ? slideItemTemplate : slideItemImage\"\n      [ngTemplateOutletContext]=\"{ item: { alt: alt, image: image, data: data }}\">\n    </ng-container>\n  </a>\n\n</div>\n\n<ng-template #slideItemTemplate let-item='item'>\n  <div\n    *ngIf=\"template\"\n    class=\"thf-slide-item-content\">\n    <ng-template\n      [ngTemplateOutlet]=\"template.templateRef\"\n      [ngTemplateOutletContext]=\"{ $implicit: item.data, index: index }\">\n    </ng-template>\n  </div>\n</ng-template>\n\n<ng-template #slideItemImage let-item='item'>\n  <img\n    *ngIf=\"item.image && !isIEOrEdge\"\n    class=\"thf-slide-image\"\n    [alt]=\"item.alt\"\n    [src]=\"item.image\"\n    [style.height.px]=\"imageHeight\">\n</ng-template>\n"
            }] }
];
ThfSlideItemComponent.propDecorators = {
    itemElement: [{ type: ViewChild, args: ['slideItem', { static: true },] }],
    action: [{ type: Input, args: ['t-action',] }],
    alt: [{ type: Input, args: ['t-alt',] }],
    data: [{ type: Input, args: ['t-data',] }],
    image: [{ type: Input, args: ['t-image',] }],
    imageHeight: [{ type: Input, args: ['t-image-height',] }],
    template: [{ type: Input, args: ['t-template',] }],
    link: [{ type: Input, args: ['t-link',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfSlideDefaultHeight = 336;
/** @type {?} */
const thfSlideIntervalMin = 1000;
/** @type {?} */
const thfSlideMinHeight = 192;
/** @type {?} */
const thfSlideTiming = '250ms ease';
/**
 * \@docsExtends ThfSlideBaseComponent
 *
 * \@example
 * <example name="thf-slide-basic" title="Totvs Slide Basic">
 *   <file name="sample-thf-slide-basic/sample-thf-slide-basic.component.html"> </file>
 *   <file name="sample-thf-slide-basic/sample-thf-slide-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-slide-labs" title="Totvs Slide Labs">
 *   <file name="sample-thf-slide-labs/sample-thf-slide-labs.component.html"> </file>
 *   <file name="sample-thf-slide-labs/sample-thf-slide-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-slide-useful-articles" title="Totvs Slide - Useful articles">
 *   <file name="sample-thf-slide-useful-articles/sample-thf-slide-useful-articles.component.html"> </file>
 *   <file name="sample-thf-slide-useful-articles/sample-thf-slide-useful-articles.component.ts"> </file>
 * </example>
 *
 * <example name="thf-slide-landscapes" title="Totvs Slide - Landscapes">
 *   <file name="sample-thf-slide-landscapes/sample-thf-slide-landscapes.component.html"> </file>
 *   <file name="sample-thf-slide-landscapes/sample-thf-slide-landscapes.component.ts"> </file>
 * </example>
 */
class ThfSlideComponent extends ThfSlideBaseComponent {
    /**
     * @param {?} builder
     */
    constructor(builder) {
        super();
        this.builder = builder;
        this.isLoaded = false;
        this.currentSlideIndex = 0;
        this.slideItems = [];
    }
    /**
     * @private
     * @return {?}
     */
    get hasElements() {
        return !!this.slide.nativeElement.offsetWidth && !!this.itemsElements && !!this.itemsElements.length;
    }
    /**
     * @private
     * @return {?}
     */
    get isImageSlide() {
        return !this.slideContentTemplate;
    }
    /**
     * @private
     * @return {?}
     */
    get offset() {
        return this.currentSlideIndex * this.slideItemWidth;
    }
    /**
     * @return {?}
     */
    get hasSlides() {
        return !!this.slides && !!this.slides.length;
    }
    /**
     * @return {?}
     */
    onResize() {
        if (this.slide) {
            this.setSlideItemWidth();
            this.goToItem(this.currentSlideIndex);
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (!this.isLoaded && this.hasElements) {
            this.setSlideItemWidth();
            this.isLoaded = true;
            if (this.hasSlides) {
                this.startSlide();
            }
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    goToItem(index) {
        if (this.interval > thfSlideIntervalMin) {
            this.startInterval();
        }
        this.currentSlideIndex = index;
        this.animate(this.offset);
    }
    /**
     * @return {?}
     */
    nextControl() {
        if (this.interval > thfSlideIntervalMin) {
            this.startInterval();
        }
        this.next();
    }
    /**
     * @return {?}
     */
    next() {
        if (this.currentSlideIndex + 1 === this.slideItems.length) {
            this.currentSlideIndex = 0;
            this.animate(0);
            return;
        }
        this.currentSlideIndex = (this.currentSlideIndex + 1) % this.slideItems.length;
        this.animate(this.offset);
    }
    /**
     * @return {?}
     */
    previous() {
        if (this.currentSlideIndex === 0) {
            this.currentSlideIndex = this.slideItems.length - 1;
            this.animate(this.offset);
            return;
        }
        this.currentSlideIndex = ((this.currentSlideIndex - 1) + this.slideItems.length) % this.slideItems.length;
        this.animate(this.offset);
    }
    /**
     * @return {?}
     */
    previousControl() {
        if (this.interval > thfSlideIntervalMin) {
            this.startInterval();
        }
        this.previous();
    }
    /**
     * @param {?} height
     * @return {?}
     */
    setSlideHeight(height) {
        this.setHeight(height);
    }
    /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    animate(offset) {
        if (this.hasElements) {
            /** @type {?} */
            const animation = this.buildTransitionAnimation(offset);
            this.player = animation.create(this.slide.nativeElement);
            this.player.play();
        }
    }
    /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    buildTransitionAnimation(offset) {
        return this.builder.build([
            animate(thfSlideTiming, keyframes([style({ transform: `translateX(-${offset}px)` })]))
        ]);
    }
    /**
     * @private
     * @param {?} slides
     * @return {?}
     */
    createArrayForTemplate(slides) {
        this.slideItems = [...slides];
    }
    /**
     * @private
     * @param {?} slides
     * @return {?}
     */
    createArrayFromSlides(slides) {
        /** @type {?} */
        const isStringArray = slides.every((/**
         * @param {?} item
         * @return {?}
         */
        item => typeof item === 'string'));
        if (isStringArray) {
            slides.forEach((/**
             * @param {?} element
             * @return {?}
             */
            element => this.slideItems.push({ image: `${element}` })));
        }
        else {
            this.slideItems = [...(/** @type {?} */ (slides))];
        }
    }
    /**
     * @private
     * @param {?} height
     * @return {?}
     */
    setDefaultHeight(height) {
        if (height && height <= thfSlideMinHeight || !height && this.isImageSlide) {
            this.slide.nativeElement.style.height = `${thfSlideDefaultHeight}px`;
            this.imageHeight = thfSlideDefaultHeight;
        }
        else {
            this.imageHeight = undefined;
        }
    }
    /**
     * @private
     * @param {?} height
     * @return {?}
     */
    setHeight(height) {
        if (height && height > thfSlideMinHeight) {
            this.slide.nativeElement.style.height = `${height}px`;
            this.imageHeight = height;
        }
        else {
            this.setDefaultHeight(height);
        }
    }
    /**
     * @private
     * @return {?}
     */
    setSlideItemWidth() {
        if (this.hasElements) {
            this.slideItemWidth = this.itemsElements.first.itemElement.nativeElement.getBoundingClientRect().width;
        }
    }
    /**
     * @protected
     * @return {?}
     */
    cancelInterval() {
        clearInterval(this.setInterval);
    }
    /**
     * @protected
     * @param {?} slides
     * @return {?}
     */
    setSlideItems(slides) {
        if (this.hasSlides) {
            this.slideContentTemplate ? this.createArrayForTemplate(slides) : this.createArrayFromSlides(slides);
        }
        else {
            this.slideItems = [];
            this.cancelInterval();
        }
    }
    /**
     * @protected
     * @return {?}
     */
    startSlide() {
        this.setSlideHeight(this.height);
        if (this.interval > thfSlideIntervalMin) {
            this.startInterval();
        }
        this.currentSlideIndex = 0;
    }
    /**
     * @protected
     * @return {?}
     */
    startInterval() {
        if (this.setInterval) {
            this.cancelInterval();
        }
        this.setInterval = this.hasSlides && this.hasElements ? setInterval((/**
         * @return {?}
         */
        () => { this.next(); }), this.interval) : undefined;
    }
}
ThfSlideComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-slide',
                template: "<div class=\"thf-slide-wrapper\">\n  <div class=\"thf-slide-outer\">\n    <div class=\"thf-slide-inner\" #slide>\n      <ng-container *ngFor=\"let item of slideItems; let index = index;\">\n        <thf-slide-item\n          [t-action]=\"item.action\"\n          [t-data]=\"item\"\n          [t-image]=\"item.image\"\n          [t-image-height]=\"imageHeight\"\n          [t-template]=\"slideContentTemplate\"\n          [t-alt]=\"item.alt\"\n          [t-link]=\"item.link\">\n        </thf-slide-item>\n      </ng-container>\n    </div>\n\n    <thf-slide-control *ngIf=\"hasSlides && slides.length > 1\" \n      t-control=\"previous\"\n      (t-click)=\"previousControl()\">\n    </thf-slide-control>\n\n    <thf-slide-control *ngIf=\"hasSlides && slides.length > 1\"\n      t-control=\"next\"\n      (t-click)=\"nextControl()\">\n    </thf-slide-control>\n\n  </div>\n\n  <thf-slide-circles\n    *ngIf=\"hasSlides && slides.length > 1\"\n    [t-current-slide-index]=\"currentSlideIndex\"\n    [t-items]=\"slideItems\"\n    (t-click)=\"goToItem($event)\">\n  </thf-slide-circles>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfSlideComponent.ctorParameters = () => [
    { type: AnimationBuilder }
];
ThfSlideComponent.propDecorators = {
    slideContentTemplate: [{ type: ContentChild, args: [ThfSlideContentTemplateDirective, { static: true },] }],
    slide: [{ type: ViewChild, args: ['slide', { static: true },] }],
    itemsElements: [{ type: ViewChildren, args: [ThfSlideItemComponent,] }],
    onResize: [{ type: HostListener, args: ['window:resize',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a seta que controla a passagem de itens do `thf-slide`.
 */
class ThfSlideControlComponent {
    constructor() {
        /**
         * Evento emitido ao clicar em um controle.
         */
        this.click = new EventEmitter();
    }
}
ThfSlideControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-slide-control',
                template: "<div class=\"thf-slide-control-{{control}}\">\n  <div class=\"thf-slide-arrow-circle\" (click)=\"click.emit();\">\n    <div class=\"thf-slide-arrow thf-slide-arrow-{{control}}\"></div>\n  </div>\n</div>\n"
            }] }
];
ThfSlideControlComponent.propDecorators = {
    control: [{ type: Input, args: ['t-control',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente `thf-slide`.
 *
 * > Para o correto funcionamento do componente `thf-slide`, deve ser importado o módulo `BrowserAnimationsModule` no
 * > módulo principal da sua aplicação.
 *
 * Módulo da aplicação:
 * ```
 * import { BrowserAnimationsModule } from '\@angular/platform-browser/animations';
 * import { ThfModule } from '\@totvs/thf-ui';
 * ...
 *
 * \@NgModule({
 *   imports: [
 *     BrowserModule,
 *     BrowserAnimationsModule,
 *     ...
 *     ThfModule
 *   ],
 *   declarations: [
 *     AppComponent,
 *     ...
 *   ],
 *   providers: [],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule { }
 * ```
 */
class ThfSlideModule {
}
ThfSlideModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    ThfContainerModule
                ],
                declarations: [
                    ThfSlideCirclesComponent,
                    ThfSlideComponent,
                    ThfSlideControlComponent,
                    ThfSlideContentTemplateDirective,
                    ThfSlideItemComponent,
                ],
                exports: [
                    ThfSlideComponent,
                    ThfSlideContentTemplateDirective
                ],
                providers: [],
                schemas: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfStepperStatus = {
    /** Define o estado do *step* como ativo. */
    Active: 'active',
    /** Define o estado do *step* como padrão. */
    Default: 'default',
    /** Define o estado do *step* como desabilitado. */
    Disabled: 'disabled',
    /** Define o estado do *step* como concluído. */
    Done: 'done',
    /** Define o estado do *step* com erro. */
    Error: 'error',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-step` é utilizado para envolver e renderizar o conteúdo de um passo (*step*) do `thf-stepper`, por exemplo:
 *
 * ```
 * <thf-stepper>
 *
 *    <thf-step t-label="Endereço">
 *
 *        <!-- Conteúdo referente ao endereço -->
 *
 *    </thf-step>
 *
 *    <thf-step t-label="Pagamento">
 *
 *        <!-- Conteúdo referente ao pagamento -->
 *
 *    </thf-step>
 *
 *  </thf-stepper>
 * ```
 *
 * A renderização do conteúdo envolvido na tela e o controle dos status são feitos automaticamente. No qual, o primeiro
 * `thf-step` encontrado será colocado como ativo, o próximo fica com o status *default* e os demais ficam
 * desabilitados (*disabled*).
 *
 * Ao clicar no `thf-step` que está com o status *default*, o que está ativo ficará com o
 * status de concluído (*done*) e o próximo que estava desabilitado ficará com o status *default* e o restante permanecerá
 * com o status desabilitado.
 *
 * > Ao utilizar o `thf-step`, o componente `thf-stepper` funcionará de forma sequencial, ou seja, não será possível
 * pular para outro `thf-step` que esteja com o status igual a desabilitado (*disabled*).
 *
 * Acesse a [documentação do `thf-stepper`](/documentation/thf-stepper) para ter mais informações sobre o seu funcionamento
 * e exemplos de uso.
 */
class ThfStepComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._status = ThfStepperStatus.Disabled;
        // ID do step
        this.id = uuid();
    }
    // Estado de exibição do `thf-step`.
    /**
     * @param {?} status
     * @return {?}
     */
    set status(status) {
        this._status = status;
        this.setDisplayOnActiveOrError();
    }
    /**
     * @return {?}
     */
    get status() {
        return this._status;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setDisplayOnActiveOrError();
    }
    /**
     * @protected
     * @return {?}
     */
    setDisplayOnActiveOrError() {
        this.elementRef.nativeElement.style.display =
            (this.status === ThfStepperStatus.Active || this.status === ThfStepperStatus.Error) ? '' : 'none';
    }
}
ThfStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-step',
                template: "<ng-content></ng-content>\n"
            }] }
];
/** @nocollapse */
ThfStepComponent.ctorParameters = () => [
    { type: ElementRef }
];
ThfStepComponent.propDecorators = {
    canActiveNextStep: [{ type: Input, args: ['t-can-active-next-step',] }],
    label: [{ type: Input, args: ['t-label',] }],
    status: [{ type: Input, args: ['t-status',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfMediumStepSize = 32;
/** @type {?} */
const thfLargeStepSize = 48;
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por exibir os círculos dos *steps*.
 */
class ThfStepperCircleComponent {
    /**
     * @return {?}
     */
    get isActive() {
        return this.status === ThfStepperStatus.Active;
    }
    /**
     * @return {?}
     */
    get isDefault() {
        return this.status === ThfStepperStatus.Default;
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.status === ThfStepperStatus.Disabled;
    }
    /**
     * @return {?}
     */
    get isDone() {
        return this.status === ThfStepperStatus.Done;
    }
    /**
     * @return {?}
     */
    get isError() {
        return this.status === ThfStepperStatus.Error;
    }
    /**
     * @return {?}
     */
    get isLargeStep() {
        return this.size >= thfLargeStepSize;
    }
    /**
     * @return {?}
     */
    get isMediumStep() {
        return this.size >= thfMediumStepSize && !this.isLargeStep;
    }
}
ThfStepperCircleComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-stepper-circle',
                template: "<div class=\"thf-stepper-circle\"\n  [class.thf-stepper-circle-with-icon]=\"icons\"\n  [style.height.px]=\"size\"\n  [style.width.px]=\"size\"\n  [tabindex]=\"isDisabled ? -1 : 0\">\n\n  <span class=\"thf-stepper-circle-content\"\n    [class.thf-icon]=\"icons\"\n    [class.thf-icon-exclamation]=\"icons && isError\"\n    [class.thf-icon-info]=\"icons && (isActive || isDefault || isDisabled)\"\n    [class.thf-icon-ok]=\"icons && isDone\"\n    [class.thf-stepper-circle-content-lg]=\"isLargeStep\"\n    [class.thf-stepper-circle-content-md]=\"isMediumStep\">\n\n    {{ !icons ? content: '' }}\n  </span>\n</div>\n"
            }] }
];
ThfStepperCircleComponent.propDecorators = {
    content: [{ type: Input, args: ['t-content',] }],
    icons: [{ type: Input, args: ['t-icons',] }],
    size: [{ type: Input, args: ['t-size',] }],
    status: [{ type: Input, args: ['t-status',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ThfStepperOrientation = {
    /** Define a exibição do componente na horizontal. */
    Horizontal: 'horizontal',
    /** Define a exibição do componente na vertical. */
    Vertical: 'vertical',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfStepperOrientationDefault = ThfStepperOrientation.Horizontal;
/**
 * \@description
 *
 * O `thf-stepper` permite que um processo seja dividido em passos para que o usuário o realize
 * mais facilmente.
 *
 * Existem duas formas de utilização:
 *
 * 1 - Usando o componente [**thf-step**](/documentation/thf-step) para renderizar e descrever os passos.
 *
 * 2 - Através da propriedade `t-steps` para descrever os passos do processo, sendo responsabilidade do desenvolvedor o controle
 * de renderização do que será exibido a cada *step* ativo.
 *
 * Através de suas propriedades, é possível definir se sua orientação será horizontal ou vertical,
 * além da possibilidade de aumentar o tamanho dos *steps*.
 *
 * Também é possível navegar entre os *steps* através do teclado utilizando a tecla *tab* e, para ativar o *step* em foco basta
 * pressionar a tecla *enter*. Além disso, é possível ativar a exibição de ícones no lugar de números nos *steps* através da
 * propriedade [`t-step-icons`](/documentation/thf-stepper#stepIconsProperty).
 *
 * #### Utilizando os métodos do componente:
 *
 * Para acessar os métodos do componente é necessário ter a referência do mesmo.
 *
 * Por exemplo, utilizando um [**ViewChild**](https://angular.io/api/core/ViewChild):
 *
 * ```
 * \@ViewChild(ThfStepperComponent) thfStepperComponent: ThfStepperComponent;
 * ```
 *
 * E para acessar o método:
 *
 * ```
 * thfStepperComponent.next();
 * ```
 *
 * #### Boas práticas
 *
 * - Evite `labels` extensos que quebram o layout do `thf-stepper`, use `labels` diretos, curtos e intuitivos.
 * - Utilize apenas um `thf-stepper` por página.
 */
class ThfStepperBaseComponent {
    constructor() {
        this._orientation = thfStepperOrientationDefault;
        this._sequential = true;
        this._step = 1;
        this._steps = [];
        /**
         * Ação que será executada quando o usuário mudar o passo do `thf-stepper`.
         */
        this.onChangeStep = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a orientação de exibição do `thf-stepper`.
     *
     * > Veja os valores válidos no *enum* [ThfStepperOrientation](documentation/thf-stepper#stepperOrientation).
     *
     * \@default `ThfStepperOrientation.Horizontal`
     * @param {?} value
     * @return {?}
     */
    set orientation(value) {
        this._orientation = ((/** @type {?} */ (Object))).values(ThfStepperOrientation).includes(value) ? value : thfStepperOrientationDefault;
    }
    /**
     * @return {?}
     */
    get orientation() {
        return this._orientation;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Controla o passo atual do `thf-stepper`.
     *
     * > Ao utilizar esta propriedade e também utilizar o componente [**thf-step**](/documentation/thf-step),
     * o valor desta propriedade será ignorada permanecendo a definição do [**thf-step**](/documentation/thf-step).
     *
     * \@default `1`
     * @param {?} step
     * @return {?}
     */
    set step(step) {
        if (step >= 1 && step <= this.steps.length) {
            this._step = step;
            this._steps[this._step - 1].status = ThfStepperStatus.Active;
        }
    }
    /**
     * @return {?}
     */
    get step() {
        return this._step;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Lista dos itens do stepper. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio.
     *
     * > Ao utilizar esta propriedade e também utilizar o componente [**thf-step**](/documentation/thf-step),
     * o valor desta propriedade será ignorada permanecendo a definição do [**thf-step**](/documentation/thf-step).
     * @param {?} steps
     * @return {?}
     */
    set steps(steps) {
        this._steps = Array.isArray(steps) ? steps : [];
        this._steps.forEach((/**
         * @param {?} step
         * @return {?}
         */
        step => step.status = ThfStepperStatus.Default));
        this.step = 1;
    }
    /**
     * @return {?}
     */
    get steps() {
        return this._steps;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define se o `thf-stepper` será sequencial ou aleatório.
     *
     * > Ao utilizar o componente [**thf-step**](/documentation/thf-step), o valor desta propriedade sempre será verdadeiro.
     *
     * \@default `true`
     * @param {?} sequential
     * @return {?}
     */
    set sequential(sequential) {
        this._sequential = convertToBoolean(sequential);
    }
    /**
     * @return {?}
     */
    get sequential() {
        return this._sequential;
    }
}
ThfStepperBaseComponent.propDecorators = {
    orientation: [{ type: Input, args: ['t-orientation',] }],
    step: [{ type: Input, args: ['t-step',] }],
    steps: [{ type: Input, args: ['t-steps',] }],
    stepIcons: [{ type: Input, args: ['t-step-icons',] }],
    stepSize: [{ type: Input, args: ['t-step-size',] }],
    sequential: [{ type: Input, args: ['t-sequential',] }],
    onChangeStep: [{ type: Output, args: ['t-change-step',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfStepperBaseComponent
 *
 * \@example
 *
 * <example name="thf-stepper-basic" title="Totvs Stepper Basic">
 *  <file name="sample-thf-stepper-basic/sample-thf-stepper-basic.component.html"> </file>
 *  <file name="sample-thf-stepper-basic/sample-thf-stepper-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-stepper-labs" title="Totvs Stepper Labs">
 *  <file name="sample-thf-stepper-labs/sample-thf-stepper-labs.component.html"> </file>
 *  <file name="sample-thf-stepper-labs/sample-thf-stepper-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-stepper-sales" title="Totvs Stepper - Sales">
 *  <file name="sample-thf-stepper-sales/sample-thf-stepper-sales.component.html"> </file>
 *  <file name="sample-thf-stepper-sales/sample-thf-stepper-sales.component.ts"> </file>
 * </example>
 */
class ThfStepperComponent extends ThfStepperBaseComponent {
    /**
     * @param {?} changeDetector
     */
    constructor(changeDetector) {
        super();
        this.changeDetector = changeDetector;
    }
    /**
     * @return {?}
     */
    get currentStepIndex() {
        return this.step - 1;
    }
    /**
     * @return {?}
     */
    get stepList() {
        return this.useThfSteps && this.thfSteps || this.steps;
    }
    /**
     * @return {?}
     */
    get useThfSteps() {
        return !!this.thfSteps.length;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.activeFirstStep();
        this.thfSteps.changes.subscribe((/**
         * @return {?}
         */
        () => {
            this.controlStepsStatus(0, this.thfSteps.first);
        }));
    }
    /**
     * Altera o status do *step* para ativo.
     *
     * > Este método é valido apenas para as implementações que utilizam o componente [**thf-step**](/documentation/thf-step).
     *
     * @param {?} index {number} Índice do `thf-step` que se deseja ativar.
     * @return {?}
     */
    active(index) {
        if (!this.useThfSteps) {
            return;
        }
        /** @type {?} */
        const stepsArray = this.getThfSteps();
        /** @type {?} */
        const step = stepsArray[index];
        /** @type {?} */
        const isDisabledStep = step.status === ThfStepperStatus.Disabled;
        /** @type {?} */
        const isErrorStep = step.status === ThfStepperStatus.Error;
        if (!isDisabledStep || isErrorStep) {
            this.changeStep(index, step);
        }
    }
    /**
     * Ativa o primeiro *step*.
     *
     * > Este método é valido apenas para as implementações que utilizam o componente [**thf-step**](/documentation/thf-step).
     * @return {?}
     */
    first() {
        if (!this.useThfSteps) {
            return;
        }
        /** @type {?} */
        const firstStep = this.thfSteps.first;
        /** @type {?} */
        const firstStepIndex = 0;
        this.changeStep(firstStepIndex, firstStep);
    }
    /**
     * Ativa o próximo *step*.
     *
     * > Este método é valido apenas para as implementações que utilizam o componente [**thf-step**](/documentation/thf-step).
     * @return {?}
     */
    next() {
        if (!this.useThfSteps) {
            return;
        }
        const { steps, stepIndex } = this.getStepsAndIndex(this.currentActiveStep);
        /** @type {?} */
        const nextIndex = stepIndex + 1;
        /** @type {?} */
        const nextStep = steps[nextIndex];
        this.changeStep(nextIndex, nextStep);
    }
    /**
     * Ativa o *step* anterior.
     *
     * > Este método é valido apenas para as implementações que utilizam o componente [**thf-step**](/documentation/thf-step).
     * @return {?}
     */
    previous() {
        if (!this.useThfSteps) {
            return;
        }
        const { steps, stepIndex } = this.getStepsAndIndex(this.currentActiveStep);
        /** @type {?} */
        const previousIndex = stepIndex - 1;
        /** @type {?} */
        const previousStep = steps[previousIndex];
        this.changeStep(previousIndex, previousStep);
    }
    /**
     * @param {?} stepIndex
     * @param {?=} step
     * @return {?}
     */
    changeStep(stepIndex, step) {
        /** @type {?} */
        const isDifferentStep = (!this.currentActiveStep || step.id !== this.currentActiveStep.id);
        if (this.useThfSteps && isDifferentStep && this.allowNextStep(stepIndex)) {
            this.controlStepsStatus(stepIndex, step);
            this.onChangeStep.emit(step);
        }
        else if (!this.useThfSteps && stepIndex !== this.currentStepIndex && this.allowNextStep(stepIndex)) {
            // if para tratamento do modelo antigo do thf-stepper
            this.onChangeStep.emit(stepIndex + 1);
        }
    }
    /**
     * @param {?} step
     * @return {?}
     */
    onStepActive(step) {
        this.currentActiveStep = step;
        this.previousActiveStep = this.thfSteps.find((/**
         * @param {?} stepChild
         * @return {?}
         */
        stepChild => stepChild.status === ThfStepperStatus.Active && stepChild.id !== step.id));
        this.setPreviousStepAsDone();
    }
    /**
     * @param {?} step
     * @return {?}
     */
    trackByFn(step) {
        return step.id;
    }
    /**
     * @private
     * @return {?}
     */
    activeFirstStep() {
        /** @type {?} */
        const hasStepActive = this.thfSteps.some((/**
         * @param {?} thfStep
         * @return {?}
         */
        thfStep => thfStep.status === ThfStepperStatus.Active));
        if (this.useThfSteps && !hasStepActive) {
            this.changeStep(0, this.thfSteps.first);
        }
    }
    /**
     * @private
     * @param {?} nextStepIndex
     * @return {?}
     */
    allowNextStep(nextStepIndex) {
        if (!this.sequential) {
            return true;
        }
        if (this.useThfSteps) {
            return this.isBeforeStep(nextStepIndex) || this.canActiveNextStep(this.currentActiveStep);
        }
        return this.steps.slice(this.step, nextStepIndex).every((/**
         * @param {?} step
         * @return {?}
         */
        step => step.status === ThfStepperStatus.Done));
    }
    /**
     * @private
     * @param {?=} currentActiveStep
     * @return {?}
     */
    canActiveNextStep(currentActiveStep = (/** @type {?} */ ({}))) {
        if (!currentActiveStep.canActiveNextStep) {
            return true;
        }
        /** @type {?} */
        const canActiveNextStep = currentActiveStep.canActiveNextStep(currentActiveStep);
        currentActiveStep.status = this.getStepperStatusByCanActive(canActiveNextStep);
        return canActiveNextStep;
    }
    /**
     * @private
     * @param {?} stepIndex
     * @param {?} step
     * @return {?}
     */
    controlStepsStatus(stepIndex, step) {
        if (this.useThfSteps) {
            this.setStepAsActive(step);
            this.setNextStepAsDefault(step);
            if (this.isBeforeStep(stepIndex)) {
                this.setFinalSteppersAsDisabled(stepIndex);
            }
            this.changeDetector.detectChanges();
        }
    }
    /**
     * @private
     * @param {?} canActiveNextStep
     * @return {?}
     */
    getStepperStatusByCanActive(canActiveNextStep) {
        return canActiveNextStep ? ThfStepperStatus.Done : ThfStepperStatus.Error;
    }
    /**
     * @private
     * @param {?=} step
     * @return {?}
     */
    getStepsAndIndex(step = (/** @type {?} */ ({}))) {
        /** @type {?} */
        const steps = this.getThfSteps();
        /** @type {?} */
        const stepIndex = steps.findIndex((/**
         * @param {?} thfStep
         * @return {?}
         */
        thfStep => thfStep.id === step.id));
        return { steps, stepIndex };
    }
    /**
     * @private
     * @return {?}
     */
    getThfSteps() {
        return this.thfSteps.toArray();
    }
    /**
     * @private
     * @param {?} stepIndex
     * @return {?}
     */
    isBeforeStep(stepIndex) {
        /** @type {?} */
        const currentActiveStepIndex = (/**
         * @return {?}
         */
        () => this.getThfSteps().findIndex((/**
         * @param {?} step
         * @return {?}
         */
        step => step.id === this.currentActiveStep.id)));
        return !!this.currentActiveStep && currentActiveStepIndex() >= stepIndex;
    }
    /**
     * @private
     * @param {?} stepIndex
     * @return {?}
     */
    setFinalSteppersAsDisabled(stepIndex) {
        this.getThfSteps()
            .filter((/**
         * @param {?} step
         * @param {?} index
         * @return {?}
         */
        (step, index) => step && index >= stepIndex + 2))
            .forEach((/**
         * @param {?} step
         * @return {?}
         */
        step => step.status = ThfStepperStatus.Disabled));
    }
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    setStepAsActive(step) {
        step.status = ThfStepperStatus.Active;
    }
    /**
     * @private
     * @param {?} currentStep
     * @return {?}
     */
    setNextStepAsDefault(currentStep) {
        const { steps, stepIndex } = this.getStepsAndIndex(currentStep);
        /** @type {?} */
        const nextIndex = stepIndex + 1;
        if (nextIndex < this.thfSteps.length) {
            steps[nextIndex].status = ThfStepperStatus.Default;
        }
    }
    /**
     * @private
     * @return {?}
     */
    setPreviousStepAsDone() {
        if (this.previousActiveStep) {
            this.previousActiveStep.status = ThfStepperStatus.Done;
        }
    }
}
ThfStepperComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-stepper',
                template: "<div class=\"thf-stepper thf-stepper-{{ orientation }}\">\n\n  <div class=\"thf-stepper-container\">\n    <thf-stepper-step *ngFor=\"let step of stepList; let index = index; trackBy: trackByFn\"\n      class=\"thf-stepper-step-position\"\n      [t-circle-content]=\"index+1\"\n      [t-label]=\"step.label\"\n      [t-orientation]=\"orientation\"\n      [t-status]=\"step.status\"\n      [t-step-icons]=\"stepIcons\"\n      [t-step-size]=\"stepSize\"\n      (t-activated)=\"onStepActive(step)\"\n      (t-click)=\"changeStep(index, step)\"\n      (t-enter)=\"changeStep(index, step)\">\n    </thf-stepper-step>\n  </div>\n\n  <div *ngIf=\"useThfSteps\" class=\"thf-stepper-content\">\n    <ng-content></ng-content>\n  </div>\n\n</div>\n"
            }] }
];
/** @nocollapse */
ThfStepperComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
ThfStepperComponent.propDecorators = {
    thfSteps: [{ type: ContentChildren, args: [ThfStepComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por exibir as legendas dos *steps*.
 */
class ThfStepperLabelComponent {
}
ThfStepperLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-stepper-label',
                template: "<div class=\"thf-stepper-label\">\n  {{ content }}\n</div>\n"
            }] }
];
ThfStepperLabelComponent.propDecorators = {
    content: [{ type: Input, args: ['t-content',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfStepperStepSizeDefault = 24;
/** @type {?} */
const thfStepperStepSizeMax = 64;
/** @type {?} */
const thfStepLiteralsDefault = {
    en: { label: 'Step' },
    es: { label: 'Paso' },
    pt: { label: 'Passo' }
};
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que representa um *step* contendo as ligações das laterais (`thf-stepper-step-bar`) e a label.
 */
class ThfStepperStepComponent {
    constructor() {
        this._stepIcons = false;
        this._stepSize = thfStepperStepSizeDefault;
        this.literals = Object.assign({}, thfStepLiteralsDefault[thfLocaleDefault], thfStepLiteralsDefault[browserLanguage()]);
        // Evento que será emitido quando o status do *step* estiver ativo (`ThfStepperStatus.Active`).
        this.activated = new EventEmitter();
        // Evento que será emitido ao clicar no *step*.
        this.click = new EventEmitter();
        // Evento que será emitido ao focar no *step* e pressionar a tecla *enter*.
        this.enter = new EventEmitter();
    }
    // Label do *step*.
    /**
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        this._label = isTypeof(value, 'string') ? value : `${this.literals.label} ${this.circleContent}`;
    }
    /**
     * @return {?}
     */
    get label() {
        return this._label;
    }
    // Define o estado de exibição.
    /**
     * @param {?} value
     * @return {?}
     */
    set status(value) {
        this._status = ((/** @type {?} */ (value))) ? value : undefined;
        if (this.status === ThfStepperStatus.Active) {
            this.activated.emit();
        }
    }
    /**
     * @return {?}
     */
    get status() {
        return this._status;
    }
    /**
     * @param {?} stepIcons
     * @return {?}
     */
    set stepIcons(stepIcons) {
        this._stepIcons = convertToBoolean(stepIcons);
    }
    /**
     * @return {?}
     */
    get stepIcons() {
        return this._stepIcons;
    }
    // Tamanho do `step` em *pixels*, possibilitando um maior destaque.
    // O valor informado deve ser entre `24` e `64`.
    /**
     * @param {?} value
     * @return {?}
     */
    set stepSize(value) {
        this._stepSize = (value >= thfStepperStepSizeDefault && value <= thfStepperStepSizeMax) ? value : thfStepperStepSizeDefault;
    }
    /**
     * @return {?}
     */
    get stepSize() {
        return this._stepSize;
    }
    /**
     * @return {?}
     */
    get halfStepSize() {
        return this.stepSize / 2;
    }
    /**
     * @return {?}
     */
    get isVerticalOrientation() {
        return this.orientation === ThfStepperOrientation.Vertical;
    }
    /**
     * @return {?}
     */
    get marginHorizontalBar() {
        return this.isVerticalOrientation ? undefined : this.halfStepSize;
    }
    /**
     * @param {?} status
     * @return {?}
     */
    getStatusClass(status) {
        switch (status) {
            case ThfStepperStatus.Active:
                return 'thf-stepper-step-active';
            case ThfStepperStatus.Disabled:
                return 'thf-stepper-step-disabled';
            case ThfStepperStatus.Done:
                return 'thf-stepper-step-done';
            case ThfStepperStatus.Error:
                return 'thf-stepper-step-error';
            default:
                return 'thf-stepper-step-default';
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.status !== ThfStepperStatus.Disabled) {
            this.click.emit();
        }
    }
    /**
     * @return {?}
     */
    onEnter() {
        if (this.status !== ThfStepperStatus.Disabled) {
            this.enter.emit();
        }
    }
}
ThfStepperStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-stepper-step',
                template: "<div class=\"thf-stepper-step\"\n  [ngClass]=\"getStatusClass(status)\"\n  (click)=\"onClick()\"\n  (keydown.enter)=\"onEnter()\">\n\n  <div class=\"thf-stepper-step-container\" [style.width.px]=\"isVerticalOrientation ? stepSize : undefined\">\n\n    <div\n      [class.thf-stepper-step-bar-top]=\"isVerticalOrientation\"\n      [class.thf-stepper-step-bar-left]=\"!isVerticalOrientation\"\n      [style.margin-right.px]=\"marginHorizontalBar\">\n    </div>\n\n    <thf-stepper-circle\n      [t-content]=\"circleContent\"\n      [t-icons]=\"stepIcons\"\n      [t-size]=\"stepSize\"\n      [t-status]=\"status\">\n    </thf-stepper-circle>\n\n    <div\n      [class.thf-stepper-step-bar-bottom]=\"isVerticalOrientation\"\n      [class.thf-stepper-step-bar-right]=\"!isVerticalOrientation\"\n      [style.margin-left.px]=\"marginHorizontalBar\">\n    </div>\n\n  </div>\n\n  <thf-stepper-label\n    class=\"thf-stepper-step-label-position\"\n    [t-content]=\"label\">\n  </thf-stepper-label>\n</div>\n"
            }] }
];
ThfStepperStepComponent.propDecorators = {
    circleContent: [{ type: Input, args: ['t-circle-content',] }],
    label: [{ type: Input, args: ['t-label',] }],
    orientation: [{ type: Input, args: ['t-orientation',] }],
    status: [{ type: Input, args: ['t-status',] }],
    stepIcons: [{ type: Input, args: ['t-step-icons',] }],
    stepSize: [{ type: Input, args: ['t-step-size',] }],
    activated: [{ type: Output, args: ['t-activated',] }],
    click: [{ type: Output, args: ['t-click',] }],
    enter: [{ type: Output, args: ['t-enter',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-stepper
 */
class ThfStepperModule {
}
ThfStepperModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    ThfStepComponent,
                    ThfStepperCircleComponent,
                    ThfStepperComponent,
                    ThfStepperLabelComponent,
                    ThfStepperStepComponent
                ],
                exports: [
                    ThfStepComponent,
                    ThfStepperComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por manipular os botões de aba.
 */
class ThfTabButtonComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        // Função sera emitida quando a tab ficar ativada
        this.activated = new EventEmitter();
        // Função sera emitida quando a tab ficar desabilitada ou escondida
        this.changeState = new EventEmitter();
        // Método recebido do usuário para ser disparado quando clicar na aba
        this.click = new EventEmitter();
    }
    // Ativa o botão
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        this._active = value;
        this.emitActivated();
    }
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    // Oculta o botão
    /**
     * @param {?} value
     * @return {?}
     */
    set hide(value) {
        this._hide = convertToBoolean(value);
        this.setDisplayOnHide();
    }
    /**
     * @return {?}
     */
    get hide() {
        return this._hide;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ((changes.hide && changes.hide.currentValue) || (changes.disabled && changes.disabled.currentValue)) {
            this.changeState.emit(this);
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.disabled) {
            this.click.emit(this.id);
        }
    }
    /**
     * @private
     * @return {?}
     */
    emitActivated() {
        if (this.active) {
            this.activated.emit(this);
        }
    }
    /**
     * @private
     * @return {?}
     */
    setDisplayOnHide() {
        this.elementRef.nativeElement.style.display = this.hide ? 'none' : '';
    }
}
ThfTabButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-tab-button',
                template: "<div\n  class=\"thf-tab-button-md\"\n  [attr.tabindex]=\"disabled ? null : 0\"\n  [class.thf-tab-button-active]=\"active\"\n  [class.thf-tab-button-disabled]=\"disabled\"\n  [class.thf-tab-button-sm]=\"small\"\n  (click)=\"onClick()\"\n  (keyup.enter)=\"onClick()\">\n\n  <span class=\"thf-tab-button-label\">\n    {{label}}\n  </span>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfTabButtonComponent.ctorParameters = () => [
    { type: ElementRef }
];
ThfTabButtonComponent.propDecorators = {
    active: [{ type: Input, args: ['t-active',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    hide: [{ type: Input, args: ['t-hide',] }],
    id: [{ type: Input, args: ['t-id',] }],
    label: [{ type: Input, args: ['t-label',] }],
    small: [{ type: Input, args: ['t-small',] }],
    activated: [{ type: Output, args: ['t-activated',] }],
    changeState: [{ type: Output, args: ['t-change-state',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-tab` renderiza uma aba na qual envolve um conteúdo HTML.
 *
 * Com este componente é possível atribuir um rótulo para auxiliar na identificação do conteúdo, ativar para que o mesmo seja exibido,
 * desabilitar para impossibilitar o acesso, bem como ocultar para indisponibilizar a aba.
 *
 * > Para controlar a navegação entre diversas abas, utilizar o componente [`thf-tabs`](/documentation/thf-tabs).
 * @abstract
 */
class ThfTabBaseComponent {
    constructor() {
        this._active = false;
        this._disabled = false;
        this._hide = false;
        // ID da aba
        this.id = uuid();
        /**
         * Método disparado ao clicar na aba.
         */
        this.click = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Ativa a aba exibindo seu conteúdo.
     *
     * > Sugere-se utilizar na aba de conteúdo inicial.
     *
     * \@default `false`
     * @param {?} active
     * @return {?}
     */
    set active(active) {
        this._active = convertToBoolean(active);
        this.setDisplayOnActive();
    }
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita a aba.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = convertToBoolean(disabled);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Oculta a aba.
     *
     * \@default `false`
     * @param {?} hide
     * @return {?}
     */
    set hide(hide) {
        this._hide = convertToBoolean(hide);
    }
    /**
     * @return {?}
     */
    get hide() {
        return this._hide;
    }
}
ThfTabBaseComponent.propDecorators = {
    active: [{ type: Input, args: ['t-active',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    hide: [{ type: Input, args: ['t-hide',] }],
    label: [{ type: Input, args: ['t-label',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfTabBaseComponent
 */
class ThfTabComponent extends ThfTabBaseComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        super();
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setDisplayOnActive();
    }
    /**
     * @protected
     * @return {?}
     */
    setDisplayOnActive() {
        this.elementRef.nativeElement.style.display = this.active ? '' : 'none';
    }
}
ThfTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-tab',
                template: "<ng-content></ng-content>\n"
            }] }
];
/** @nocollapse */
ThfTabComponent.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para agrupamento de componentes `thf-tab-button` que os rendereiza em uma um caixa de diálogo
 * no formato de lista.
 */
class ThfTabDropdownComponent {
    constructor() {
        // Lista de abas
        this.tabs = [];
        // Evento que será emitido ao ativar uma aba
        this.activated = new EventEmitter();
        // Evento que será emitido a aba for desabilitada ou ocultada
        this.changeState = new EventEmitter();
        // Evento de click
        this.click = new EventEmitter();
    }
    /**
     * @return {?}
     */
    getContainerClass() {
        return this.small ? 'thf-tab-dropdown-container-sm' : 'thf-tab-dropdown-container';
    }
    /**
     * @return {?}
     */
    togglePopover() {
        this.popover.isHidden ? this.popover.open() : this.popover.close();
    }
}
ThfTabDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-tab-dropdown',
                template: "<div #tabDrop\n  class=\"thf-tab-dropdown-content thf-tab-button-md\"\n  [attr.tabindex]=\"0\"\n  [class.thf-tab-button-sm]=\"small\"\n  (keyup.enter)=\"togglePopover()\">\n  <div class=\"thf-tab-button-label\">\n    {{ label }}\n    <span class=\"thf-icon\" [ngClass]=\"(popover.isHidden ? 'thf-icon-arrow-down' : 'thf-icon-arrow-up')\">\n    </span>\n  </div>\n</div>\n\n<thf-popover #popover\n  t-hide-arrow\n  t-position=\"bottom\"\n  [t-target]=\"tabDropdown\">\n\n  <div [ngClass]=\"getContainerClass()\">\n    <thf-tab-button *ngFor=\"let tab of tabs\"\n      class=\"thf-tab-dropdown-button\"\n      [class.thf-tab-dropdown-button-active]=\"tab.active\"\n      [t-active]=\"tab.active\"\n      [t-disabled]=\"tab.disabled\"\n      [t-hide]=\"tab.hide\"\n      [t-id]=\"tab.id\"\n      [t-label]=\"tab.label\"\n      [t-small]=\"small\"\n      (t-activated)=\"activated.emit(tab)\"\n      (t-change-state)=\"changeState.emit(tab)\"\n      (t-click)=\"popover.close();click.emit(tab);\">\n    </thf-tab-button>\n  </div>\n\n</thf-popover>\n"
            }] }
];
ThfTabDropdownComponent.propDecorators = {
    popover: [{ type: ViewChild, args: ['popover', { static: true },] }],
    tabDropdown: [{ type: ViewChild, args: ['tabDrop', { read: ElementRef, static: true },] }],
    label: [{ type: Input, args: ['t-label',] }],
    small: [{ type: Input, args: ['t-small',] }],
    tabs: [{ type: Input, args: ['t-tabs',] }],
    activated: [{ type: Output, args: ['t-activated',] }],
    changeState: [{ type: Output, args: ['t-change-state',] }],
    click: [{ type: Output, args: ['t-click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-tabs` é responsável por agrupar [abas](/documentation/thf-tab) dispostas numa linha horizontal,
 * ideal para facilitar a organização de conteúdos.
 *
 * Até cinco abas o componente exibe todas normalmente. Contudo, a partir de seis abas, o componente torna visível
 * apenas as quatro primeiras, agrupando todas as demais na quinta aba rotulada de **Mais**.
 *
 * > As abas que estiverem agrupadas serão dispostas numa cascata suspensa que será exibida ao clicar no botão **Mais**.
 *
 * É possível realizar a navegação entre as abas através da tecla TAB do teclado.
 * Caso uma aba estiver desabilitada, não receberá foco de navegação.
 *
 * #### Boas práticas
 *
 * - Evite utilizar uma quantidade excessiva de abas, pois irá gerar um *scroll* muito longo no `dropdown`;
 * - Evite `labels` extensos para as `tabs` pois podem quebrar seu *layout*, use `labels` diretos, curtos e intuitivos.
 */
class ThfTabsBaseComponent {
    constructor() {
        this._small = false;
    }
    /**
     * \@optinal
     *
     * \@description
     *
     * Diminui o tamanho das abas.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set small(value) {
        this._small = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get small() {
        return this._small;
    }
}
ThfTabsBaseComponent.propDecorators = {
    small: [{ type: Input, args: ['t-small',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfTabsMaxNumberOfTabs = 5;
/**
 * \@docsExtends ThfTabsBaseComponent
 *
 * \@example
 *
 * <example name="thf-tabs-basic" title="Totvs Tabs Basic">
 *  <file name="sample-thf-tabs-basic/sample-thf-tabs-basic.component.html"> </file>
 *  <file name="sample-thf-tabs-basic/sample-thf-tabs-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tabs-labs" title="Totvs Tabs Labs">
 *  <file name="sample-thf-tabs-labs/sample-thf-tabs-labs.component.html"> </file>
 *  <file name="sample-thf-tabs-labs/sample-thf-tabs-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tabs-travel" title="Totvs Tabs - Travel">
 *  <file name="sample-thf-tabs-travel/sample-thf-tabs-travel.component.html"> </file>
 *  <file name="sample-thf-tabs-travel/sample-thf-tabs-travel.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tabs-business-conf" title="Totvs Tabs - Business Conference">
 *  <file name="sample-thf-tabs-business-conf/sample-thf-tabs-business-conf.component.html"> </file>
 *  <file name="sample-thf-tabs-business-conf/sample-thf-tabs-business-conf.component.ts"> </file>
 * </example>
 */
class ThfTabsComponent extends ThfTabsBaseComponent {
    /**
     * @param {?} changeDetector
     */
    constructor(changeDetector) {
        super();
        this.changeDetector = changeDetector;
        this.maxNumberOfTabs = thfTabsMaxNumberOfTabs;
    }
    /**
     * @return {?}
     */
    get isShowTabDropdown() {
        return this.visibleTabs.length > this.maxNumberOfTabs;
    }
    // tabs que serão apresentadas na aba "Mais"
    /**
     * @return {?}
     */
    get overflowedTabs() {
        return this.visibleTabs.filter((/**
         * @param {?} _tab
         * @param {?} index
         * @return {?}
         */
        (_tab, index) => index > (this.maxNumberOfTabs - 2)));
    }
    /**
     * @return {?}
     */
    get visibleTabs() {
        return this.tabs.filter((/**
         * @param {?} tab
         * @return {?}
         */
        tab => !tab.hide));
    }
    /**
     * @return {?}
     */
    closePopover() {
        /** @type {?} */
        const containsPopoverVisible = this.tabDropdown && this.tabDropdown.popover && !this.tabDropdown.popover.isHidden;
        if (containsPopoverVisible) {
            this.tabDropdown.popover.close();
        }
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    isVisibleTab(tab) {
        /** @type {?} */
        const visibleTabIndex = this.visibleTabs.findIndex((/**
         * @param {?} visibleTab
         * @return {?}
         */
        visibleTab => visibleTab.id === tab.id));
        return (this.visibleTabs.length <= this.maxNumberOfTabs) || (visibleTabIndex < (this.maxNumberOfTabs - 1));
    }
    // Função disparada quando alguma tab ficar ativa
    /**
     * @param {?} tab
     * @return {?}
     */
    onTabActive(tab) {
        this.previousActiveTab = this.tabs.find((/**
         * @param {?} tabChild
         * @return {?}
         */
        tabChild => tabChild.active && tabChild.id !== tab.id));
        this.deactivateTab();
    }
    // funcao será disparada quando mudar o estado do thfTab para desabilitado ou escondido.
    /**
     * @param {?} tab
     * @return {?}
     */
    onTabChangeState(tab) {
        if (tab.active) {
            tab.active = false;
            this.activeDistinctTab();
            this.changeDetector.detectChanges();
        }
    }
    // selectiona a aba informada por parametro, caso houver click faz a emição do evento.
    /**
     * @param {?} tab
     * @return {?}
     */
    selectedTab(tab) {
        tab.active = true;
        if (tab.click) {
            tab.click.emit(tab);
        }
        this.changeDetector.detectChanges();
    }
    /**
     * @param {?} _i
     * @param {?} tab
     * @return {?}
     */
    trackByFn(_i, tab) {
        return tab.id;
    }
    // ativa a previousActiveTab ou primeira tab encontrada.
    /**
     * @private
     * @return {?}
     */
    activeDistinctTab() {
        if (this.previousActiveTab) {
            this.previousActiveTab.active = true;
        }
        else {
            this.activeFirstTab();
        }
    }
    // Ativa a primeira Tab que não estiver desabilitada ou escondida.
    /**
     * @private
     * @return {?}
     */
    activeFirstTab() {
        this.tabs.some((/**
         * @param {?} tabChild
         * @return {?}
         */
        tabChild => {
            if (!tabChild.disabled && !tabChild.hide) {
                tabChild.active = true;
                return true;
            }
        }));
    }
    // desativa previousActiveTab e dispara a detecção de mudança.
    /**
     * @private
     * @return {?}
     */
    deactivateTab() {
        if (this.previousActiveTab) {
            this.previousActiveTab.active = false;
            this.changeDetector.detectChanges();
        }
    }
}
ThfTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-tabs',
                template: "<div class=\"thf-tabs-header\">\n\n  <ng-container *ngFor=\"let tab of tabs; trackBy: trackByFn\">\n    <thf-tab-button *ngIf=\"isVisibleTab(tab)\"\n      class=\"thf-tab-button\"\n      [t-active]=\"tab.active\"\n      [t-disabled]=\"tab.disabled\"\n      [t-id]=\"tab.id\"\n      [t-hide]=\"tab.hide\"\n      [t-label]=\"tab.label\"\n      [t-small]=\"small\"\n      (keyup.enter)=\"closePopover()\"\n      (t-activated)=\"onTabActive(tab)\"\n      (t-change-state)=\"onTabChangeState(tab)\"\n      (t-click)=\"selectedTab(tab)\">\n    </thf-tab-button>\n  </ng-container>\n\n  <thf-tab-dropdown #tabDropdown\n    *ngIf=\"isShowTabDropdown\"\n    class=\"thf-tab-button thf-tab-dropdown\"\n    t-label=\"Mais\"\n    [t-small]=\"small\"\n    [t-tabs]=\"overflowedTabs\"\n    (t-activated)=\"onTabActive($event)\"\n    (t-change-state)=\"onTabChangeState($event)\"\n    (t-click)=\"selectedTab($event)\">\n  </thf-tab-dropdown>\n</div>\n\n<div class=\"thf-tabs-container\">\n  <ng-content></ng-content>\n</div>\n\n"
            }] }
];
/** @nocollapse */
ThfTabsComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
ThfTabsComponent.propDecorators = {
    tabs: [{ type: ContentChildren, args: [ThfTabComponent,] }],
    tabDropdown: [{ type: ViewChild, args: ['tabDropdown', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-tabs
 */
class ThfTabsModule {
}
ThfTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfPopoverModule
                ],
                declarations: [
                    ThfTabButtonComponent,
                    ThfTabComponent,
                    ThfTabDropdownComponent,
                    ThfTabsComponent
                ],
                entryComponents: [
                    ThfTabButtonComponent,
                    ThfTabDropdownComponent
                ],
                exports: [
                    ThfTabComponent,
                    ThfTabsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfToolbarActionsIconDefault = 'thf-icon-more';
/**
 * \@docsPrivate
 *
 * \@usedBy ThfToolbarComponent
 *
 * \@description
 *
 * O componente `thf-toolbar-actions` tem como objetivo receber uma lista de ações e um ícone que podem ser personalizados.
 */
class ThfToolbarActionsComponent {
    constructor() {
        this._actionsIcon = thfToolbarActionsIconDefault;
    }
    /**
     * Define o ícone das ações.
     * @param {?} icon
     * @return {?}
     */
    set actionsIcon(icon) {
        this._actionsIcon = isTypeof(icon, 'string') ? icon : thfToolbarActionsIconDefault;
    }
    /**
     * @return {?}
     */
    get actionsIcon() {
        return this._actionsIcon;
    }
}
ThfToolbarActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-toolbar-actions',
                template: "<div class=\"thf-toolbar-actions thf-clickable\" (click)=\"popup.toggle()\">\n  <span #toolbarActions class=\"thf-icon {{ actionsIcon }} thf-toolbar-icon\"></span>\n</div>\n\n<thf-popup #popup\n  [t-actions]=\"actions\"\n  [t-target]=\"toolbarActions\">\n</thf-popup>\n",
                providers: [ThfControlPositionService]
            }] }
];
ThfToolbarActionsComponent.propDecorators = {
    actions: [{ type: Input, args: ['t-actions',] }],
    actionsIcon: [{ type: Input, args: ['t-actions-icon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-toolbar` é um cabeçalho para o título da aplicação e informações de usuário e notificações quando houver necessidade.
 */
class ThfToolbarBaseComponent {
    constructor() {
        /**
         * Se falso, oculta o ícone de notificações.
         */
        this.showNotification = true;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Número de notificações.
     * @param {?} value
     * @return {?}
     */
    set notificationNumber(value) {
        this._notificationNumber = convertToInt(value, 0);
    }
    /**
     * @return {?}
     */
    get notificationNumber() {
        return this._notificationNumber;
    }
    /**
     * @return {?}
     */
    get isShowProfile() {
        return this.profile || this.profileActions;
    }
}
ThfToolbarBaseComponent.propDecorators = {
    actions: [{ type: Input, args: ['t-actions',] }],
    actionsIcon: [{ type: Input, args: ['t-actions-icon',] }],
    profile: [{ type: Input, args: ['t-profile',] }],
    profileActions: [{ type: Input, args: ['t-profile-actions',] }],
    showNotification: [{ type: Input, args: ['t-show-notification',] }],
    title: [{ type: Input, args: ['t-title',] }],
    notificationActions: [{ type: Input, args: ['t-notification-actions',] }],
    notificationNumber: [{ type: Input, args: ['t-notification-number',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfToolbarBaseComponent
 *
 * \@example
 *
 * <example name="thf-toolbar-basic" title="Totvs Toolbar Basic">
 *  <file name="sample-thf-toolbar-basic/sample-thf-toolbar-basic.component.html"> </file>
 *  <file name="sample-thf-toolbar-basic/sample-thf-toolbar-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-toolbar-labs" title="Totvs Toolbar Labs">
 *  <file name="sample-thf-toolbar-labs/sample-thf-toolbar-labs.component.html"> </file>
 *  <file name="sample-thf-toolbar-labs/sample-thf-toolbar-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-toolbar-logged" title="Totvs Toolbar - Logged">
 *  <file name="sample-thf-toolbar-logged/sample-thf-toolbar-logged.component.html"> </file>
 *  <file name="sample-thf-toolbar-logged/sample-thf-toolbar-logged.component.ts"> </file>
 * </example>
 */
class ThfToolbarComponent extends ThfToolbarBaseComponent {
    /**
     * @param {?} titleService
     * @param {?} viewRef
     */
    constructor(titleService, viewRef) {
        super();
        this.titleService = titleService;
        this.parentRef = viewRef['_view']['component'];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setTitle(this.title);
    }
    /**
     * @private
     * @param {?} newTitle
     * @return {?}
     */
    setTitle(newTitle) {
        this.titleService.setTitle(newTitle);
    }
}
ThfToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-toolbar',
                template: "<div class=\"thf-toolbar\">\n  <div class=\"thf-toolbar-title\"> {{title}} </div>\n\n  <div class=\"thf-toolbar-group-icon\">\n    <thf-toolbar-actions *ngIf=\"actions && actions.length\"\n      [t-actions]=\"actions\"\n      [t-actions-icon]=\"actionsIcon\">\n    </thf-toolbar-actions>\n\n    <thf-toolbar-notification *ngIf=\"showNotification && notificationActions\"\n      [t-notification-actions]=\"notificationActions\"\n      [t-notification-number]=\"notificationNumber\">\n    </thf-toolbar-notification>\n\n    <thf-toolbar-profile *ngIf=\"isShowProfile\"\n      [t-profile]=\"profile || { avatar: userSrc, title: userName }\"\n      [t-profile-actions]=\"profileActions || userActions\">\n    </thf-toolbar-profile>\n  </div>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfToolbarComponent.ctorParameters = () => [
    { type: Title },
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@usedBy ThfToolbarComponent
 *
 * \@description
 *
 * O componente `thf-toolbar-notification` tem como objetivo notificar o usuário de novas ações da aplicação que necessitam de atenção,
 * como por exemplo um alerta de nova mensagem.
 *
 * O mesmo também permite que a cada nova notificação seja incrementado e exibido, ou não, este número em uma *tag* ao lado do
 * ícone de notificações.
 */
class ThfToolbarNotificationComponent {
    constructor() {
        this._notificationNumber = 0;
    }
    /**
     * Define o número de notificações.
     * @param {?} value
     * @return {?}
     */
    set notificationNumber(value) {
        this._notificationNumber = Number.isInteger(value) ? value : 0;
    }
    /**
     * @return {?}
     */
    get notificationNumber() {
        return this._notificationNumber;
    }
}
ThfToolbarNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-toolbar-notification',
                template: "<div class=\"thf-toolbar-notification thf-clickable\" (click)=\"popup.toggle()\">\n  <span #notification class=\"thf-icon thf-icon-notification thf-toolbar-icon\"></span>\n  <div *ngIf=\"notificationNumber\" class=\"thf-toolbar-notification-badge\">\n    {{ notificationNumber }}\n  </div>\n</div>\n\n<thf-popup #popup\n  [t-actions]=\"notificationActions\"\n  [t-target]=\"notification\">\n</thf-popup>\n",
                providers: [ThfControlPositionService]
            }] }
];
ThfToolbarNotificationComponent.propDecorators = {
    notificationActions: [{ type: Input, args: ['t-notification-actions',] }],
    notificationNumber: [{ type: Input, args: ['t-notification-number',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfToolbarProfileDefaultAvatar = './assets/images/totvs-logo-user.svg';
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfToolbarProfileComponent
 *
 * \@description
 *
 * Componente `thf-toolbar-profile`.
 */
class ThfToolbarProfileComponent {
    constructor() {
        this.defaultAvatar = thfToolbarProfileDefaultAvatar;
    }
}
ThfToolbarProfileComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-toolbar-profile',
                template: "<div #profileElement class=\"thf-toolbar-profile thf-clickable\" (click)=\"popup.toggle()\">\n  <ng-container *ngIf=\"profile.avatar; then avatar; else userIcon\"></ng-container>\n</div>\n\n<thf-popup #popup\n  [t-actions]=\"profileActions\"\n  [t-target]=\"profileElement\">\n\n  <div t-popup-header-template\n    *ngIf=\"profile?.title\"\n    class=\"thf-toolbar-profile-item-header\">\n\n    <thf-avatar\n      class=\"thf-toolbar-profile-item-avatar\"\n      t-size=\"sm\"\n      [t-src]=\"profile.avatar || defaultAvatar\">\n    </thf-avatar>\n\n    <div>\n      <div class=\"thf-toolbar-profile-item-header-title\">\n        {{ profile.title }}\n      </div>\n\n      <div *ngIf=\"profile.subtitle\" class=\"thf-toolbar-profile-item-header-subtitle\">\n        {{ profile.subtitle }}\n      </div>\n    </div>\n  </div>\n\n</thf-popup>\n\n<ng-template #avatar>\n  <thf-avatar t-size=\"xs\" [t-src]=\"profile.avatar\"></thf-avatar>\n</ng-template>\n\n<ng-template #userIcon>\n  <span class=\"thf-icon thf-icon-user thf-toolbar-icon\"></span>\n</ng-template>\n",
                providers: [ThfControlPositionService]
            }] }
];
ThfToolbarProfileComponent.propDecorators = {
    profile: [{ type: Input, args: ['t-profile',] }],
    profileActions: [{ type: Input, args: ['t-profile-actions',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-toolbar
 *
 */
class ThfToolbarModule {
}
ThfToolbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfAvatarModule,
                    ThfPopupModule
                ],
                declarations: [
                    ThfToolbarActionsComponent,
                    ThfToolbarComponent,
                    ThfToolbarNotificationComponent,
                    ThfToolbarProfileComponent
                ],
                exports: [
                    ThfToolbarComponent
                ],
                providers: [],
                schemas: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 *
 * O componente `thf-widget` é recomendado para exibição de *dashboards*, podendo ser utilizado
 * para incluir vários tipos de conteúdo como: gráficos, tabelas, grids e imagens.
 *
 * Além da exibição de conteúdos, este componente possibilita adicionar ações e um link
 * para ajuda, como também possibilita ser utilizado com ou sem sombra.
 *
 * Para controlar sua largura, é possível utilizar o [Grid System](/guides/grid-system) para um maior
 * controle de seu redimensionamento, assim possibilitando o tratamento para diferentes resoluções.
 * @abstract
 */
class ThfWidgetBaseComponent {
    constructor() {
        this._disabled = false;
        this._noShadow = false;
        this._primary = false;
        this.containerHeight = 'auto';
        /**
         * Ação que será executada quando o usuário clicar sobre a área total do `thf-widget`.
         */
        this.click = new EventEmitter();
        /**
         * Função que será disparada com o valor do `t-disabled` quando esta propriedade for alterada.
         */
        this.onDisabled = new EventEmitter();
        /**
         * Função que será chamada na primeira ação.
         */
        this.primaryAction = new EventEmitter();
        /**
         * Função que será chamada na segunda ação.
         */
        this.secondaryAction = new EventEmitter();
        /**
         * Função chamada ao clicar no ícone de configuração
         */
        this.setting = new EventEmitter();
        /**
         * Função que será chamada ao clicar no título.
         */
        this.titleAction = new EventEmitter();
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Aplicação de imagem de fundo.
     * > Se a imagem escolhida intervir na legibilidade do texto contido no `t-widget`,
     * pode-se utilizar a propriedade `t-primary` em conjunto para que os textos fiquem na cor branca.
     *
     * @param {?} value
     * @return {?}
     */
    set background(value) {
        this._background = (value && typeof value === 'string') ? value : undefined;
    }
    /**
     * @return {?}
     */
    get background() {
        return this._background;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita todas as ações do componente.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
        this.onDisabled.emit(this.disabled);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a altura do `thf-widget`.
     * A altura mínima para o `thf-widget` depende do que será exibido através das propriedades `t-primary-label`,
     * `t-setting`, `t-help` e `t-title`.
     * > Caso não seja informado valor, a propriedade irá assumir o tamanho do conteúdo.
     * @param {?} value
     * @return {?}
     */
    set height(value) {
        this._height = parseInt((/** @type {?} */ (value)), 10);
        this.setHeight(this.height);
    }
    /**
     * @return {?}
     */
    get height() {
        return this._height;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Link de ajuda
     * @param {?} value
     * @return {?}
     */
    set help(value) {
        this._help = isTypeof(value, 'string') ? value : '';
        this.setHeight(this.height);
    }
    /**
     * @return {?}
     */
    get help() {
        return this._help;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita a sombra do `thf-widget`.
     *
     * \@default `true`
     * @param {?} value
     * @return {?}
     */
    set noShadow(value) {
        this._noShadow = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
        this.setHeight(this.height);
    }
    /**
     * @return {?}
     */
    get noShadow() {
        return this._noShadow;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Opção para que o `thf-widget` fique em destaque.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set primary(value) {
        this._primary = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get primary() {
        return this._primary;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Descrição da primeira ação.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set primaryLabel(value) {
        this._primaryLabel = isTypeof(value, 'string') ? value : '';
        this.setHeight(this.height);
    }
    /**
     * @return {?}
     */
    get primaryLabel() {
        return this._primaryLabel;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Título do `thf-widget`.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this._title = isTypeof(value, 'string') ? value : '';
        this.setHeight(this.height);
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
}
ThfWidgetBaseComponent.propDecorators = {
    background: [{ type: Input, args: ['t-background',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    height: [{ type: Input, args: ['t-height',] }],
    help: [{ type: Input, args: ['t-help',] }],
    noShadow: [{ type: Input, args: ['t-no-shadow',] }],
    primary: [{ type: Input, args: ['t-primary',] }],
    primaryLabel: [{ type: Input, args: ['t-primary-label',] }],
    secondaryLabel: [{ type: Input, args: ['t-secondary-label',] }],
    title: [{ type: Input, args: ['t-title',] }],
    click: [{ type: Output, args: ['t-click',] }],
    onDisabled: [{ type: Output, args: ['t-on-disabled',] }],
    primaryAction: [{ type: Output, args: ['t-primary-action',] }],
    secondaryAction: [{ type: Output, args: ['t-secondary-action',] }],
    setting: [{ type: Output, args: ['t-setting',] }],
    titleAction: [{ type: Output, args: ['t-title-action',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfWidgetBaseComponent
 *
 * \@example
 *
 * <example name="thf-widget-basic" title="Totvs Widget Basic">
 *  <file name="sample-thf-widget-basic/sample-thf-widget-basic.component.html"> </file>
 *  <file name="sample-thf-widget-basic/sample-thf-widget-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-widget-labs" title="Totvs Widget Labs">
 *  <file name="sample-thf-widget-labs/sample-thf-widget-labs.component.html"> </file>
 *  <file name="sample-thf-widget-labs/sample-thf-widget-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-widget-finance-dashboard" title="Totvs Widget - Finance dashboard">
 *  <file name="sample-thf-widget-finance-dashboard/sample-thf-widget-finance-dashboard.component.html"> </file>
 *  <file name="sample-thf-widget-finance-dashboard/sample-thf-widget-finance-dashboard.component.ts"> </file>
 * </example>
 *
 * <example name="thf-widget-card" title="Totvs Widget - Card">
 *  <file name="sample-thf-widget-card/sample-thf-widget-card.component.html"> </file>
 *  <file name="sample-thf-widget-card/sample-thf-widget-card.component.ts"> </file>
 * </example>
 *
 */
class ThfWidgetComponent extends ThfWidgetBaseComponent {
    /**
     * @param {?} viewRef
     */
    constructor(viewRef) {
        super();
    }
    /**
     * @return {?}
     */
    get showTitleAction() {
        return !!this.titleAction.observers[0];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setHeight(this.height);
    }
    /**
     * @return {?}
     */
    hasTitleHelpOrSetting() {
        return !!this.title || !!this.help || !!this.setting.observers[0];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (!this.disabled) {
            this.click.emit(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openHelp(event) {
        if (!this.disabled) {
            event.stopPropagation();
            window.open(this.help, '_blank');
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    runPrimaryAction(event) {
        if (!this.disabled) {
            event.stopPropagation();
            this.primaryAction.emit();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    runSecondaryAction(event) {
        if (!this.disabled) {
            event.stopPropagation();
            this.secondaryAction.emit();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    runTitleAction(event) {
        if (!this.disabled) {
            event.stopPropagation();
            this.titleAction.emit();
        }
    }
    /**
     * @param {?} height
     * @return {?}
     */
    setHeight(height) {
        if (height) {
            /** @type {?} */
            let bodyHeight = height;
            /** @type {?} */
            const hasSettingOrHelp = this.setting.observers.length > 0 || this.help;
            /** @type {?} */
            const footerBorder = 1;
            /** @type {?} */
            const footerHeight = 40;
            /** @type {?} */
            const settingHeight = 37;
            /** @type {?} */
            const shadowHeight = 2;
            /** @type {?} */
            const titleHeight = 50;
            if (this.noShadow) {
                bodyHeight -= shadowHeight;
            }
            if (hasSettingOrHelp && !this.title) {
                bodyHeight -= settingHeight;
            }
            if (this.title) {
                bodyHeight -= titleHeight;
            }
            if (this.primaryLabel) {
                bodyHeight -= footerHeight + footerBorder;
            }
            this.containerHeight = `${bodyHeight}px`;
        }
        else {
            this.containerHeight = `auto`;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    settingOutput(event) {
        if (!this.disabled) {
            event.stopPropagation();
            this.setting.emit();
        }
    }
}
ThfWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-widget',
                template: "<div\n  [class.thf-clickable]=\"click.observers.length\"\n  [class.thf-widget]=\"!primary\"\n  [class.thf-widget-disabled]=\"disabled\"\n  [class.thf-widget-primary]=\"primary\"\n  [class.thf-widget-no-shadow]=\"noShadow\"\n  [style.background-image]=\"background ? 'url(' + background + ')' : undefined\"\n  (click)=\"onClick($event)\">\n\n  <div *ngIf=\"hasTitleHelpOrSetting()\" class=\"thf-widget-header\">\n\n    <span\n      *ngIf=\"showTitleAction; else noTitleAction\"\n      class=\"thf-widget-title-action\"\n      (click)=\"runTitleAction($event)\">\n      {{ title }}\n    </span>\n    <ng-template #noTitleAction>{{ title }}</ng-template>\n\n    <div *ngIf=\"setting.observers[0] || help\" class=\"thf-pull-right\">\n      <span id=\"settingAction\"\n        *ngIf=\"setting.observers[0]\"\n        class=\"thf-clickable thf-icon thf-icon-settings\"\n        (click)=\"settingOutput($event)\">\n      </span>\n      <span id=\"helpLink\"\n        *ngIf=\"help\"\n        class=\"thf-clickable thf-icon thf-icon-help\"\n        (click)=\"openHelp($event)\">\n      </span>\n    </div>\n  </div>\n\n  <thf-container\n    t-no-border\n    [t-height]=\"containerHeight\">\n    <div class=\"thf-widget-body\">\n      <ng-content></ng-content>\n    </div>\n  </thf-container>\n\n  <div *ngIf=\"primaryLabel\" class=\"thf-widget-footer\">\n\n    <div class=\"thf-widget-xl\" *ngIf=\"!secondaryLabel\">\n      <a class=\"thf-widget-action\" id='primaryAct' (click)=\"runPrimaryAction($event)\">{{ primaryLabel }}</a>\n    </div>\n\n    <div class=\"thf-widget-md\" *ngIf=\"secondaryLabel\">\n      <a class=\"thf-widget-action\" id='primaryAct' (click)=\"runPrimaryAction($event)\">{{ primaryLabel }}</a>\n    </div>\n    <div class=\"thf-widget-md\" *ngIf=\"secondaryLabel\">\n      <a class=\"thf-widget-action\" id='secondaryAct' (click)=\"runSecondaryAction($event)\">{{ secondaryLabel }}</a>\n    </div>\n\n  </div>\n</div>\n"
            }] }
];
/** @nocollapse */
ThfWidgetComponent.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-widget
 */
class ThfWidgetModule {
}
ThfWidgetModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ThfContainerModule
                ],
                exports: [
                    ThfWidgetComponent
                ],
                declarations: [ThfWidgetComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfComponentsModule {
}
ThfComponentsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    ThfAvatarModule,
                    ThfBreadcrumbModule,
                    ThfButtonModule,
                    ThfButtonGroupModule,
                    ThfCalendarModule,
                    ThfChartModule,
                    ThfContainerModule,
                    ThfDisclaimerGroupModule,
                    ThfDisclaimerModule,
                    ThfDividerModule,
                    ThfDropdownModule,
                    ThfDynamicModule,
                    ThfFieldModule,
                    ThfGridModule,
                    ThfInfoModule,
                    ThfListViewModule,
                    ThfLoadingModule,
                    ThfMenuModule,
                    ThfMenuPanelModule,
                    ThfModalModule,
                    ThfNavbarModule,
                    ThfPageModule,
                    ThfPopoverModule,
                    ThfPopupModule,
                    ThfSlideModule,
                    ThfStepperModule,
                    ThfTableModule,
                    ThfTabsModule,
                    ThfTagModule,
                    ThfToolbarModule,
                    ThfWidgetModule
                ],
                exports: [
                    ThfAvatarModule,
                    ThfBreadcrumbModule,
                    ThfButtonModule,
                    ThfButtonGroupModule,
                    ThfCalendarModule,
                    ThfChartModule,
                    ThfContainerModule,
                    ThfDisclaimerGroupModule,
                    ThfDisclaimerModule,
                    ThfDividerModule,
                    ThfDropdownModule,
                    ThfDynamicModule,
                    ThfFieldModule,
                    ThfGridModule,
                    ThfInfoModule,
                    ThfListViewModule,
                    ThfLoadingModule,
                    ThfMenuModule,
                    ThfMenuPanelModule,
                    ThfModalModule,
                    ThfNavbarModule,
                    ThfPageModule,
                    ThfPopoverModule,
                    ThfPopupModule,
                    ThfSlideModule,
                    ThfStepperModule,
                    ThfTableModule,
                    ThfTabsModule,
                    ThfTagModule,
                    ThfToolbarModule,
                    ThfWidgetModule
                ],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfDirectivesModule {
}
ThfDirectivesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    ThfTooltipModule
                ],
                exports: [
                    ThfTooltipModule
                ],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfGuardsModule {
}
ThfGuardsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [],
                exports: [],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfDialogType = {
    // Enum para alert
    Alert: 0,
    // Enum para confirm
    Confirm: 1,
};
ThfDialogType[ThfDialogType.Alert] = 'Alert';
ThfDialogType[ThfDialogType.Confirm] = 'Confirm';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O thf-dialog é um serviço para exibição de caixas de diálogo, é possível customiza-los passando alguns parâmetros de acordo com a
 * necessidade do desenvolvedor.
 * @abstract
 */
class ThfDialogBaseService {
    /**
     * Exibe um diálogo de confirmação, é possível definir ações para as opções de confirmação e cancelamento.
     * @param {?} confirmOptions
     * @return {?}
     */
    confirm(confirmOptions) {
        this.openDialog(ThfDialogType.Confirm, confirmOptions);
    }
    /**
     * Exibe um diálogo de alerta.
     * @param {?} alertOptions
     * @return {?}
     */
    alert(alertOptions) {
        this.openDialog(ThfDialogType.Alert, alertOptions);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const thfDialogAlertLiteralsDefault = {
    en: (/** @type {?} */ ({ ok: 'Ok' })),
    es: (/** @type {?} */ ({ ok: 'Ok' })),
    pt: (/** @type {?} */ ({ ok: 'Ok' }))
};
/** @type {?} */
const thfDialogConfirmLiteralsDefault = {
    en: (/** @type {?} */ ({ cancel: 'Cancel', confirm: 'Confirm' })),
    es: (/** @type {?} */ ({ cancel: 'Cancelar', confirm: 'Confirmar' })),
    pt: (/** @type {?} */ ({ cancel: 'Cancelar', confirm: 'Confirmar' }))
};
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente que serve como container do thf-dialog.service
 */
class ThfDialogComponent {
    constructor() {
        // Objeto primary do thfModal
        this.primaryAction = { label: 'ok', action: (/**
             * @return {?}
             */
            () => { }) };
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.closeSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.closeSubscription = this.thfModal.onXClosed.subscribe((/**
         * @param {?} close
         * @return {?}
         */
        close => this.destroy()));
    }
    // Fecha o thfModal
    /**
     * @return {?}
     */
    close() {
        this.thfModal.close();
        this.destroy();
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
        }
    }
    // Insere os valores recebidos de this.open para o thfModal
    /**
     * @param {?=} primaryLabel
     * @param {?=} primaryAction
     * @param {?=} secondaryLabel
     * @param {?=} secondaryAction
     * @return {?}
     */
    configDialog(primaryLabel, primaryAction, secondaryLabel, secondaryAction) {
        this.primaryAction = {
            label: primaryLabel,
            action: (/**
             * @return {?}
             */
            () => {
                if (primaryAction) {
                    primaryAction();
                }
                this.close();
            })
        };
        if (secondaryLabel) {
            this.secondaryAction = {
                label: secondaryLabel,
                action: (/**
                 * @return {?}
                 */
                () => {
                    if (secondaryAction) {
                        secondaryAction();
                    }
                    this.close();
                })
            };
        }
    }
    // Insere os valores recebidos de thf-dialog.service de acordo com o tipo de diálago solicitado
    /**
     * @param {?} dialogOptions
     * @param {?} dialogType
     * @param {?=} componentRef
     * @return {?}
     */
    open(dialogOptions, dialogType, componentRef) {
        this.title = dialogOptions.title;
        this.message = dialogOptions.message;
        this.componentRef = componentRef;
        this.setDialogLiterals(dialogOptions, dialogType);
        switch (dialogType) {
            case ThfDialogType.Confirm: {
                this.configDialog(this.literalsConfirm.confirm, ((/** @type {?} */ (dialogOptions))).confirm, this.literalsConfirm.cancel, ((/** @type {?} */ (dialogOptions))).cancel);
                break;
            }
            case ThfDialogType.Alert: {
                this.configDialog(this.literalsAlert.ok, ((/** @type {?} */ (dialogOptions))).ok);
                break;
            }
        }
        this.thfModal.open();
    }
    /**
     * @private
     * @param {?} dialogOptions
     * @param {?} dialogType
     * @return {?}
     */
    setDialogLiterals(dialogOptions, dialogType) {
        /** @type {?} */
        const alertLiterals = thfDialogAlertLiteralsDefault;
        /** @type {?} */
        const confirmLiterals = thfDialogConfirmLiteralsDefault;
        /** @type {?} */
        const literals = dialogOptions.literals;
        if (dialogType === ThfDialogType.Alert) {
            this.literalsAlert = Object.assign({}, alertLiterals[thfLocaleDefault], alertLiterals[browserLanguage()], literals);
        }
        else {
            this.literalsConfirm = Object.assign({}, confirmLiterals[thfLocaleDefault], confirmLiterals[browserLanguage()], literals);
        }
    }
}
ThfDialogComponent.decorators = [
    { type: Component, args: [{
                template: "<thf-modal\n  [t-title]=\"title\"\n  [t-primary-action]=\"primaryAction\"\n  [t-secondary-action]=\"secondaryAction\">\n  {{ message }}\n</thf-modal>\n"
            }] }
];
ThfDialogComponent.propDecorators = {
    thfModal: [{ type: ViewChild, args: [ThfModalComponent, { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfDialogBaseService
 *
 * \@example
 *
 * <example name="thf-dialog-basic" title="Totvs Dialog Basic">
 *  <file name="sample-thf-dialog-basic/sample-thf-dialog-basic.component.html"> </file>
 *  <file name="sample-thf-dialog-basic/sample-thf-dialog-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-dialog-labs" title="Totvs Dialog Labs">
 *  <file name="sample-thf-dialog-labs/sample-thf-dialog-labs.component.html"> </file>
 *  <file name="sample-thf-dialog-labs/sample-thf-dialog-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-dialog-cancel-credit-card" title="Totvs Dialog - Cancel Credit Card">
 *  <file name="sample-thf-dialog-cancel-credit-card/sample-thf-dialog-cancel-credit-card.component.html"> </file>
 *  <file name="sample-thf-dialog-cancel-credit-card/sample-thf-dialog-cancel-credit-card.component.ts"> </file>
 * </example>
 */
class ThfDialogService extends ThfDialogBaseService {
    /**
     * @param {?} thfComponentInjector
     */
    constructor(thfComponentInjector) {
        super();
        this.thfComponentInjector = thfComponentInjector;
    }
    /**
     * @param {?} dialogType
     * @param {?} dialogOptions
     * @return {?}
     */
    openDialog(dialogType, dialogOptions) {
        /** @type {?} */
        const componentRef = this.thfComponentInjector.createComponentInApplication(ThfDialogComponent);
        componentRef.changeDetectorRef.detectChanges();
        componentRef.instance.open(dialogOptions, dialogType, componentRef);
    }
}
ThfDialogService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfDialogService.ctorParameters = () => [
    { type: ThfComponentInjectorService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfToasterOrientation = {
    /** Orientção do componente fica no rodapé */
    Bottom: 0,
    /** Orientção do componente fica no topo */
    Top: 1,
};
ThfToasterOrientation[ThfToasterOrientation.Bottom] = 'Bottom';
ThfToasterOrientation[ThfToasterOrientation.Top] = 'Top';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ThfToasterType = {
    /** Enum para informações do tipo "Erro" */
    Error: 0,
    /** Enum para informações do tipo "Informação" */
    Information: 1,
    /** Enum para informações do tipo "Sucesso" */
    Success: 2,
    /** Enum para informações do tipo "Atenção" */
    Warning: 3,
};
ThfToasterType[ThfToasterType.Error] = 'Error';
ThfToasterType[ThfToasterType.Information] = 'Information';
ThfToasterType[ThfToasterType.Success] = 'Success';
ThfToasterType[ThfToasterType.Warning] = 'Warning';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Serviço responsável por emitir as notificações em uma página. São disponibilizados os métodos de:
 *
 * - success,
 * - warning,
 * - error,
 * - information.
 *
 * Cada um destes métodos recebe como parâmetro o objeto "ThfNotification" que contém os dados da mensagem e o
 * objeto ViewContainerRef que é a representação do container do componente onde será criada a notificação.
 *
 * Estas notificações serão exibidas durante 10 segundos, após este tempo a mesma é removida automaticamente.
 * @abstract
 */
class ThfNotificationBaseService {
    constructor() {
        // Array responsável por guardar a instância de thf-toaster's superiores.
        this.stackTop = [];
        // Array responsável por guardar a instância de thf-toaster's inferiores.
        this.stackBottom = [];
        // Duração do toaster ativo.
        this.durationToaster = 10000;
    }
    /**
     * Emite uma notificação de sucesso.
     *
     * @param {?} notification {ThfNotification | string} Objeto com os dados da notificação ou somente a string com a mensagem da notificação.
     * @return {?}
     */
    success(notification) {
        this.createToaster(this.buildToaster(notification, ThfToasterType.Success));
    }
    /**
     * Emite uma notificação de atenção.
     *
     * @param {?} notification {ThfNotification | string} Objeto com os dados da notificação ou somente a string com a mensagem da notificação
     * @return {?}
     */
    warning(notification) {
        this.createToaster(this.buildToaster(notification, ThfToasterType.Warning));
    }
    /**
     * Emite uma notificação de erro.
     *
     * @param {?} notification {ThfNotification | string} Objeto com os dados da notificação ou somente a string com a mensagem da notificação
     * @return {?}
     */
    error(notification) {
        this.createToaster(this.buildToaster(notification, ThfToasterType.Error));
    }
    /**
     * Emite uma notificação de informação.
     *
     * @param {?} notification {ThfNotification | string} Objeto com os dados da notificação ou somente a string com a mensagem da notificação
     * @return {?}
     */
    information(notification) {
        this.createToaster(this.buildToaster(notification, ThfToasterType.Information));
    }
    /**
     * \@docsPrivate
     *
     * Cria um objeto do tipo ThfToaster de acordo o tipo.
     *
     * @private
     * @param {?} notification {ThfNotification | string} Objeto ThfNotification com os dados da notificação
     * @param {?} type
     * @return {?}
     */
    buildToaster(notification, type) {
        /** @type {?} */
        let index = 0;
        /** @type {?} */
        let orientation;
        if (((/** @type {?} */ (notification))).orientation === undefined ||
            ((/** @type {?} */ (notification))).orientation === ThfToasterOrientation.Bottom) {
            index = this.stackBottom.length;
            orientation = ThfToasterOrientation.Bottom;
        }
        else {
            index = this.stackTop.length;
            orientation = ThfToasterOrientation.Top;
        }
        /** @type {?} */
        const toaster = {
            componentRef: undefined,
            message: ((/** @type {?} */ (notification))).message || (/** @type {?} */ (notification)),
            type: type,
            orientation: orientation,
            action: ((/** @type {?} */ (notification))).action,
            actionLabel: ((/** @type {?} */ (notification))).actionLabel,
            position: index
        };
        if (((/** @type {?} */ (notification))).action) {
            toaster.action = (/**
             * @param {?} param
             * @return {?}
             */
            (param) => {
                ((/** @type {?} */ (notification))).action();
                this.destroyToaster(param.componentRef);
            });
        }
        return toaster;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * O componente thf-toaster foi construído para exibir notificações para o usuário.
 * @abstract
 */
class ThfToasterBaseComponent {
    constructor() {
        /**
         * Orientação da notificação, a mesma pode ser exibida na parte superior ou inferior da página.
         */
        this.orientation = ThfToasterOrientation.Bottom;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfToasterBaseComponent
 */
class ThfToasterComponent extends ThfToasterBaseComponent {
    /**
     * @param {?} changeDetector
     * @param {?=} elementeRef
     */
    constructor(changeDetector, elementeRef) {
        super();
        this.changeDetector = changeDetector;
        this.elementeRef = elementeRef;
        /* Margem do Toaster referênte à sua orientação e posição*/
        this.margin = 20;
        /* Observable para monitorar o Close to Toaster */
        this.observableOnClose = new Subject();
        /* Mostra ou oculta o Toaster */
        this.showToaster = true;
        /* Posição do Toaster*/
        this.toasterPosition = 'thf-toaster-bottom';
    }
    /* Muda a posição do Toaster na tela*/
    /**
     * @param {?} position
     * @return {?}
     */
    changePosition(position) {
        this.elementeRef.nativeElement.style.display = 'table';
        this.margin = 6 + (44 * (position)) + position * 6;
        if (this.orientation === ThfToasterOrientation.Top) {
            this.toaster.nativeElement.style.top = this.margin + 'px';
        }
        else {
            this.toaster.nativeElement.style.bottom = this.margin + 'px';
        }
    }
    /* Fecha o componente Toaster */
    /**
     * @return {?}
     */
    close() {
        this.showToaster = false;
        this.observableOnClose.next(true);
    }
    /* Configura o Toaster com os atributos passados para ele */
    /**
     * @param {?} thfToaster
     * @return {?}
     */
    configToaster(thfToaster) {
        this.type = thfToaster.type;
        this.message = thfToaster.message;
        this.orientation = thfToaster.orientation;
        this.position = thfToaster.position;
        this.action = thfToaster.action;
        this.actionLabel = (thfToaster.actionLabel) ? thfToaster.actionLabel : 'Fechar';
        this.componentRef = thfToaster.componentRef;
        /* Muda a orientação do Toaster */
        if (this.orientation === ThfToasterOrientation.Top) {
            this.toasterPosition = 'thf-toaster-top';
        }
        /* Muda a posição do Toaster */
        this.changePosition(this.position);
        /* Switch para o tipo de Toaster */
        switch (this.type) {
            case ThfToasterType.Error: {
                this.toasterType = 'thf-toaster-error';
                this.icon = 'thf-icon-close';
                break;
            }
            case ThfToasterType.Information: {
                this.toasterType = 'thf-toaster-info';
                this.icon = 'thf-icon-info';
                break;
            }
            case ThfToasterType.Success: {
                this.toasterType = 'thf-toaster-success';
                this.icon = 'thf-icon-ok';
                break;
            }
            case ThfToasterType.Warning: {
                this.toasterType = 'thf-toaster-warning';
                this.icon = 'thf-icon-warning';
                break;
            }
        }
        this.changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    getShowToaster() {
        return this.showToaster;
    }
    /**
     * @return {?}
     */
    getIcon() {
        return this.icon;
    }
    /**
     * @return {?}
     */
    getToasterPosition() {
        return this.toasterPosition;
    }
    /**
     * @return {?}
     */
    getToasterType() {
        return this.toasterType;
    }
    /* Chama a função passada pelo atributo `action` */
    /**
     * @return {?}
     */
    thfToasterAction() {
        this.action(this);
    }
}
ThfToasterComponent.decorators = [
    { type: Component, args: [{
                selector: 'thf-toaster',
                template: "<div #toaster *ngIf=\"getShowToaster()\"\n  class=\"thf-toaster {{ getToasterType() }} {{ getToasterPosition() }} thf-clickable\"\n  (click)=\"close()\">\n\n  <div class=\"thf-toaster-message\">\n    <span class=\"thf-icon {{ getIcon() }}\"></span> {{ message }}\n  </div>\n\n  <div *ngIf=\"action !== undefined\" (click)=\"thfToasterAction()\" class=\"thf-toaster-action\">\n    {{ actionLabel }}\n  </div>\n\n</div>\n"
            }] }
];
/** @nocollapse */
ThfToasterComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
ThfToasterComponent.propDecorators = {
    toaster: [{ type: ViewChild, args: ['toaster', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfNotificationBaseService
 *
 * \@example
 *
 * <example name="thf-notification-basic" title="Totvs Notification Basic">
 *  <file name="sample-thf-notification-basic/sample-thf-notification-basic.component.html"> </file>
 *  <file name="sample-thf-notification-basic/sample-thf-notification-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-notification-labs" title="Totvs Notification Labs">
 *  <file name="sample-thf-notification-labs/sample-thf-notification-labs.component.html"> </file>
 *  <file name="sample-thf-notification-labs/sample-thf-notification-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-notification-sales" title="Totvs Notification - Sales">
 *  <file name="sample-thf-notification-sales/sample-thf-notification-sales.component.html"> </file>
 *  <file name="sample-thf-notification-sales/sample-thf-notification-sales.component.ts"> </file>
 * </example>
 */
class ThfNotificationService extends ThfNotificationBaseService {
    /**
     * @param {?} thfComponentInjector
     */
    constructor(thfComponentInjector) {
        super();
        this.thfComponentInjector = thfComponentInjector;
    }
    /**
     * @param {?} toaster
     * @return {?}
     */
    createToaster(toaster) {
        /** @type {?} */
        const componentRef = this.thfComponentInjector.createComponentInApplication(ThfToasterComponent);
        toaster.componentRef = componentRef;
        componentRef.changeDetectorRef.detectChanges();
        componentRef.instance.configToaster(toaster);
        if (toaster.orientation === ThfToasterOrientation.Top) {
            this.stackTop.push(componentRef);
        }
        else {
            this.stackBottom.push(componentRef);
        }
        this.observableOnClose(componentRef);
        if (toaster.action === undefined) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.destroyToaster(componentRef);
            }), this.durationToaster);
        }
    }
    /**
     * @param {?} toaster
     * @return {?}
     */
    destroyToaster(toaster) {
        /** @type {?} */
        let stack;
        if (toaster.instance.orientation === ThfToasterOrientation.Top) {
            stack = this.stackTop;
        }
        else {
            stack = this.stackBottom;
        }
        /** @type {?} */
        const index = stack.indexOf(toaster);
        stack.splice(index, 1);
        this.thfComponentInjector.destroyComponentInApplication(toaster);
        for (let count = 0; count < stack.length; count++) {
            stack[count].instance.changePosition(count);
        }
    }
    /**
     * @private
     * @param {?} componentRef
     * @return {?}
     */
    observableOnClose(componentRef) {
        componentRef.instance.observableOnClose.subscribe((/**
         * @return {?}
         */
        () => {
            this.destroyToaster(componentRef);
        }));
    }
}
ThfNotificationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ThfNotificationService.ctorParameters = () => [
    { type: ThfComponentInjectorService }
];
/** @nocollapse */ ThfNotificationService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ThfNotificationService_Factory() { return new ThfNotificationService(ɵɵinject(ThfComponentInjectorService)); }, token: ThfNotificationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NO_ERROR_HEADER_PARAM = 'X-Totvs-No-Error';
/**
 * \@description
 *
 * O serviço Totvs Http Interceptor realiza o tratamento de requisições HTTP conforme o padrão do
 * [**Guia de implementação das APIs TOTVS**](http://tdn.totvs.com/pages/viewpage.action?pageId=484701395) para adaptá-lo
 * ao modelo do THF.
 *
 * Ao analisar o objeto `_messages` retornado pela requisição, o serviço exibirá notificações com mensagens na tela.
 * Os retornos de erros com códigos 4xx e 5xx são tratados automaticamente, sem a necessidade de incluir o `_messages`.
 *
 * Também existe a possibilidade de não apresentar a notificação quando houver algum erro com códigos 4xx e 5xx,
 * utilizando o parâmetro `X-Totvs-No-Error` que foi definido conforme o
 * [**Guia de implementação das APIs TOTVS**](http://tdn.totvs.com/pages/viewpage.action?pageId=484701395) (em Cabeçalhos Customizados).
 * O parâmetro `X-Totvs-No-Error` deve ser informado no cabeçalho da requisição com o valor `'true'` para funcionar corretamente,
 * por exemplo:
 *
 * ```
 * ...
 *  const headers = { 'X-Totvs-No-Error': 'true' };
 *
 *  this.http.get(`/customers/1`, { headers: headers });
 * ...
 *
 * ```
 * > Após a validação no interceptor, o parâmetro será removido do cabeçalho da requisição.
 *
 * O `Content-Type` deve ser `application/json` e a estrutura de mensagem recebida pelo serviço deve seguir o
 * [**Guia de implementação das APIs TOTVS**](http://tdn.totvs.com/pages/viewpage.action?pageId=484701395)
 * (em Mensagens de sucesso para coleções), exemplo:
 *  - _messages: lista de mensagens de erro ou informativo resultante do serviço.
 *    - type: success, warning, error, e information;
 *    - code: título ou código da mensagem;
 *    - message: texto da mensagem;
 *    - detailedMessage: detalhamento do erro ou informativo;
 *
 * Ao importar o módulo `ThfModule` na aplicação, o `thf-http-interceptor` é automaticamente configurado sem a necessidade
 * de qualquer configuração extra.
 *
 * Ao realizar requisições utilize o `HttpClient`, conforme exemplo abaixo:
 *
 * ```
 * import { HttpClient } from '\@angular/common/http';
 *
 * ...
 *
 * \@Injectable()
 * export class UserService {
 *
 *   constructor(private http: HttpClient) { }
 *
 *   getUsers() {
 *     return this.http.get('/api/users');
 *   }
 *
 *   ...
 *
 * }
 * ```
 *
 * @abstract
 */
class ThfHttpInterceptorBaseService {
    /**
     * @param {?} notification
     * @param {?} dialog
     */
    constructor(notification, dialog) {
        this.notification = notification;
        this.dialog = dialog;
        this.notificationTypes = ['success', 'warning', 'error', 'information'];
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const cloneRequest = request.clone();
        request = request.headers.has(NO_ERROR_HEADER_PARAM) ? this.cloneRequestWithoutNoErrorHeaderParam(request) : request;
        return next.handle(request).pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            if (response instanceof HttpResponse) {
                this.processResponse(response);
            }
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.processErrorResponse(error, cloneRequest);
        })));
    }
    /**
     * @param {?} response
     * @return {?}
     */
    processResponse(response) {
        if (response.body && response.body._messages) {
            /** @type {?} */
            const messages = response.body._messages;
            if (messages instanceof Array) {
                messages.forEach((/**
                 * @param {?} message
                 * @return {?}
                 */
                (message) => {
                    this.showNotification(message);
                }));
            }
            else {
                this.showNotification(messages);
            }
        }
    }
    /**
     * @param {?} response
     * @param {?} request
     * @return {?}
     */
    processErrorResponse(response, request) {
        /** @type {?} */
        const errorResponse = response.status !== 0
            ? response.error
            : { code: 0, message: 'Servidor não está respondendo.', detailedMessage: response.message };
        /** @type {?} */
        const hasNoErrorParam = this.hasNoErrorParam(request);
        // not show the notification when has NoError parameter on header of request.
        if (errorResponse && errorResponse.message && !hasNoErrorParam) {
            this.showNotification(Object.assign({}, errorResponse, { type: 'error' }));
        }
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    cloneRequestWithoutNoErrorHeaderParam(request) {
        return request && request.clone({ headers: request.headers.delete(NO_ERROR_HEADER_PARAM) });
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    hasNoErrorParam(request) {
        /** @type {?} */
        const noErrorParam = request && request.headers.get(NO_ERROR_HEADER_PARAM);
        return noErrorParam && noErrorParam.toString().toLocaleLowerCase() === 'true';
    }
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    showNotification(response) {
        /** @type {?} */
        const typeNotification = this.notificationTypes.includes(response.type) ? response.type : 'information';
        /** @type {?} */
        const notificationAction = this.generateNotificationAction(response);
        this.notification[typeNotification]({
            message: response.message,
            actionLabel: notificationAction.label,
            action: notificationAction.action
        });
    }
    /**
     * @private
     * @param {?} errorResponse
     * @return {?}
     */
    generateNotificationAction(errorResponse) {
        /** @type {?} */
        let notificationAction;
        /** @type {?} */
        let notificationLabel;
        /** @type {?} */
        let notificationMessage = errorResponse.message.concat(` ${errorResponse.detailedMessage}`);
        if (errorResponse.details && errorResponse.details instanceof Array) {
            errorResponse.details.forEach((/**
             * @param {?} detailError
             * @return {?}
             */
            (detailError) => {
                notificationMessage += `\n${detailError.message}`;
            }));
        }
        if (errorResponse.helpUrl && !(errorResponse.detailedMessage || errorResponse.details)) {
            notificationLabel = 'Ajuda';
            notificationAction = this.generateUrlHelpFunction(errorResponse.helpUrl);
        }
        else if (errorResponse.detailedMessage || errorResponse.details) {
            notificationLabel = 'Detalhes';
            notificationAction = this.generateDialogDetailFunction(errorResponse, notificationMessage);
        }
        return { label: notificationLabel, action: notificationAction };
    }
    /**
     * @private
     * @param {?} helpUrl
     * @return {?}
     */
    generateUrlHelpFunction(helpUrl) {
        return (/**
         * @return {?}
         */
        () => { window.open(helpUrl, '_blank'); });
    }
    /**
     * @private
     * @param {?} errorResponse
     * @param {?} notificationMessage
     * @return {?}
     */
    generateDialogDetailFunction(errorResponse, notificationMessage) {
        return (/**
         * @return {?}
         */
        () => {
            this.dialog.alert({
                title: errorResponse.code,
                message: notificationMessage,
                ok: errorResponse.helpUrl ? this.generateUrlHelpFunction(errorResponse.helpUrl) : undefined
            });
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfHttpInterceptorBaseService
 *
 * \@example
 * <example name='thf-http-interceptor-labs' title='Totvs Http Interceptor Labs'>
 *  <file name='sample-thf-http-interceptor-labs.component.ts'> </file>
 *  <file name='sample-thf-http-interceptor-labs.component.html'> </file>
 * </example>
 */
class ThfHttpInterceptorService extends ThfHttpInterceptorBaseService {
    /**
     * @param {?} notification
     * @param {?} dialog
     */
    constructor(notification, dialog) {
        super(notification, dialog);
    }
}
ThfHttpInterceptorService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ThfHttpInterceptorService.ctorParameters = () => [
    { type: ThfNotificationService },
    { type: ThfDialogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfHttpInterceptorModule {
}
ThfHttpInterceptorModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    ThfHttpInterceptorService,
                    ThfDialogService,
                    ThfNotificationService,
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: ThfHttpInterceptorService,
                        multi: true
                    }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * Serviço responsável por efetuar o controle de interação com o serviço de interceptor `ThfHttpRequestInterceptorService`
 * gerenciando o seu estado.
 */
class ThfHttpRequesControltService {
    constructor() {
        this.controlHttpRequest = new Subject();
    }
    /**
     * @return {?}
     */
    getControlHttpRequest() {
        return this.controlHttpRequest.asObservable();
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    send(value = 0) {
        this.controlHttpRequest.next(value);
    }
}
ThfHttpRequesControltService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const noCountPendingRequests = 'X-Totvs-No-Count-Pending-Requests';
/** @type {?} */
const screenLock = 'X-Totvs-Screen-Lock';
/**
 * \@description
 *
 * O serviço Totvs Http Request Interceptor realiza a contabilização de requisições pendentes na aplicação.
 *
 * Existe a possibilidade de não efetuar a contabilização das requisições pendentes, utilizando o parâmetro
 * `X-Totvs-No-Count-Pending-Requests`. Para isso deve ser informado no cabeçalho da requisição com o valor `'true'`,
 * por exemplo:
 *
 * ```
 * ...
 *  const headers = { 'X-Totvs-No-Count-Pending-Requests': 'true' };
 *
 *  this.http.get(`/customers/1`, { headers: headers });
 * ...
 *
 * ```
 * Para obter a quantidade de requisições pendentes, deve inscrever-se no método `getCountPendingRequests` do
 * serviço `ThfHttpRequestInterceptorService`, com isso, ao realizar requisições utilizando `HttpClient`,
 * será retornado a quantidade de requisições pendentes.
 *
 * Também existe a possibildade de travar a tela e mostrar uma imagem de _loading_ durante o processamento de uma requisição
 * deve-se passar o parâmetro `X-Totvs-Screen-Lock` no cabeçalho da requisição com valor `'true'`.
 *
 * por exemplo:
 *
 * ```
 * ...
 *  const headers = { 'X-Totvs-Screen-Lock': 'true' };
 *
 *  this.http.get(`/customers/1`, { headers: headers });
 * ...
 *
 * ```
 * > Após a validação no interceptor, o parâmetro será removido do cabeçalho da requisição.
 *
 * Ao importar o módulo `ThfModule` na aplicação, o `thf-http-request-interceptor` é automaticamente configurado sem a necessidade
 * de qualquer configuração extra.
 *
 *
 * Segue abaixo um exemplo de uso:
 *
 * ```
 * import { HttpClient } from '\@angular/common/http';
 *
 * ...
 *
 * \@Injectable()
 * export class CustomersService {
 *
 *  headers = { 'X-Totvs-No-Count-Pending-Requests': true, 'X-Totvs-Screen-Lock': 'true' }
 *  pendingRequests: number = 0;
 *  subscription: Subscription;
 *
 *  constructor(
 *    private http: HttpClient,
 *    private httpRequestInterceptor: ThfHttpRequestInterceptorService) { }
 *
 *  ngOnDestroy(): void {
 *    this.subscription.unsubscribe();
 *  }
 *
 *  ngOnInit(): void {
 *    this.subscription = this.httpRequestInterceptor.getCountPendingRequests().subscribe(data => {
 *      this.pendingRequests = data;
 *    });
 *  }
 *
 *  getCustomers() {
 *    return this.http.get(`/customers/1`, { headers: headers });
 *  }
 *
 *  ...
 *
 * }
 * ```
 *
 * \@example
 * <example name='thf-http-request-interceptor-labs' title='Totvs Http Request Interceptor Labs'>
 *  <file name='sample-thf-http-request-interceptor-labs.component.ts'> </file>
 *  <file name='sample-thf-http-request-interceptor-labs.component.html'> </file>
 * </example>
 */
class ThfHttpRequestInterceptorService {
    /**
     * @param {?} controlHttpRequest
     * @param {?} thfComponentInjector
     */
    constructor(controlHttpRequest, thfComponentInjector) {
        this.controlHttpRequest = controlHttpRequest;
        this.thfComponentInjector = thfComponentInjector;
        this.loadingOverlayComponent = undefined;
        this.pendingRequests = 0;
        this.overlayRequests = 0;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const requestClone = request.clone();
        request = this.requestCloneWithoutHeaderParam([noCountPendingRequests, screenLock], request);
        this.setCountPendingRequests(true, requestClone);
        this.setCountOverlayRequests(true, requestClone);
        return next.handle(request).pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            if (response instanceof HttpResponse) {
                this.setCountPendingRequests(false, requestClone);
                this.setCountOverlayRequests(false, requestClone);
            }
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => {
            this.setCountPendingRequests(false, requestClone);
            this.setCountOverlayRequests(false, requestClone);
            return throwError(error);
        })));
    }
    /**
     * @return {?}
     */
    getCountPendingRequests() {
        return this.controlHttpRequest.getControlHttpRequest();
    }
    /**
     * @private
     * @return {?}
     */
    buildLoading() {
        if (!this.loadingOverlayComponent) {
            this.loadingOverlayComponent = this.thfComponentInjector.createComponentInApplication(ThfLoadingOverlayComponent);
            this.loadingOverlayComponent.instance.screenLock = true;
            this.loadingOverlayComponent.instance.changeDetector.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    destroyLoading() {
        if (this.loadingOverlayComponent) {
            this.thfComponentInjector.destroyComponentInApplication(this.loadingOverlayComponent);
            this.loadingOverlayComponent = undefined;
        }
    }
    /**
     * @private
     * @param {?} headersParams
     * @param {?} request
     * @return {?}
     */
    requestCloneWithoutHeaderParam(headersParams, request) {
        /** @type {?} */
        let isRequestClone = false;
        headersParams.forEach((/**
         * @param {?} headerParam
         * @return {?}
         */
        headerParam => {
            if (request.headers.has(headerParam)) {
                request.headers.delete(headerParam);
                isRequestClone = true;
            }
        }));
        return isRequestClone ? request.clone({ headers: request.headers }) : request;
    }
    /**
     * @private
     * @param {?} isIncrement
     * @param {?} request
     * @return {?}
     */
    setCountPendingRequests(isIncrement, request) {
        /** @type {?} */
        const hasCountPendingRequestHeaderParam = request.headers.has(noCountPendingRequests);
        /** @type {?} */
        const headerParam = request.headers.get(noCountPendingRequests);
        if (hasCountPendingRequestHeaderParam && (headerParam.toString().toLowerCase() === 'true')) {
            return;
        }
        this.pendingRequests += isIncrement ? 1 : -1;
        this.controlHttpRequest.send(this.pendingRequests);
    }
    /**
     * @private
     * @param {?} isIncrement
     * @param {?} request
     * @return {?}
     */
    setCountOverlayRequests(isIncrement, request) {
        /** @type {?} */
        const hasOverlayRequestHeaderParam = request.headers.has(screenLock);
        if (hasOverlayRequestHeaderParam) {
            /** @type {?} */
            const headerParam = request.headers.get(screenLock);
            if (headerParam.toString().toLowerCase() === 'false') {
                return;
            }
            this.overlayRequests += isIncrement ? 1 : -1;
            this.overlayRequests > 0 ? this.buildLoading() : this.destroyLoading();
        }
    }
}
ThfHttpRequestInterceptorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ThfHttpRequestInterceptorService.ctorParameters = () => [
    { type: ThfHttpRequesControltService },
    { type: ThfComponentInjectorService }
];
/** @nocollapse */ ThfHttpRequestInterceptorService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ThfHttpRequestInterceptorService_Factory() { return new ThfHttpRequestInterceptorService(ɵɵinject(ThfHttpRequesControltService), ɵɵinject(ThfComponentInjectorService)); }, token: ThfHttpRequestInterceptorService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfHttpRequestModule {
}
ThfHttpRequestModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    ThfHttpRequesControltService,
                    ThfHttpRequestInterceptorService,
                    ThfComponentInjectorService,
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: ThfHttpRequestInterceptorService,
                        multi: true
                    }
                ],
                entryComponents: [ThfLoadingOverlayComponent, ThfLoadingComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfInterceptorsModule {
}
ThfInterceptorsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    ThfHttpInterceptorModule,
                    ThfHttpRequestModule
                ],
                exports: [
                    ThfHttpInterceptorModule,
                    ThfHttpRequestModule
                ],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfPipesModule {
}
ThfPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    ThfTimeModule
                ],
                exports: [
                    ThfTimeModule
                ],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do serviço `thf-color-palette`.
 */
class ThfColorPaletteModule {
}
ThfColorPaletteModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    ThfColorPaletteService
                ],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfComponentInjectorModule {
}
ThfComponentInjectorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [],
                exports: [],
                providers: [
                    ThfComponentInjectorService
                ],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do serviço thf-control-position.
 */
class ThfControlPositionModule {
}
ThfControlPositionModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    ThfControlPositionService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do serviço `thf-date`.
 */
class ThfDateTimeModule {
}
ThfDateTimeModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    ThfDateService
                ],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfDialogModule {
}
ThfDialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ThfDialogComponent
                ],
                imports: [
                    ThfModalModule
                ],
                exports: [
                    ThfDialogComponent
                ],
                entryComponents: [
                    ThfDialogComponent
                ],
                providers: [
                    ThfDialogService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O pipe thf-i18n é responsável por tratar literais parâmetrizadas, dando mais flexibilidade as literais de tradução.
 * O número de parâmetros inseridos nas literais deve coincidir com a quantia de parâmetros passados por parâmetro,
 * os parâmetros serão substituidos de acordo com a ordem informada.
 *
 * Para inserir um parâmetro em uma literal, o mesmo deverá ser inserido entre chaves dentro da literal e posicionado
 * de acordo como deve ser exibido após a sua transformação.
 *
 * ```
 * const i18nPT = {
 *   pagination: 'Página {1} de {2} páginas.',
 *   totalPages: 'Total de {totalPages} encontradas.'
 * };
 * ```
 *
 * É possível passar um valor ou um array de valores para o pipe, caso seja passado um array, os valores devem obedecer a ordem
 * informada na literal.
 *
 * ```
 * {{ i18nPT.pagination | thfI18n:[1,10] }}
 * {{ i18nPT.totalPages | thfI18n:10 }}
 * ```
 */
class ThfI18nBasePipe {
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    transform(value, args) {
        if (!value) {
            return '';
        }
        if (!(args instanceof Array)) {
            args = [args];
        }
        for (const arg of args) {
            value = value.replace(/(\{\w*\})+/, arg);
        }
        return value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfI18nBasePipe
 *
 * \@example
 * <example name='thf-i18n-pipe-labs' title='Totvs i18n Pipe Labs' >
 *  <file name='sample-thf-i18n-pipe-labs.component.html'> </file>
 *  <file name='sample-thf-i18n-pipe-labs.component.ts'> </file>
 *  <file name='sample-thf-i18n-pipe.component.html'> </file>
 *  <file name='sample-thf-i18n-pipe.component.ts'> </file>
 * </example>
 */
class ThfI18nPipe extends ThfI18nBasePipe {
}
ThfI18nPipe.decorators = [
    { type: Pipe, args: [{
                name: 'thfI18n'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfNotificationModule {
}
ThfNotificationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ThfToasterComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [],
                entryComponents: [
                    ThfToasterComponent
                ],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfServicesModule {
}
ThfServicesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ThfI18nPipe
                ],
                imports: [
                    ThfColorPaletteModule,
                    ThfComponentInjectorModule,
                    ThfControlPositionModule,
                    ThfDateTimeModule,
                    ThfDialogModule,
                    ThfLanguageModule,
                    ThfNotificationModule
                ],
                exports: [
                    ThfColorPaletteModule,
                    ThfComponentInjectorModule,
                    ThfControlPositionModule,
                    ThfDateTimeModule,
                    ThfDialogModule,
                    ThfI18nPipe,
                    ThfNotificationModule
                ],
                providers: [],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThfModule {
}
ThfModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    ThfComponentsModule,
                    ThfDirectivesModule,
                    ThfGuardsModule,
                    ThfInterceptorsModule,
                    ThfPipesModule,
                    ThfServicesModule
                ],
                exports: [
                    ThfComponentsModule,
                    ThfDirectivesModule,
                    ThfInterceptorsModule,
                    ThfGuardsModule,
                    ThfPipesModule,
                    ThfServicesModule
                ],
                providers: [ThfNotificationService],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const I18N_CONFIG = new InjectionToken('I18N_CONFIG');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O serviço `ThfI18nService` possibilita utilizar múltiplos idiomas e contextos na aplicação.
 *
 * > Antes da utilização do serviço, é necessário realizar a
 * [importação e configuração do módulo `ThfI18nModule`](/documentation/thf-i18n#i18n-config).
 *
 * **Utilização do serviço `ThfI18nService`:**
 *
 * Para utilizar o serviço basta importá-lo nos componentes que necessitarem de literais e fazer a injeção de
 * dependência no construtor:
 * ```
 *  import { ThfI18nService } from '\@totvs/thf-ui';
 *  ...
 *  constructor(private thfI18nService: ThfI18nService) { }
 *  ...
 * ```
 *
 * Por fim realizar a busca pelas literais, inscrevendo-se no [Observable](https://angular.io/guide/observables) pelo
 * método `getLiterals()`.
 *
 * > O método `getLiterals()` pode receber um objeto do tipo da interface `ThfI18nLiterals` como parâmetro,
 * porém, nenhuma das propriedades são obrigatórias. Caso nenhum parâmetro seja passado, serão buscadas
 * todas as literais do contexto definido com padrão, no idioma definido como padrão.
 *
 * Exemplos de requisição:
 * ```
 * literals = {};
 * literalsEn = {};
 * literalsCrm = {};
 *
 * constructor(private thfI18nService: ThfI18nService) {
 *   thfI18nService.getLiterals()
 *     .subscribe((literals) => {
 *       this.literals = literals;
 *     });
 *
 *   thfI18nService.getLiterals({context: 'crm', literals: ['add', 'remove']})
 *     .subscribe((literals) => {
 *       this.literalsCrm = literals;
 *     });
 *
 *   thfI18nService.getLiterals({language: 'en-us'})
 *     .subscribe((literals) => {
 *       this.literalsEn = literals;
 *     });
 * }
 * ```
 *
 * Para apresentar as literais capturadas acima no HTML do componente, deve-se utilizar o
 * seguinte código:
 *
 * <pre ngNonBindable>
 * {{ literals?.add }}
 * {{ literals?.remove }}
 * </pre>
 *
 * Caso as literais contenham variáveis que precisem ser substituídas, pode-se utilizar o *pipe* `thfI18n`.
 * É possível informar propriedades do componente como `name` e `nickname` ou
 * informar o valor diretamente com "" ou número, conforme o exemplo abaixo:
 *
 * <pre ngNonBindable>
 * {{ literals?.people | thfI18n:[120] }}
 * {{ literals?.greeting | thfI18n:[name, nickname] }}
 * {{ literals?.greeting | thfI18n:["Brad", "Green"] }}
 * </pre>
 *
 * > É importante o uso do operador `?` (Elvis) para evitar erros enquanto as literais não forem carregadas.
 *
 * ### Teste unitário
 *
 * Abaixo segue um exemplo de *setup* inicial de teste unitário do *AppComponent* que utiliza o `ThfI18nService`:
 *
 * ```
 * import { async, TestBed } from '\@angular/core/testing';
 * import { HttpClientTestingModule } from '\@angular/common/http/testing';
 *
 * import { ThfI18nModule } from '\@totvs/thf-ui';
 *
 * import { AppComponent } from './app.component';
 *
 * describe('AppComponent', () => {
 *   const anotherPT = {
 *     text: 'texto',
 *     add: 'adicionar',
 *     remove: 'remover'
 *   };
 *
 *   const generalPT = {
 *     text: 'texto',
 *     add: 'adicionar',
 *     remove: 'remover'
 *   };
 *
 *   const config = {
 *     default: {
 *       language: 'pt-BR',
 *       context: 'general',
 *       cache: false
 *     },
 *     contexts: {
 *       general: {
 *         'pt-br': generalPT
 *       },
 *       another: {
 *         'pt-br': anotherPT
 *       }
 *     }
 *   };
 *
 *   beforeEach(async(() => {
 *     TestBed.configureTestingModule({
 *       declarations: [
 *         AppComponent
 *       ],
 *       imports: [
 *         HttpClientTestingModule,
 *         ThfI18nModule.config(config)
 *       ]
 *     }).compileComponents();
 *   }));
 *
 *   it('should create the app', async(() => {
 *     const fixture = TestBed.createComponent(AppComponent);
 *     const app = fixture.debugElement.componentInstance;
 *
 *     expect(app).toBeTruthy();
 *   }));
 *
 * });
 * ```
 */
class ThfI18nBaseService {
    /**
     * @param {?=} config
     * @param {?=} http
     * @param {?=} languageService
     */
    constructor(config, http, languageService) {
        this.config = config;
        this.http = http;
        this.languageService = languageService;
        this.varI18n = {};
        this.useCache = false;
        this.servicesContext = {};
        this.setConfig(config);
    }
    /**
     * <a id="get-language"></a>
     * Método que retorna o idioma padrão ativo.
     *
     * A busca deste idioma pelo método será feita na seguinte ordem:
     *
     *   1 - o idioma que foi armazenado no *localStorage*, através do método [`setLanguage()`](documentation/thf-i18n#setLanguage).
     *
     *   2 - o valor inserido no módulo do i18n através do parâmetro `config`, sendo o idioma inserido na propriedade
     * `language` da interface [`ThfI18nConfigDefault`](documentation/thf-i18n#thfI18nConfigDefault).
     *
     *   3 - o idioma do navegador utilizado.
     *
     * > Caso o idioma do navegador não seja suportado pelo THF (`pt`, `en` ou `es`), será retornado valor `pt`.
     *
     * **Retorno:**
     *
     * `string` com a sigla do idioma padrão.
     * @return {?}
     */
    getLanguage() {
        return this.languageService.getLanguage();
    }
    /**
     * Método que retorna o idioma padrão ativo, com somente a abreviação do idioma (duas primeiras letras).
     * Por exemplo: "pt" ou "es".
     *
     * A busca deste idioma é baseada no método [**getLanguage()**](/documentation/thf-i18n#get-language).
     *
     * **Retorno:**
     *
     * `string` com a sigla do idioma padrão.
     * @return {?}
     */
    getShortLanguage() {
        return this.languageService.getShortLanguage();
    }
    /**
     * <a id="setLanguage"></a>
     * Método para alterar o idioma padrão do módulo do i18n.
     *
     * Ao utilizar este método, o idioma ficará gravado no armazenamento local do navegador, que será utilizado pelo
     * serviço do `i18n` para buscar as literais no idioma padrão.
     *
     * @param {?} language {string} Sigla do idioma.
     *
     * Esta sigla deve ser composta por duas letras representando o idioma,
     * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
     *
     * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
     *
     * @param {?=} reload {boolean} Indica se a página atual poderá ser recarregada após a alteração do idioma.
     *
     * Este recurso pode ser útil para os usuários que utilizam o método `getLiterals()` do serviço do i18n para poder
     * buscar novamente as literais no novo idioma configurado.
     * @return {?}
     */
    setLanguage(language, reload) {
        if (!isLanguage(language)) {
            return;
        }
        this.languageService.setLanguage(language);
        if (reload) {
            reloadCurrentPage();
        }
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        // Seta as configurações padrões definidas no importação do módulo
        if (config['default']) {
            this.languageService.setLanguageDefault(config['default']['language']);
            this.contextDefault = (config['default']['context']) ? config['default']['context'] : '';
            this.useCache = (config['default']['cache']) ? config['default']['cache'] : false;
        }
        // Carrega a lista dos contextos e as contantes informadas
        if (config['contexts']) {
            this.setVarI18n(config['contexts']);
            // Se nenhum contexto foi definido como padrão,
            // então define o primeiro contexto
            if (!this.contextDefault) {
                for (const context in config['contexts']) {
                    if (this.config['contexts'].hasOwnProperty(context)) {
                        this.contextDefault = context;
                        break;
                    }
                }
            }
        }
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    getLiterals(options = {}) {
        /** @type {?} */
        const language = options['language'] ? options['language'].toLowerCase() : this.getLanguage();
        /** @type {?} */
        const context = (options['context']) ? options['context'] : this.contextDefault;
        /** @type {?} */
        const literals = (options['literals']) ? options['literals'] : [];
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            if (this.servicesContext[context]) {
                // Faz o processo de busca de um contexto que contém serviço
                this.getLiteralsFromContextService(language, context, literals, observer);
            }
            else {
                // Faz o processo de busca de um contexto que utiliza constante
                this.getLiteralsFromContextConstant(language, context, literals, observer);
            }
        }));
    }
    // Processo de busca de um contexto que contém serviço.
    //    1 - Procura na variável I18n deste serviço
    //    2 - Procura no local storage (Se o cache estiver definido como true na configuração do módulo)
    //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
    //    4 - Se nenhuma literal for encontrada, então busca em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    getLiteralsFromContextService(language, context, literals, observer, translations = {}, languageAlternative = null) {
        // Idioma usado para tentar buscar as literais faltantes
        /** @type {?} */
        const languageSearch = (languageAlternative) ? languageAlternative : language;
        translations = this.mergeObject(translations, this.searchInVarI18n(languageSearch, context, literals));
        if (this.countObject(translations) > 0) {
            observer.next(translations);
        }
        // realiza a busca no localStorage e em seguida no serviço
        this.getLiteralsLocalStorageAndCache(languageSearch, context, literals, observer, translations, languageAlternative);
    }
    // Procura no local storage e em seguida no serviço
    // Caso não encontre nem no serviço, recomeça a busca em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    getLiteralsLocalStorageAndCache(language, context, literals, observer, translations, languageAlternative = null) {
        /** @type {?} */
        const languageSearch = (languageAlternative) ? languageAlternative : language;
        /** @type {?} */
        let translationTemp;
        // Verifica se usa cache
        if (this.useCache) {
            translationTemp = this.searchInLocalStorage(languageSearch, context, literals);
            if (this.countObject(translationTemp) > 0) {
                this.updateVarI18n(language, context, translationTemp);
                translations = this.mergeObject(translationTemp, translations);
                observer.next(translations);
            }
        }
        // Busca do Serviço
        this.getHttpService(this.servicesContext[context], languageSearch, literals)
            .subscribe((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            if (response) {
                this.updateLocalStorage(language, context, response);
                this.updateVarI18n(language, context, response);
                translationTemp = this.searchInVarI18n(language, context, literals);
                translations = this.mergeObject(translationTemp, translations);
                observer.next(translations);
            }
            // Se não encontrou todas as literais pesquisadas no idioma
            // Então refaz o processo procurando em português
            if (literals.length > this.countObject(translations)) {
                if (languageAlternative === 'pt-br') {
                    // Se não encontrou nem em português, então retorna o nome das literais
                    translations = this.completeFaultLiterals(language, context, literals, translations);
                    this.updateLocalStorage(language, context, translations);
                    this.updateVarI18n(language, context, translations);
                    observer.next(translations);
                }
                else {
                    this.getLiteralsFromContextService(language, context, literals, observer, translations, 'pt-br');
                }
            }
        }));
    }
    // Procura pela lista de literais
    // Se não encontrar todas, procura em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @return {?}
     */
    getLiteralsFromContextConstant(language, context, literals, observer, translations = {}) {
        translations = this.mergeObject(translations, this.searchInVarI18n(language, context, literals));
        if (this.countObject(translations) > 0) {
            observer.next(translations);
        }
        // Se foi pesquisado por literais
        if (literals.length > 0) {
            // Se não encontrou todas as literais pesquisadas no idioma, procura em português
            if (literals.length > this.countObject(translations)) {
                if (language === 'pt-br') {
                    // Se não encontrou nem em português, então retorna o nome das literais
                    translations = this.completeFaultLiterals(language, context, literals, translations);
                    observer.next(translations);
                }
                else {
                    this.getLiteralsFromContextConstant('pt-br', context, literals, observer, translations);
                }
            }
        }
        else {
            // Se não encontrar nenhuma literal, procura em português
            if (this.countObject(translations) === 0 && language !== 'pt-br') {
                this.getLiteralsFromContextConstant('pt-br', context, literals, observer, translations);
            }
            // caso não informar literais e não houver tradução
            observer.next(translations);
            observer.complete();
        }
    }
    // Busca pelas literais no local storage
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    searchInLocalStorage(language, context, literals) {
        /** @type {?} */
        const translations = {};
        if (literals.length > 0) {
            for (let i = 0; i < literals.length; i++) {
                /** @type {?} */
                const literal = literals[i];
                /** @type {?} */
                const translation = localStorage.getItem(language + '-' + context + '-' + literal);
                if (translation) {
                    translations[literal] = translation;
                }
            }
        }
        return translations;
    }
    // Busca pelas literais na variável do serviço
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    searchInVarI18n(language, context, literals) {
        /** @type {?} */
        let translations = {};
        if (this.varI18n[language] && this.varI18n[language][context]) {
            /** @type {?} */
            const content = this.varI18n[language][context];
            if (literals.length > 0) {
                // Busca as literais desejadas
                for (let i = 0; i < literals.length; i++) {
                    /** @type {?} */
                    const literal = literals[i];
                    if (content.hasOwnProperty(literal)) {
                        translations[literal] = content[literal];
                    }
                }
            }
            else {
                // Atribui todas as literais
                translations = Object.assign({}, content);
            }
        }
        return translations;
    }
    // Atualiza o local storage
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    updateLocalStorage(language, context, data) {
        if (this.useCache) {
            for (const literal in data) {
                if (data.hasOwnProperty(literal)) {
                    localStorage.setItem(language + '-' + context + '-' + literal, data[literal]);
                }
            }
        }
    }
    // Atualiza a variável local com as literais com os objetos passados na configuração
    /**
     * @private
     * @param {?} contexts
     * @return {?}
     */
    setVarI18n(contexts) {
        // Percorre os contextos
        for (const context in contexts) {
            if (contexts.hasOwnProperty(context)) {
                /** @type {?} */
                const contextContent = contexts[context];
                // Percorre os idiomas dentro do contexto
                for (const language in contextContent) {
                    if (contextContent.hasOwnProperty(language)) {
                        /** @type {?} */
                        const languageContent = contextContent[language];
                        if (language === 'url') {
                            this.servicesContext[context] = languageContent;
                        }
                        else {
                            this.updateVarI18n(language, context, languageContent);
                        }
                    }
                }
            }
        }
    }
    // Atualiza a variável local com as literais idioma e contexto
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    updateVarI18n(language, context, data) {
        language = language.toLowerCase();
        if (!this.varI18n[language]) {
            this.varI18n[language] = { [context]: {} };
        }
        if (!this.varI18n[language][context]) {
            this.varI18n[language][context] = {};
        }
        // Cria ou atualiza o contexto dentro do storage
        this.varI18n[language][context] = this.mergeObject(data, this.varI18n[language][context]);
    }
    /**
     * @private
     * @param {?} url
     * @param {?} language
     * @param {?} literals
     * @return {?}
     */
    getHttpService(url, language, literals) {
        /** @type {?} */
        let param = '?language=' + language;
        if (literals.length > 0) {
            param += '&literals=' + literals.join();
        }
        // Remove a barra final do endereço
        url = (url.lastIndexOf('/') === url.length - 1) ? url.substr(0, url.length - 1) : url;
        return this.http.get(url + param);
    }
    // Completa com o nome da literais, as que não foram encontradas
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} translations
     * @return {?}
     */
    completeFaultLiterals(language, context, literals, translations) {
        for (let i = 0; i < literals.length; i++) {
            /** @type {?} */
            const literal = literals[i];
            if (!translations[literal]) {
                translations[literal] = literal;
            }
        }
        return translations;
    }
    // Conta os atributos do objeto
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    countObject(obj) {
        return Object.keys(obj).length;
    }
    // Faz o merge dos objetos, sempre dando preferência para o primeiro objeto de parâmetro
    /**
     * @private
     * @param {?} objPermanent
     * @param {?} obj
     * @return {?}
     */
    mergeObject(objPermanent, obj) {
        return Object.assign({}, obj, objPermanent);
    }
}
/** @nocollapse */
ThfI18nBaseService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [I18N_CONFIG,] }] },
    { type: HttpClient, decorators: [{ type: Inject, args: [HttpClient,] }] },
    { type: ThfLanguageService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfI18nBaseService
 */
class ThfI18nService extends ThfI18nBaseService {
}
ThfI18nService.decorators = [
    { type: Injectable }
];
// Função usada para retornar instância para o módulo thf-i18n.module
/**
 * @param {?} config
 * @param {?} http
 * @param {?} languageService
 * @return {?}
 */
function returnThfI18nService(config, http, languageService) {
    return new ThfI18nService(config, http, languageService);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do serviço `ThfI18nService` para controle de idiomas com THF.
 *
 * Para utilização do serviço de idiomas `ThfI18nService`, deve-se importar este módulo mesmo já havendo importado
 * o módulo `ThfModule`. Na importação deve ser invocado o método `config`, informando um objeto que deve implementar
 * a interface [`ThfI18nConfig`](documentation/thf-i18n#thfI18nConfig) para configuração.
 *
 * <a id="i18n-config"></a>
 * **Exemplo de configuração do módulo do i18n:**
 * ```
 * import { ThfI18nConfig } from '\@totvs/thf-ui';
 *
 * import { generalEn } from './i18n/general-en';
 * import { generalPt } from './i18n/general-pt';
 *
 * const i18nConfig: ThfI18nConfig = {
 *   default: {
 *     language: 'pt-BR',
 *     context: 'general',
 *     cache: true
 *   },
 *   contexts: {
 *     general: {
 *       'pt-BR': generalPt,
 *       'en-US': generalEn
 *     },
 *     hcm: {
 *       url: 'http://10.1.1.1/api/translations/hcm/'
 *     }
 *   }
 * };
 *
 * \@NgModule({
 *   declarations: [],
 *   imports: [
 *     ThfModule,
 *     ThfI18nModule.config(i18nConfig)
 *   ],
 *   bootstrap: [AppComponent]
 * })
 * ```
 *
 * Para cada contexto é possível definir a origem das literais, que podem ser de um serviço REST ou
 * de um objeto. Exemplo:
 *
 * Arquivo general-pt.ts
 * ```
 * export const generalPt = {
 *  add: 'Adicionar',
 *  greeting: 'Prazer, {0} {1}',
 *  people: '{0} Pessoas,
 *  remove: 'Remover'
 * }
 * ```
 *
 * Arquivo general-en.ts
 * ```
 * export const generalEn = {
 *  add: 'Add',
 *  greeting: 'Nice to meet you, {0} {1}',
 *  people: '{0} People,
 *  remove: 'Remove'
 * }
 * ```
 *
 * **Exemplo de configuração de contextos usando constantes externas:**
 * ```
 * import { ThfI18nConfig } from '\@totvs/thf-ui';
 *
 * import { generalEn } from './i18n/general-en';
 * import { generalPt } from './i18n/general-pt';
 *
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: {
 *       'pt-BR': generalPt, // constantes em arquivos separados
 *       'en-US': generalEn // constantes em arquivos separados
 *     },
 *     crm: {
 *       url: 'http://10.0.0.1:3000/api/translations/crm'
 *     }
 *   },
 *   default: {}
 * }
 * ```
 *
 * **Exemplo de configuração de um contexto utilizando serviço:**
 *
 * Ao optar por utilizar um serviço para configuração de contexto, deverá ser definida a URL
 * específica do contexto, como nos exemplos abaixo:
 *
 *  - http://10.0.0.1:3000/api/translations/crm
 *  - http://10.0.0.1:3000/api/translations/general
 *
 * Os idiomas e literais serão automaticamente buscados com parâmetros na própria URL:
 * - **language**: o idioma será sempre passado por parâmetro e é recomendado utilizar uma das linguagens
 * suportadas pelo THF (`pt-br`, `en-us` ou `es-es`).
 * - **literals**: as literais serão separadas por vírgula. Caso esse parâmetro não seja informado, o
 * serviço deve retornar todas as literais do idioma.
 *
 * Exemplos de requisição:
 *
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br&literals=add,remove,text
 *
 * > Sempre que o idioma solicitado não for encontrado, será buscado por `pt-br`.
 *
 * Além dos contextos, é possível definir as configurações *default* do sistema na configuração do
 * módulo utilizando a interface [`ThfI18nConfig`](documentation/thf-i18n#thfI18nConfig):
 *
 * **Exemplo de padrões definidos:**
 * ```
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: { }
 *   },
 *   default: {
 *    language: 'pt-BR',
 *    context: 'general',
 *    cache: true
 *   }
 * }
 * ```
 *
 * **Importante:**
 *
 * Recomenda-se que as definições *default* sejam realizadas apenas uma vez na aplicação,
 * preferencialmente no módulo `AppModule`.
 *
 * **i18n com *Lazy loading***
 *
 * Para aplicações que utilizem a abordagem de módulos com carregamento *lazy loading*, caso seja
 * definida outra configuração do `ThfI18nModule`, deve-se atentar os seguintes detalhes:
 *
 * - Caso existam literais comuns na aplicação, estas devem ser reimportadas;
 * - Não defina outra *default language* para este módulo. Caso for definida, será sobreposta para
 * toda a aplicação;
 * - Caso precise de módulos carregados via *lazy loading* com linguagens diferentes, utilize o
 * método [`setLanguage()`](documentation/thf-i18n#setLanguage) disponibilizado pelo `ThfI18nService`
 * para definir a linguagem da aplicação e dos módulos com as linguagens diferentes.
 */
class ThfI18nModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static config(config) {
        return {
            ngModule: ThfI18nModule,
            providers: [
                {
                    provide: I18N_CONFIG,
                    useValue: config
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: initializeLanguageDefault,
                    multi: true,
                    deps: [I18N_CONFIG, ThfLanguageService]
                },
                {
                    provide: ThfI18nService,
                    useFactory: returnThfI18nService,
                    deps: [I18N_CONFIG, HttpClient, ThfLanguageService]
                }
            ]
        };
    }
}
ThfI18nModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule,
                    ThfLanguageModule
                ]
            },] }
];
/**
 * @param {?} config
 * @param {?} languageService
 * @return {?}
 */
function initializeLanguageDefault(config, languageService) {
    // tslint:disable-next-line:prefer-immediate-return
    /** @type {?} */
    const setDefaultLanguage = (/**
     * @return {?}
     */
    () => {
        if (config.default.language) {
            languageService.setLanguageDefault(config.default.language);
        }
    });
    return setDefaultLanguage;
}

export { ThfAvatarComponent, ThfAvatarModule, ThfBreadcrumbComponent, ThfBreadcrumbModule, ThfButtonComponent, ThfButtonGroupComponent, ThfButtonGroupModule, ThfButtonGroupToggle, ThfButtonModule, ThfCalendarComponent, ThfCalendarModule, ThfChartComponent, ThfChartModule, ThfChartType, ThfCheckboxGroupComponent, ThfComboComponent, ThfComboFilterMode, ThfComponentInjectorModule, ThfComponentInjectorService, ThfComponentsModule, ThfContainerComponent, ThfContainerModule, ThfDatepickerComponent, ThfDatepickerRangeComponent, ThfDecimalComponent, ThfDialogModule, ThfDialogService, ThfDialogType, ThfDirectivesModule, ThfDisclaimerGroupComponent, ThfDisclaimerGroupModule, ThfDisclaimerModule, ThfDividerComponent, ThfDividerModule, ThfDropdownComponent, ThfDropdownModule, ThfDynamicFieldType, ThfDynamicFormComponent, ThfDynamicModule, ThfDynamicViewComponent, ThfEmailComponent, ThfFieldModule, ThfGridComponent, ThfGridModule, ThfGuardsModule, ThfHttpInterceptorModule, ThfHttpInterceptorService, ThfHttpRequestInterceptorService, ThfHttpRequestModule, ThfI18nModule, ThfI18nPipe, ThfI18nService, ThfInfoComponent, ThfInfoModule, ThfInfoOrientation, ThfInputComponent, ThfInterceptorsModule, ThfListViewComponent, ThfListViewContentTemplateDirective, ThfListViewDetailTemplateDirective, ThfListViewModule, ThfLoadingModule, ThfLoadingOverlayComponent, ThfLoginComponent, ThfLookupComponent, ThfMenuComponent, ThfMenuModule, ThfMenuPanelComponent, ThfMenuPanelModule, ThfModalComponent, ThfModalModule, ThfModule, ThfMultiselectComponent, ThfMultiselectFilterMode, ThfNavbarComponent, ThfNavbarModule, ThfNotificationModule, ThfNotificationService, ThfNumberComponent, ThfPageDefaultComponent, ThfPageDetailComponent, ThfPageEditComponent, ThfPageListComponent, ThfPageModule, ThfPasswordComponent, ThfPipesModule, ThfPopoverComponent, ThfPopoverModule, ThfPopupComponent, ThfPopupModule, ThfRadioGroupComponent, ThfRichTextComponent, ThfSelectComponent, ThfSelectOptionTemplateDirective, ThfServicesModule, ThfSlideComponent, ThfSlideModule, ThfStepComponent, ThfStepperComponent, ThfStepperModule, ThfStepperOrientation, ThfStepperStatus, ThfSwitchComponent, ThfSwitchLabelPosition, ThfTabComponent, ThfTableComponent, ThfTableModule, ThfTableRowTemplateDirective, ThfTabsComponent, ThfTabsModule, ThfTagComponent, ThfTagModule, ThfTagOrientation, ThfTagType, ThfTextareaComponent, ThfTimeModule, ThfTimePipe, ThfToasterOrientation, ThfToasterType, ThfToolbarComponent, ThfToolbarModule, ThfTooltipDirective, ThfTooltipModule, ThfUploadComponent, ThfUrlComponent, ThfWidgetComponent, ThfWidgetModule, initializeLanguageDefault, returnThfI18nService, ThfAvatarBaseComponent as ɵa, ThfBreadcrumbBaseComponent as ɵb, ThfInfoBaseComponent as ɵba, ThfLanguageModule as ɵbb, ThfLanguageService as ɵbc, ThfLoadingComponent as ɵbd, ThfLoadingBaseComponent as ɵbe, ThfLoadingOverlayBaseComponent as ɵbf, ThfModalBaseComponent as ɵbg, ThfModalService as ɵbh, ThfTableBaseComponent as ɵbi, ThfTableColumnIconComponent as ɵbj, ThfTableColumnLabelComponent as ɵbk, ThfColorPaletteService as ɵbl, ThfTableColumnLinkComponent as ɵbm, ThfTableDetailComponent as ɵbn, ThfTableShowSubtitleComponent as ɵbo, ThfTableSubtitleCircleComponent as ɵbp, ThfTableSubtitleFooterComponent as ɵbq, ThfCheckboxGroupBaseComponent as ɵbr, ThfCleanComponent as ɵbs, ThfCleanBaseComponent as ɵbt, ThfComboBaseComponent as ɵbu, ThfComboFilterService as ɵbv, ThfInputBaseComponent as ɵbw, ThfDatepickerBaseComponent as ɵbx, ThfDatepickerRangeBaseComponent as ɵby, ThfInputGeneric as ɵbz, ThfBreadcrumbDropdownComponent as ɵc, ThfLookupBaseComponent as ɵca, ThfLookupFilterService as ɵcb, ThfLookupModalService as ɵcc, ThfLookupModalComponent as ɵcd, ThfLookupModalBaseComponent as ɵce, ThfMultiselectBaseComponent as ɵcf, ThfNumberBaseComponent as ɵcg, ThfRadioGroupBaseComponent as ɵch, ThfRichTextBaseComponent as ɵci, ThfSelectBaseComponent as ɵcj, ThfSwitchBaseComponent as ɵck, ThfTextareaBaseComponent as ɵcl, ThfUploadBaseComponent as ɵcm, ThfUploadService as ɵcn, ThfUploadBaseService as ɵco, ThfCalendarComponent$1 as ɵcp, ThfCalendarService$1 as ɵcq, ThfCalendarLangService$1 as ɵcr, ThfFieldContainerComponent as ɵcs, ThfFieldContainerBottomComponent as ɵct, ThfMultiselectDropdownComponent as ɵcu, ThfMultiselectItemComponent as ɵcv, ThfMultiselectSearchComponent as ɵcw, ThfRichTextBodyComponent as ɵcx, ThfRichTextToolbarComponent as ɵcy, ThfTagBaseComponent as ɵcz, ThfBreadcrumbFavoriteComponent as ɵd, ThfDynamicFormBaseComponent as ɵda, ThfDynamicFormFieldsComponent as ɵdb, ThfDynamicFormFieldsBaseComponent as ɵdc, ThfDynamicViewBaseComponent as ɵdd, ThfGridCellActionComponent as ɵde, ThfGridCellComponent as ɵdf, ThfGridHeadComponent as ɵdg, ThfListViewBaseComponent as ɵdh, ThfBadgeModule as ɵdi, ThfBadgeComponent as ɵdj, ThfBadgeBaseComponent as ɵdk, ThfMenuBaseComponent as ɵdl, ThfMenuService as ɵdm, ThfMenuItemsService as ɵdn, ThfMenuHeaderTemplateDirective as ɵdo, ThfMenuFilterComponent as ɵdp, ThfMenuItemComponent as ɵdq, ThfMenuPanelBaseComponent as ɵdr, ThfMenuPanelItemsService as ɵds, ThfMenuPanelItemComponent as ɵdt, ThfNavbarActionsModule as ɵdu, ThfNavbarActionComponent as ɵdv, ThfNavbarActionPopupComponent as ɵdw, ThfNavbarActionsComponent as ɵdx, ThfNavbarItemsModule as ɵdy, ThfNavbarItemComponent as ɵdz, ThfBreadcrumbFavoriteService as ɵe, ThfNavbarItemsComponent as ɵea, ThfNavbarBaseComponent as ɵeb, ThfNavbarItemNavigationComponent as ɵec, ThfNavbarLogoComponent as ɵed, ThfPageComponent as ɵee, ThfPageBaseComponent as ɵef, ThfPageContentComponent as ɵeg, ThfPageContentBaseComponent as ɵeh, ThfPageDefaultBaseComponent as ɵei, ThfPageDetailBaseComponent as ɵej, ThfPageEditBaseComponent as ɵek, ThfPageHeaderComponent as ɵel, ThfPageHeaderBaseComponent as ɵem, ThfPageListBaseComponent as ɵen, ThfPopoverBaseComponent as ɵeo, ThfSlideCirclesComponent as ɵep, ThfSlideBaseComponent as ɵeq, ThfSlideContentTemplateDirective as ɵer, ThfSlideItemComponent as ɵes, ThfSlideControlComponent as ɵet, ThfStepperCircleComponent as ɵeu, ThfStepperBaseComponent as ɵev, ThfStepperLabelComponent as ɵew, ThfStepperStepComponent as ɵex, ThfTabButtonComponent as ɵey, ThfTabBaseComponent as ɵez, ThfBreadcrumbItemComponent as ɵf, ThfTabDropdownComponent as ɵfa, ThfTabsBaseComponent as ɵfb, ThfToolbarActionsComponent as ɵfc, ThfToolbarBaseComponent as ɵfd, ThfToolbarNotificationComponent as ɵfe, ThfToolbarProfileComponent as ɵff, ThfWidgetBaseComponent as ɵfg, ThfHttpInterceptorBaseService as ɵfh, ThfNotificationBaseService as ɵfi, ThfDialogBaseService as ɵfj, ThfHttpRequesControltService as ɵfk, ThfI18nBasePipe as ɵfl, ThfColorPaletteModule as ɵfm, ThfControlPositionModule as ɵfn, ThfDateTimeModule as ɵfo, ThfDialogComponent as ɵfp, ThfToasterComponent as ɵfq, ThfToasterBaseComponent as ɵfr, ThfI18nBaseService as ɵfs, I18N_CONFIG as ɵft, ThfButtonBaseComponent as ɵg, ThfTooltipBaseDirective as ɵh, ThfControlPositionService as ɵi, ThfButtonGroupBaseComponent as ɵj, ThfCalendarBaseComponent as ɵk, ThfDateService as ɵl, ThfCalendarLangService as ɵm, ThfCalendarService as ɵn, ThfDateService as ɵo, ThfChartBaseComponent as ɵp, ThfChartPieComponent as ɵq, ThfChartDynamicTypeComponent as ɵr, ThfContainerBaseComponent as ɵs, ThfDisclaimerComponent as ɵt, ThfDisclaimerBaseComponent as ɵu, ThfDisclaimerGroupBaseComponent as ɵv, ThfDisclaimerRemoveComponent as ɵw, ThfDividerBaseComponent as ɵx, ThfPopupBaseComponent as ɵy, ThfDropdownBaseComponent as ɵz };
//# sourceMappingURL=totvs-thf-ui.js.map
