/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter, Input, Output } from '@angular/core';
import { convertToBoolean, removeDuplicatedOptions, removeUndefinedAndNullOptions } from '../../../utils/util';
import { requiredFailed } from '../validators';
/**
 * \@description
 *
 * O componente thf-select exibe uma lista de valores e permite que o usuário selecione um desses valores.
 * Os valores listados podem ser fixos ou dinâmicos de acordo com a necessidade do desenvolvedor, dando mais flexibilidade ao componente.
 * O thf-select não permite que o usuário informe um valor diferente dos valores listados, isso garante a consistência da informação.
 * O thf-select não permite que sejam passados valores duplicados, undefined e null para as opções, excluindo-os da lista.
 *
 * > Ao passar um valor para o _model_ que não está na lista de opções, o mesmo será definido como `undefined`.
 *
 * Também existe a possibilidade de utilizar um _template_ para a exibição dos itens da lista,
 * veja mais em **[t-select-option-template](/documentation/thf-select-option-template)**.
 * @abstract
 */
export class ThfSelectBaseComponent {
    /**
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(element, changeDetector) {
        this.element = element;
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        /**
         * Deve ser informada uma função que será disparada quando houver alterações no ngModel.
         */
        this.change = new EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new EventEmitter();
        this.readyToValidation = false;
        this.element = element;
        this.changeDetector = changeDetector;
    }
    /**
     * Nesta propriedade deve ser definido uma coleção de objetos que implementam a interface ThfSelectOption.
     * Caso esta lista estiver vazia, o model será undefined.
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        this._options = options;
        removeDuplicatedOptions(this._options);
        removeUndefinedAndNullOptions(this._options);
        this.onUpdateOptions();
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será desabilitado.
     *
     * \@default `false`
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = convertToBoolean(disabled);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será somente para leitura.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    callModelChange(value) {
        // Caso o componente estiver dentro de um form, terá acesso ao método onModelChange.
        return (this.onModelChange) ? this.onModelChange(value) : this.ngModelChange.emit(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChange(value) {
        this.change.emit(value);
    }
    /**
     * @param {?} abstractControl
     * @return {?}
     */
    validate(abstractControl) {
        if (requiredFailed(this._required, this._disabled, abstractControl.value)) {
            return {
                required: {
                    valid: false,
                }
            };
        }
        return null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    validateModel() {
        if (this.onValidatorChange) {
            this.onValidatorChange();
        }
    }
}
ThfSelectBaseComponent.propDecorators = {
    label: [{ type: Input, args: ['t-label',] }],
    name: [{ type: Input, args: ['name',] }],
    help: [{ type: Input, args: ['t-help',] }],
    placeholder: [{ type: Input, args: ['t-placeholder',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    options: [{ type: Input, args: ['t-options',] }],
    change: [{ type: Output, args: ['t-change',] }],
    ngModelChange: [{ type: Output, args: ['ngModelChange',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    required: [{ type: Input, args: ['t-required',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    ThfSelectBaseComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    ThfSelectBaseComponent.prototype._options;
    /**
     * @type {?}
     * @private
     */
    ThfSelectBaseComponent.prototype._readonly;
    /**
     * @type {?}
     * @private
     */
    ThfSelectBaseComponent.prototype._required;
    /**
     * @type {?}
     * @private
     */
    ThfSelectBaseComponent.prototype.onValidatorChange;
    /**
     * Adiciona uma label no componente.
     * @type {?}
     */
    ThfSelectBaseComponent.prototype.label;
    /**
     * Nome do componente.
     * @type {?}
     */
    ThfSelectBaseComponent.prototype.name;
    /**
     * Texto de apoio para o campo.
     * @type {?}
     */
    ThfSelectBaseComponent.prototype.help;
    /**
     * Mensagem que aparecerá enquanto nenhuma opção estiver selecionada.
     * @type {?}
     */
    ThfSelectBaseComponent.prototype.placeholder;
    /**
     * \@optional
     *
     * \@description
     *
     * Define se a indicação de campo opcional será exibida.
     *
     * > Não será exibida a indicação se:
     * - O campo conter `t-required`;
     * - Não possuir `t-help` e/ou `t-label`.
     *
     * \@default `false`
     * @type {?}
     */
    ThfSelectBaseComponent.prototype.optional;
    /**
     * Deve ser informada uma função que será disparada quando houver alterações no ngModel.
     * @type {?}
     */
    ThfSelectBaseComponent.prototype.change;
    /** @type {?} */
    ThfSelectBaseComponent.prototype.ngModelChange;
    /** @type {?} */
    ThfSelectBaseComponent.prototype.changeDetector;
    /** @type {?} */
    ThfSelectBaseComponent.prototype.onModelChange;
    /** @type {?} */
    ThfSelectBaseComponent.prototype.onModelTouched;
    /** @type {?} */
    ThfSelectBaseComponent.prototype.readyToValidation;
    /**
     * @type {?}
     * @protected
     */
    ThfSelectBaseComponent.prototype.clickoutListener;
    /** @type {?} */
    ThfSelectBaseComponent.prototype.element;
    /**
     * @abstract
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.onUpdateOptions = function () { };
    /**
     * @abstract
     * @param {?} selectOption
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.updateModel = function (selectOption) { };
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.writeValue = function (value) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhmLXNlbGVjdC1iYXNlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0b3R2cy90aGYtdWkvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy90aGYtZmllbGQvdGhmLXNlbGVjdC90aGYtc2VsZWN0LWJhc2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQWlDLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSx1QkFBdUIsRUFBRSw2QkFBNkIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQy9HLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQWlCL0MsTUFBTSxPQUFnQixzQkFBc0I7Ozs7O0lBc0gxQyxZQUFtQixPQUFtQixFQUFFLGNBQWlDO1FBQXRELFlBQU8sR0FBUCxPQUFPLENBQVk7UUFwSDlCLGNBQVMsR0FBYSxLQUFLLENBQUM7UUFFNUIsY0FBUyxHQUFZLEtBQUssQ0FBQztRQUMzQixjQUFTLEdBQWEsS0FBSyxDQUFDOzs7O1FBK0NoQixXQUFNLEdBQXVCLElBQUksWUFBWSxFQUFPLENBQUM7O1FBR2hELGtCQUFhLEdBQXVCLElBQUksWUFBWSxFQUFPLENBQUM7UUEyRHJGLHNCQUFpQixHQUFZLEtBQUssQ0FBQztRQUtqQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztJQUN2QyxDQUFDOzs7Ozs7O0lBakZELElBQXdCLE9BQU8sQ0FBQyxPQUErQjtRQUM3RCxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztRQUN4Qix1QkFBdUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdkMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdDLElBQUks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Ozs7O0lBRzVCLHNDQUErQjs7Ozs7SUFHL0IsNkNBQTZDOzs7Ozs7Ozs7Ozs7Ozs7SUFlN0MsMENBQXVDOzs7OztJQWtCdkMsd0NBQXlFOztJQUd6RSwrQ0FBcUY7O0lBd0RyRixnREFBa0M7O0lBQ2xDLCtDQUFtQjs7SUFDbkIsZ0RBQW9COztJQUNwQixtREFBbUM7Ozs7O0lBRW5DLGtEQUF1Qzs7SUFFM0IseUNBQTBCOzs7OztJQTZDdEMsbUVBQWlDOzs7Ozs7SUFFakMsMkVBQTBEOzs7Ozs7SUFFMUQsbUVBQXNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBjb252ZXJ0VG9Cb29sZWFuLCByZW1vdmVEdXBsaWNhdGVkT3B0aW9ucywgcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi91dGlscy91dGlsJztcbmltcG9ydCB7IHJlcXVpcmVkRmFpbGVkIH0gZnJvbSAnLi4vdmFsaWRhdG9ycyc7XG5cbmltcG9ydCB7IFRoZlNlbGVjdE9wdGlvbiB9IGZyb20gJy4vdGhmLXNlbGVjdC1vcHRpb24uaW50ZXJmYWNlJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBPIGNvbXBvbmVudGUgdGhmLXNlbGVjdCBleGliZSB1bWEgbGlzdGEgZGUgdmFsb3JlcyBlIHBlcm1pdGUgcXVlIG8gdXN1w6FyaW8gc2VsZWNpb25lIHVtIGRlc3NlcyB2YWxvcmVzLlxuICogT3MgdmFsb3JlcyBsaXN0YWRvcyBwb2RlbSBzZXIgZml4b3Mgb3UgZGluw6JtaWNvcyBkZSBhY29yZG8gY29tIGEgbmVjZXNzaWRhZGUgZG8gZGVzZW52b2x2ZWRvciwgZGFuZG8gbWFpcyBmbGV4aWJpbGlkYWRlIGFvIGNvbXBvbmVudGUuXG4gKiBPIHRoZi1zZWxlY3QgbsOjbyBwZXJtaXRlIHF1ZSBvIHVzdcOhcmlvIGluZm9ybWUgdW0gdmFsb3IgZGlmZXJlbnRlIGRvcyB2YWxvcmVzIGxpc3RhZG9zLCBpc3NvIGdhcmFudGUgYSBjb25zaXN0w6puY2lhIGRhIGluZm9ybWHDp8Ojby5cbiAqIE8gdGhmLXNlbGVjdCBuw6NvIHBlcm1pdGUgcXVlIHNlamFtIHBhc3NhZG9zIHZhbG9yZXMgZHVwbGljYWRvcywgdW5kZWZpbmVkIGUgbnVsbCBwYXJhIGFzIG9ww6fDtWVzLCBleGNsdWluZG8tb3MgZGEgbGlzdGEuXG4gKlxuICogPiBBbyBwYXNzYXIgdW0gdmFsb3IgcGFyYSBvIF9tb2RlbF8gcXVlIG7Do28gZXN0w6EgbmEgbGlzdGEgZGUgb3DDp8O1ZXMsIG8gbWVzbW8gc2Vyw6EgZGVmaW5pZG8gY29tbyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBUYW1iw6ltIGV4aXN0ZSBhIHBvc3NpYmlsaWRhZGUgZGUgdXRpbGl6YXIgdW0gX3RlbXBsYXRlXyBwYXJhIGEgZXhpYmnDp8OjbyBkb3MgaXRlbnMgZGEgbGlzdGEsXG4gKiB2ZWphIG1haXMgZW0gKipbdC1zZWxlY3Qtb3B0aW9uLXRlbXBsYXRlXSgvZG9jdW1lbnRhdGlvbi90aGYtc2VsZWN0LW9wdGlvbi10ZW1wbGF0ZSkqKi5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRoZlNlbGVjdEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIHtcblxuICBwcml2YXRlIF9kaXNhYmxlZD86IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfb3B0aW9uczogQXJyYXk8VGhmU2VsZWN0T3B0aW9uPjtcbiAgcHJpdmF0ZSBfcmVhZG9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfcmVxdWlyZWQ/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBvblZhbGlkYXRvckNoYW5nZTtcblxuICAvKiogQWRpY2lvbmEgdW1hIGxhYmVsIG5vIGNvbXBvbmVudGUuICovXG4gIEBJbnB1dCgndC1sYWJlbCcpIGxhYmVsPzogc3RyaW5nO1xuXG4gIC8qKiBOb21lIGRvIGNvbXBvbmVudGUuICovXG4gIEBJbnB1dCgnbmFtZScpIG5hbWU6IHN0cmluZztcblxuICAvKiogVGV4dG8gZGUgYXBvaW8gcGFyYSBvIGNhbXBvLiAqL1xuICBASW5wdXQoJ3QtaGVscCcpIGhlbHA/OiBzdHJpbmc7XG5cbiAgLyoqIE1lbnNhZ2VtIHF1ZSBhcGFyZWNlcsOhIGVucXVhbnRvIG5lbmh1bWEgb3DDp8OjbyBlc3RpdmVyIHNlbGVjaW9uYWRhLiAqL1xuICBASW5wdXQoJ3QtcGxhY2Vob2xkZXInKSBwbGFjZWhvbGRlcj86IHN0cmluZztcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmUgc2UgYSBpbmRpY2HDp8OjbyBkZSBjYW1wbyBvcGNpb25hbCBzZXLDoSBleGliaWRhLlxuICAgKlxuICAgKiA+IE7Do28gc2Vyw6EgZXhpYmlkYSBhIGluZGljYcOnw6NvIHNlOlxuICAgKiAtIE8gY2FtcG8gY29udGVyIGB0LXJlcXVpcmVkYDtcbiAgICogLSBOw6NvIHBvc3N1aXIgYHQtaGVscGAgZS9vdSBgdC1sYWJlbGAuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIEBJbnB1dCgndC1vcHRpb25hbCcpIG9wdGlvbmFsOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBOZXN0YSBwcm9wcmllZGFkZSBkZXZlIHNlciBkZWZpbmlkbyB1bWEgY29sZcOnw6NvIGRlIG9iamV0b3MgcXVlIGltcGxlbWVudGFtIGEgaW50ZXJmYWNlIFRoZlNlbGVjdE9wdGlvbi5cbiAgICogQ2FzbyBlc3RhIGxpc3RhIGVzdGl2ZXIgdmF6aWEsIG8gbW9kZWwgc2Vyw6EgdW5kZWZpbmVkLlxuICAgKi9cbiAgQElucHV0KCd0LW9wdGlvbnMnKSBzZXQgb3B0aW9ucyhvcHRpb25zOiBBcnJheTxUaGZTZWxlY3RPcHRpb24+KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmVtb3ZlRHVwbGljYXRlZE9wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gICAgcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbE9wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gICAgdGhpcy5vblVwZGF0ZU9wdGlvbnMoKTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgLyoqIERldmUgc2VyIGluZm9ybWFkYSB1bWEgZnVuw6fDo28gcXVlIHNlcsOhIGRpc3BhcmFkYSBxdWFuZG8gaG91dmVyIGFsdGVyYcOnw7VlcyBubyBuZ01vZGVsLiAqL1xuICBAT3V0cHV0KCd0LWNoYW5nZScpIGNoYW5nZT86IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLy8gRnVuw6fDo28gcGFyYSBhdHVhbGl6YXIgbyBuZ01vZGVsIGRvIGNvbXBvbmVudGUsIG5lY2Vzc8OhcmlvIHF1YW5kbyBuw6NvIGZvciB1dGlsaXphZG8gZGVudHJvIGRhIHRhZyBmb3JtLlxuICBAT3V0cHV0KCduZ01vZGVsQ2hhbmdlJykgbmdNb2RlbENoYW5nZT86IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIGRlc2FiaWxpdGFkby5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCd0LWRpc2FibGVkJykgc2V0IGRpc2FibGVkKGRpc2FibGVkOiBzdHJpbmcgfCBib29sZWFuKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBjb252ZXJ0VG9Cb29sZWFuKGRpc2FibGVkKTtcblxuICAgIHRoaXMudmFsaWRhdGVNb2RlbCgpO1xuICB9XG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBJbmRpY2EgcXVlIG8gY2FtcG8gc2Vyw6Egc29tZW50ZSBwYXJhIGxlaXR1cmEuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIEBJbnB1dCgndC1yZWFkb25seScpIHNldCByZWFkb25seSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3JlYWRvbmx5ID0gY29udmVydFRvQm9vbGVhbih2YWx1ZSk7XG4gIH1cblxuICBnZXQgcmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRvbmx5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIG9icmlnYXTDs3Jpby5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCd0LXJlcXVpcmVkJylcbiAgc2V0IHJlcXVpcmVkKHJlcXVpcmVkOiBzdHJpbmcgfCBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVxdWlyZWQgPSBjb252ZXJ0VG9Cb29sZWFuKHJlcXVpcmVkKTtcblxuICAgIHRoaXMudmFsaWRhdGVNb2RlbCgpO1xuICB9XG4gIGdldCByZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7XG4gIH1cblxuICBjaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gIG9uTW9kZWxDaGFuZ2U6IGFueTtcbiAgb25Nb2RlbFRvdWNoZWQ6IGFueTtcbiAgcmVhZHlUb1ZhbGlkYXRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgY2xpY2tvdXRMaXN0ZW5lcjogKCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZiwgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gIH1cblxuICBjYWxsTW9kZWxDaGFuZ2UodmFsdWU6IGFueSkge1xuICAgIC8vIENhc28gbyBjb21wb25lbnRlIGVzdGl2ZXIgZGVudHJvIGRlIHVtIGZvcm0sIHRlcsOhIGFjZXNzbyBhbyBtw6l0b2RvIG9uTW9kZWxDaGFuZ2UuXG4gICAgcmV0dXJuICh0aGlzLm9uTW9kZWxDaGFuZ2UpID8gdGhpcy5vbk1vZGVsQ2hhbmdlKHZhbHVlKSA6IHRoaXMubmdNb2RlbENoYW5nZS5lbWl0KHZhbHVlKTtcbiAgfVxuXG4gIG9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5jaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gIH1cblxuICB2YWxpZGF0ZShhYnN0cmFjdENvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IHsgW2tleTogc3RyaW5nXTogYW55OyB9IHtcblxuICAgIGlmIChyZXF1aXJlZEZhaWxlZCh0aGlzLl9yZXF1aXJlZCwgdGhpcy5fZGlzYWJsZWQsIGFic3RyYWN0Q29udHJvbC52YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogYW55KSB7XG4gICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSA9IGZuO1xuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZU1vZGVsKCkge1xuICAgIGlmICh0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKSB7XG4gICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgYWJzdHJhY3Qgb25VcGRhdGVPcHRpb25zKCk6IHZvaWQ7XG5cbiAgYWJzdHJhY3QgdXBkYXRlTW9kZWwoc2VsZWN0T3B0aW9uOiBUaGZTZWxlY3RPcHRpb24pOiB2b2lkO1xuXG4gIGFic3RyYWN0IHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG5cbn1cbiJdfQ==