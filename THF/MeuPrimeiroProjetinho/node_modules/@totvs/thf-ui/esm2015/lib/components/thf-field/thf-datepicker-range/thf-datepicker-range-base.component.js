/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter, Input, Output } from '@angular/core';
import { browserLanguage, convertToBoolean, thfLocaleDefault } from './../../../utils/util';
import { requiredFailed } from '../validators';
/** @type {?} */
export const thfDatepickerRangeLiteralsDefault = {
    en: (/** @type {?} */ ({
        invalidFormat: 'Date in invalid format',
        startDateGreaterThanEndDate: 'Start date greater than end date',
    })),
    es: (/** @type {?} */ ({
        invalidFormat: 'Fecha en formato no válido',
        startDateGreaterThanEndDate: 'Fecha de inicio mayor que fecha final',
    })),
    pt: (/** @type {?} */ ({
        invalidFormat: 'Data no formato inválido',
        startDateGreaterThanEndDate: 'Data inicial maior que data final',
    }))
};
/**
 * \@description
 *
 * O `thf-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `thf-datepicker-range` trabalha com um objeto que implementa a interface
 * `ThfDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `t-start-date` e `t-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 * @abstract
 */
export class ThfDatepickerRangeBaseComponent {
    /**
     * @param {?} thfDateService
     */
    constructor(thfDateService) {
        this.thfDateService = thfDateService;
        this.errorMessage = '';
        this._clean = false;
        this._readonly = false;
        this._required = false;
        this.dateRange = { start: '', end: '' };
        this.format = 'dd/mm/yyyy';
        this.isDateRangeInputFormatValid = true;
        this.isStartDateRangeInputValid = true;
        /**
         * \@optional
         *
         * \@description
         *
         * Evento disparado ao alterar valor do campo.
         */
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isDateRangeInputValid() {
        return this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Habilita ação para limpar o campo.
     *
     * \@default `false`
     * @param {?} clean
     * @return {?}
     */
    set clean(clean) {
        this._clean = convertToBoolean(clean);
    }
    /**
     * @return {?}
     */
    get clean() {
        return this._clean;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita o campo.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data final.
     * @param {?} date
     * @return {?}
     */
    set endDate(date) {
        this._endDate = this.convertPatternDateFormat(date);
        this.dateRange.end = this.endDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get endDate() {
        return this._endDate;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `thf-datepicker-range`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: ThfDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format',
     *    startDateGreaterThanEndDate: 'End date less than start date'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: ThfDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <thf-datepicker-range
     *   [t-literals]="customLiterals">
     * </thf-datepicker-range>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, thfDatepickerRangeLiteralsDefault[thfLocaleDefault], thfDatepickerRangeLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = thfDatepickerRangeLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || thfDatepickerRangeLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será somente leitura.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data inicial.
     * @param {?} date
     * @return {?}
     */
    set startDate(date) {
        this._startDate = this.convertPatternDateFormat(date);
        this.dateRange.start = this.startDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get startDate() {
        return this._startDate;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangeModel = func;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouchedModel = func;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        const value = control.value || {};
        /** @type {?} */
        const startDate = value.start ? this.convertPatternDateFormat(value.start) : '';
        /** @type {?} */
        const endDate = value.end ? this.convertPatternDateFormat(value.end) : '';
        if (this.requiredDateRangeFailed(startDate, endDate)) {
            this.errorMessage = '';
            return { required: {
                    valid: false,
                } };
        }
        if (this.dateRangeObjectFailed(control.value) || this.dateRangeFormatFailed(startDate, endDate)) {
            this.errorMessage = this.literals.invalidFormat;
            return { date: {
                    valid: false,
                } };
        }
        if (this.dateRangeFailed(startDate, endDate)) {
            this.errorMessage = this.literals.startDateGreaterThanEndDate;
            return { date: {
                    valid: false,
                } };
        }
        return null;
    }
    /**
     * @param {?} dateRange
     * @return {?}
     */
    writeValue(dateRange) {
        this.resetDateRangeInputValidation();
        if (!dateRange || this.dateRangeObjectFailed(dateRange)) {
            this.dateRange = { start: '', end: '' };
        }
        if (!dateRange) {
            this.validateModel(this.dateRange);
        }
        if (this.dateRangeObjectFailed(dateRange)) {
            this.updateModel(dateRange);
        }
        if (this.isDateRangeObject(dateRange)) {
            this.dateRange = {
                start: this.convertPatternDateFormat(dateRange.start),
                end: this.convertPatternDateFormat(dateRange.end)
            };
            this.updateModel(this.dateRange);
        }
        this.updateScreenByModel(this.dateRange);
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    dateFormatFailed(value) {
        return value && !this.thfDateService.isValidIso(value);
    }
    // Executa a função onChange
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    updateModel(value) {
        /** @type {?} */
        const model = typeof (value) === 'object' ? Object.assign({}, value) : value;
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(model);
        }
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    validateModel(value) {
        /** @type {?} */
        const model = Object.assign({}, value);
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    convertPatternDateFormat(value) {
        if (value instanceof Date) {
            return this.thfDateService.convertDateToISO(value);
        }
        return value;
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    dateRangeFailed(startDate, endDate) {
        return !this.thfDateService.isDateRangeValid(endDate, startDate) || !this.isStartDateRangeInputValid;
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    dateRangeFormatFailed(startDate, endDate) {
        return this.dateFormatFailed(endDate) || this.dateFormatFailed(startDate) || !this.isDateRangeInputFormatValid;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    dateRangeObjectFailed(value) {
        return value && !this.isDateRangeObject(value);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isDateRangeObject(value) {
        return value && value.hasOwnProperty('start') && value.hasOwnProperty('end');
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    requiredDateRangeFailed(startDate, endDate) {
        return this.isDateRangeInputValid &&
            requiredFailed(this.required, this.disabled, startDate) &&
            requiredFailed(this.required, this.disabled, endDate);
    }
}
ThfDatepickerRangeBaseComponent.propDecorators = {
    clean: [{ type: Input, args: ['t-clean',] }],
    disabled: [{ type: Input, args: ['t-disabled',] }],
    endDate: [{ type: Input, args: ['t-end-date',] }],
    help: [{ type: Input, args: ['t-help',] }],
    label: [{ type: Input, args: ['t-label',] }],
    literals: [{ type: Input, args: ['t-literals',] }],
    optional: [{ type: Input, args: ['t-optional',] }],
    readonly: [{ type: Input, args: ['t-readonly',] }],
    required: [{ type: Input, args: ['t-required',] }],
    startDate: [{ type: Input, args: ['t-start-date',] }],
    onChange: [{ type: Output, args: ['t-change',] }]
};
if (false) {
    /** @type {?} */
    ThfDatepickerRangeBaseComponent.prototype.errorMessage;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._clean;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._endDate;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._literals;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._readonly;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._required;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._startDate;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype.onChangeModel;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype.validatorChange;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.dateRange;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.format;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.isDateRangeInputFormatValid;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.isStartDateRangeInputValid;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.onTouchedModel;
    /**
     * \@optional
     *
     * \@description
     *
     * Texto de apoio do campo.
     * @type {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.help;
    /**
     * \@optional
     *
     * \@description
     *
     * Rótulo do campo.
     * @type {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.label;
    /**
     * \@optional
     *
     * \@description
     *
     * Define se a indicação de campo opcional será exibida.
     *
     * > Não será exibida a indicação se:
     * - O campo conter `t-required`;
     * - Não possuir `t-help` e/ou `t-label`.
     *
     * \@default `false`
     * @type {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.optional;
    /**
     * \@optional
     *
     * \@description
     *
     * Evento disparado ao alterar valor do campo.
     * @type {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.onChange;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.thfDateService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.resetDateRangeInputValidation = function () { };
    /**
     * @abstract
     * @protected
     * @param {?} dateRange
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.updateScreenByModel = function (dateRange) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhmLWRhdGVwaWNrZXItcmFuZ2UtYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdG90dnMvdGhmLXVpLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvdGhmLWZpZWxkL3RoZi1kYXRlcGlja2VyLXJhbmdlL3RoZi1kYXRlcGlja2VyLXJhbmdlLWJhc2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFNUQsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVGLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBTS9DLE1BQU0sT0FBTyxpQ0FBaUMsR0FBRztJQUMvQyxFQUFFLEVBQUUsbUJBQTZCO1FBQy9CLGFBQWEsRUFBRSx3QkFBd0I7UUFDdkMsMkJBQTJCLEVBQUUsa0NBQWtDO0tBQ2hFLEVBQUE7SUFDRCxFQUFFLEVBQUUsbUJBQTZCO1FBQy9CLGFBQWEsRUFBRSw0QkFBNEI7UUFDM0MsMkJBQTJCLEVBQUUsdUNBQXVDO0tBQ3JFLEVBQUE7SUFDRCxFQUFFLEVBQUUsbUJBQTZCO1FBQy9CLGFBQWEsRUFBRSwwQkFBMEI7UUFDekMsMkJBQTJCLEVBQUUsbUNBQW1DO0tBQ2pFLEVBQUE7Q0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDRCxNQUFNLE9BQWdCLCtCQUErQjs7OztJQW9PbkQsWUFBc0IsY0FBOEI7UUFBOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBbE9wRCxpQkFBWSxHQUFXLEVBQUUsQ0FBQztRQUVsQixXQUFNLEdBQWEsS0FBSyxDQUFDO1FBSXpCLGNBQVMsR0FBWSxLQUFLLENBQUM7UUFDM0IsY0FBUyxHQUFhLEtBQUssQ0FBQztRQUsxQixjQUFT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QmxCLEtBQUssU0FBQyxRQUFRO29CQVNkLEtBQUssU0FBQyxTQUFTO3VCQW9DZixLQUFLLFNBQUMsWUFBWTt1QkE2QmxCLEtBQUssU0FBQyxZQUFZO3VCQVdsQixLQUFLLFNBQUMsWUFBWTt1QkFtQmxCLEtBQUssU0FBQyxZQUFZO3dCQWlCbEIsS0FBSyxTQUFDLGNBQWM7dUJBbUJwQixNQUFNLFNBQUMsVUFBVTs7OztJQWhPbEIsdURBQTBCOzs7OztJQUUxQixpREFBaUM7Ozs7O0lBQ2pDLG9EQUFtQjs7Ozs7SUFDbkIsbURBQWtCOzs7OztJQUNsQixvREFBd0I7Ozs7O0lBQ3hCLG9EQUFtQzs7Ozs7SUFDbkMsb0RBQW9DOzs7OztJQUNwQyxxREFBb0I7Ozs7O0lBQ3BCLHdEQUEyQjs7Ozs7SUFDM0IsMERBQTZCOzs7OztJQUU3QixvREFBaUU7Ozs7O0lBQ2pFLGlEQUFxQzs7Ozs7SUFDckMsc0VBQXNEOzs7OztJQUN0RCxxRUFBcUQ7Ozs7O0lBQ3JELHlEQUE4Qjs7Ozs7Ozs7O0lBb0U5QiwrQ0FBK0I7Ozs7Ozs7OztJQVMvQixnREFBaUM7Ozs7Ozs7Ozs7Ozs7OztJQWlFakMsbURBQXVDOzs7Ozs7Ozs7SUFrRXZDLG1EQUEyRTs7Ozs7SUFFL0QseURBQXdDOzs7Ozs7SUFFcEQsMEZBQXlEOzs7Ozs7O0lBRXpELHlGQUFzRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBicm93c2VyTGFuZ3VhZ2UsIGNvbnZlcnRUb0Jvb2xlYW4sIHRoZkxvY2FsZURlZmF1bHQgfSBmcm9tICcuLy4uLy4uLy4uL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgcmVxdWlyZWRGYWlsZWQgfSBmcm9tICcuLi92YWxpZGF0b3JzJztcblxuaW1wb3J0IHsgVGhmRGF0ZXBpY2tlclJhbmdlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3RoZi1kYXRlcGlja2VyLXJhbmdlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBUaGZEYXRlcGlja2VyUmFuZ2VMaXRlcmFscyB9IGZyb20gJy4vaW50ZXJmYWNlcy90aGYtZGF0ZXBpY2tlci1yYW5nZS1saXRlcmFscy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVGhmRGF0ZVNlcnZpY2UgfSBmcm9tICcuLy4uLy4uLy4uL3NlcnZpY2VzL3RoZi1kYXRlL3RoZi1kYXRlLnNlcnZpY2UnO1xuXG5leHBvcnQgY29uc3QgdGhmRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHNEZWZhdWx0ID0ge1xuICBlbjogPFRoZkRhdGVwaWNrZXJSYW5nZUxpdGVyYWxzPiB7XG4gICAgaW52YWxpZEZvcm1hdDogJ0RhdGUgaW4gaW52YWxpZCBmb3JtYXQnLFxuICAgIHN0YXJ0RGF0ZUdyZWF0ZXJUaGFuRW5kRGF0ZTogJ1N0YXJ0IGRhdGUgZ3JlYXRlciB0aGFuIGVuZCBkYXRlJyxcbiAgfSxcbiAgZXM6IDxUaGZEYXRlcGlja2VyUmFuZ2VMaXRlcmFscz4ge1xuICAgIGludmFsaWRGb3JtYXQ6ICdGZWNoYSBlbiBmb3JtYXRvIG5vIHbDoWxpZG8nLFxuICAgIHN0YXJ0RGF0ZUdyZWF0ZXJUaGFuRW5kRGF0ZTogJ0ZlY2hhIGRlIGluaWNpbyBtYXlvciBxdWUgZmVjaGEgZmluYWwnLFxuICB9LFxuICBwdDogPFRoZkRhdGVwaWNrZXJSYW5nZUxpdGVyYWxzPiB7XG4gICAgaW52YWxpZEZvcm1hdDogJ0RhdGEgbm8gZm9ybWF0byBpbnbDoWxpZG8nLFxuICAgIHN0YXJ0RGF0ZUdyZWF0ZXJUaGFuRW5kRGF0ZTogJ0RhdGEgaW5pY2lhbCBtYWlvciBxdWUgZGF0YSBmaW5hbCcsXG4gIH1cbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogTyBgdGhmLWRhdGVwaWNrZXItcmFuZ2VgIMOpIHVtIGNvbXBvbmVudGUgcGFyYSBzZWxlw6fDo28gZGUgdW0gcGVyw61vZG8gZW50cmUgZHVhcyBkYXRhcywgb25kZSDDqSBwb3Nzw612ZWwgaW5mb3JtYXIgYXBlbmFzXG4gKiBhIGRhdGEgaW5pY2lhbCBvdSBhIGRhdGEgZmluYWwuXG4gKlxuICogTyBjb21wb25lbnRlIGBbKG5nTW9kZWwpXWAgZG8gYHRoZi1kYXRlcGlja2VyLXJhbmdlYCB0cmFiYWxoYSBjb20gdW0gb2JqZXRvIHF1ZSBpbXBsZW1lbnRhIGEgaW50ZXJmYWNlXG4gKiBgVGhmRGF0ZXBpY2tlclJhbmdlYCwgY29udGVuZG8gYXMgc2VndWludGVzIHByb3ByaWVkYWRlczpcbiAqIGBgYFxuICogeyBcInN0YXJ0XCI6ICcyMDE3LTExLTI4JywgXCJlbmRcIjogJzIwMTctMTEtMzAnIH1cbiAqIGBgYFxuICpcbiAqIDxhIGlkPVwiYWNjZXB0ZWQtZm9ybWF0c1wiPjwvYT5cbiAqIEVzdGUgY29tcG9uZW50ZSBwb2RlIHJlY2ViZXIgb3Mgc2VndWludGVzIGZvcm1hdG9zIGRlIGRhdGE6XG4gKlxuICogLSAqKkRhdGEgZSBob3JhIGNvbWJpbmFkb3MgKEU4NjAxRFp3KTogeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tKipcbiAqIGBgYFxuICogJzIwMTctMTEtMjhUMDA6MDA6MDAtMDI6MDAnO1xuICogYGBgXG4gKlxuICogLSAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKlxuICogYGBgXG4gKiAnMjAxNy0xMS0yOCc7XG4gKiBgYGBcbiAqXG4gKiAtICoqSmF2YVNjcmlwdCBEYXRlIE9iamVjdDoqKlxuICogYGBgXG4gKiBuZXcgRGF0ZSgyMDE3LCAxMCwgMjgpO1xuICogYGBgXG4gKlxuICogPiBPIGNvbXBvbmVudGUgcmVzcGVpdGFyw6EgbyBmb3JtYXRvIHBhc3NhZG8gcGFyYSBvICptb2RlbCogdmlhIGNvZGlmaWNhw6fDo28uIFBvcsOpbSwgY2FzbyBzZWphIGZlaXRhIGFsdGVyYcOnw6NvIGVtIGFsZ3VtXG4gKiBkb3MgdmFsb3JlcyBkZSBkYXRhIGVtIHRlbGEsIG8gY29tcG9uZW50ZSBhdHJpYnVpcsOhIG8gZm9ybWF0byAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKiBhbyBtb2RlbC5cbiAqXG4gKiBJbXBvcnRhbnRlOlxuICpcbiAqIC0gUXVhbmRvIHByZWVuY2hpZGFzIGEgZGF0YSBpbmljaWFsIGUgZmluYWwsIGEgZGF0YSBpbmljaWFsIGRldmUgc2VyIHNlbXByZSBtZW5vciBvdSBpZ3VhbCBhIGRhdGEgZmluYWw7XG4gKiAtIEFvIHBhc3NhciB1bWEgZGF0YSBpbnbDoWxpZGEgdmlhIGNvZGlmaWNhw6fDo28sIG8gdmFsb3Igc2Vyw6EgbWFudGlkbyBubyAqbW9kZWwqIGUgbyBgaW5wdXRgIGRhIHRlbGEgYXBhcmVjZXLDoSB2YXppbztcbiAqIC0gUGVybWl0ZSB0cmFiYWxoYXIgY29tIGFzIGR1YXMgZGF0YXMgc2VwYXJhZGFtZW50ZSBhdHJhdsOpcyBkYXMgcHJvcHJpZWRhZGVzIGB0LXN0YXJ0LWRhdGVgIGUgYHQtZW5kLWRhdGVgIG5vIGx1Z2FyIGRvXG4gKiBgWyhuZ01vZGVsKV1gLCBubyBlbnRhbnRvIHNlbSBhIHZhbGlkYcOnw6NvIGRvIGZvcm11bMOhcmlvO1xuICogLSBQYXJhIGEgdmFsaWRhw6fDo28gZG8gZm9ybXVsw6FyaW8sIHV0aWxpemUgbyBgWyhuZ01vZGVsKV1gLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGhmRGF0ZXBpY2tlclJhbmdlQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuXG4gIGVycm9yTWVzc2FnZTogc3RyaW5nID0gJyc7XG5cbiAgcHJpdmF0ZSBfY2xlYW4/OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2Rpc2FibGVkPztcbiAgcHJpdmF0ZSBfZW5kRGF0ZT87XG4gIHByaXZhdGUgX2xpdGVyYWxzPzogYW55O1xuICBwcml2YXRlIF9yZWFkb25seTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9yZXF1aXJlZD86IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfc3RhcnREYXRlPztcbiAgcHJpdmF0ZSBvbkNoYW5nZU1vZGVsOiBhbnk7XG4gIHByaXZhdGUgdmFsaWRhdG9yQ2hhbmdlOiBhbnk7XG5cbiAgcHJvdGVjdGVkIGRhdGVSYW5nZTogVGhmRGF0ZXBpY2tlclJhbmdlID0geyBzdGFydDogJycsIGVuZDogJycgfTtcbiAgcHJvdGVjdGVkIGZvcm1hdDogYW55ID0gJ2RkL21tL3l5eXknO1xuICBwcm90ZWN0ZWQgaXNEYXRlUmFuZ2VJbnB1dEZvcm1hdFZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJvdGVjdGVkIGlzU3RhcnREYXRlUmFuZ2VJbnB1dFZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJvdGVjdGVkIG9uVG91Y2hlZE1vZGVsOiBhbnk7XG5cbiAgZ2V0IGlzRGF0ZVJhbmdlSW5wdXRWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0RhdGVSYW5nZUlucHV0Rm9ybWF0VmFsaWQgJiYgdGhpcy5pc1N0YXJ0RGF0ZVJhbmdlSW5wdXRWYWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIEhhYmlsaXRhIGHDp8OjbyBwYXJhIGxpbXBhciBvIGNhbXBvLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3QtY2xlYW4nKSBzZXQgY2xlYW4oY2xlYW46IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jbGVhbiA9IGNvbnZlcnRUb0Jvb2xlYW4oY2xlYW4pO1xuICB9XG5cbiAgZ2V0IGNsZWFuKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlc2FiaWxpdGEgbyBjYW1wby5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCd0LWRpc2FibGVkJykgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBjb252ZXJ0VG9Cb29sZWFuKHZhbHVlKTtcblxuICAgIHRoaXMudmFsaWRhdGVNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGF0YSBmaW5hbC5cbiAgICovXG4gIEBJbnB1dCgndC1lbmQtZGF0ZScpIHNldCBlbmREYXRlKGRhdGU6IHN0cmluZyB8IERhdGUpIHtcbiAgICB0aGlzLl9lbmREYXRlID0gdGhpcy5jb252ZXJ0UGF0dGVybkRhdGVGb3JtYXQoZGF0ZSk7XG4gICAgdGhpcy5kYXRlUmFuZ2UuZW5kID0gdGhpcy5lbmREYXRlO1xuXG4gICAgdGhpcy51cGRhdGVTY3JlZW5CeU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIGdldCBlbmREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmREYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogVGV4dG8gZGUgYXBvaW8gZG8gY2FtcG8uXG4gICAqL1xuICBASW5wdXQoJ3QtaGVscCcpIGhlbHA/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogUsOzdHVsbyBkbyBjYW1wby5cbiAgICovXG4gIEBJbnB1dCgndC1sYWJlbCcpIGxhYmVsPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIE9iamV0byBjb20gYXMgbGl0ZXJhaXMgdXNhZGFzIG5vIGB0aGYtZGF0ZXBpY2tlci1yYW5nZWAuXG4gICAqXG4gICAqIEV4aXN0ZW0gZHVhcyBtYW5laXJhcyBkZSBjdXN0b21pemFyIG8gY29tcG9uZW50ZSwgcGFzc2FuZG8gdW0gb2JqZXRvIGNvbSB0b2RhcyBhcyBsaXRlcmFpcyBkaXNwb27DrXZlaXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiAgY29uc3QgY3VzdG9tTGl0ZXJhbHM6IFRoZkRhdGVwaWNrZXJSYW5nZUxpdGVyYWxzID0ge1xuICAgKiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0ZSBpbiBpbmNvbnNpc3RlbnQgZm9ybWF0JyxcbiAgICogICAgc3RhcnREYXRlR3JlYXRlclRoYW5FbmREYXRlOiAnRW5kIGRhdGUgbGVzcyB0aGFuIHN0YXJ0IGRhdGUnXG4gICAqICB9O1xuICAgKiBgYGBcbiAgICpcbiAgICogT3UgcGFzc2FuZG8gYXBlbmFzIGFzIGxpdGVyYWlzIHF1ZSBkZXNlamEgY3VzdG9taXphcjpcbiAgICpcbiAgICogYGBgXG4gICAqICBjb25zdCBjdXN0b21MaXRlcmFsczogVGhmRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHMgPSB7XG4gICAqICAgIGludmFsaWRGb3JtYXQ6ICdEYXRlIGluIGluY29uc2lzdGVudCBmb3JtYXQnXG4gICAqICB9O1xuICAgKiBgYGBcbiAgICpcbiAgICogRSBwYXJhIGNhcnJlZ2FyIGFzIGxpdGVyYWlzIGN1c3RvbWl6YWRhcywgYmFzdGEgYXBlbmFzIHBhc3NhciBvIG9iamV0byBwYXJhIG8gY29tcG9uZW50ZS5cbiAgICpcbiAgICogYGBgXG4gICAqIDx0aGYtZGF0ZXBpY2tlci1yYW5nZVxuICAgKiAgIFt0LWxpdGVyYWxzXT1cImN1c3RvbUxpdGVyYWxzXCI+XG4gICAqIDwvdGhmLWRhdGVwaWNrZXItcmFuZ2U+XG4gICAqIGBgYFxuICAgKlxuICAgKiA+IE8gb2JqZXRvIHBhZHLDo28gZGUgbGl0ZXJhaXMgc2Vyw6EgdHJhZHV6aWRvIGRlIGFjb3JkbyBjb20gbyBpZGlvbWEgZG8gYnJvd3NlciAocHQsIGVuLCBlcykuXG4gICAqL1xuICBASW5wdXQoJ3QtbGl0ZXJhbHMnKSBzZXQgbGl0ZXJhbHModmFsdWU6IFRoZkRhdGVwaWNrZXJSYW5nZUxpdGVyYWxzKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmICEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRoaXMuX2xpdGVyYWxzID0ge1xuICAgICAgICAuLi50aGZEYXRlcGlja2VyUmFuZ2VMaXRlcmFsc0RlZmF1bHRbdGhmTG9jYWxlRGVmYXVsdF0sXG4gICAgICAgIC4uLnRoZkRhdGVwaWNrZXJSYW5nZUxpdGVyYWxzRGVmYXVsdFticm93c2VyTGFuZ3VhZ2UoKV0sXG4gICAgICAgIC4uLnZhbHVlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saXRlcmFscyA9IHRoZkRhdGVwaWNrZXJSYW5nZUxpdGVyYWxzRGVmYXVsdFticm93c2VyTGFuZ3VhZ2UoKV07XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxpdGVyYWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9saXRlcmFscyB8fCB0aGZEYXRlcGlja2VyUmFuZ2VMaXRlcmFsc0RlZmF1bHRbYnJvd3Nlckxhbmd1YWdlKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVmaW5lIHNlIGEgaW5kaWNhw6fDo28gZGUgY2FtcG8gb3BjaW9uYWwgc2Vyw6EgZXhpYmlkYS5cbiAgICpcbiAgICogPiBOw6NvIHNlcsOhIGV4aWJpZGEgYSBpbmRpY2HDp8OjbyBzZTpcbiAgICogLSBPIGNhbXBvIGNvbnRlciBgdC1yZXF1aXJlZGA7XG4gICAqIC0gTsOjbyBwb3NzdWlyIGB0LWhlbHBgIGUvb3UgYHQtbGFiZWxgLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3Qtb3B0aW9uYWwnKSBvcHRpb25hbDogYm9vbGVhbjtcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBJbmRpY2EgcXVlIG8gY2FtcG8gc2Vyw6Egc29tZW50ZSBsZWl0dXJhLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3QtcmVhZG9ubHknKSBzZXQgcmVhZG9ubHkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZWFkb25seSA9IGNvbnZlcnRUb0Jvb2xlYW4odmFsdWUpO1xuXG4gICAgdGhpcy52YWxpZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIGdldCByZWFkb25seSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZG9ubHk7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBJbmRpY2EgcXVlIG8gY2FtcG8gc2Vyw6Egb2JyaWdhdMOzcmlvLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3QtcmVxdWlyZWQnKSBzZXQgcmVxdWlyZWQocmVxdWlyZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZXF1aXJlZCA9IGNvbnZlcnRUb0Jvb2xlYW4ocmVxdWlyZWQpO1xuXG4gICAgdGhpcy52YWxpZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIGdldCByZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEYXRhIGluaWNpYWwuXG4gICAqL1xuICBASW5wdXQoJ3Qtc3RhcnQtZGF0ZScpIHNldCBzdGFydERhdGUoZGF0ZTogc3RyaW5nIHwgRGF0ZSkge1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KGRhdGUpO1xuICAgIHRoaXMuZGF0ZVJhbmdlLnN0YXJ0ID0gdGhpcy5zdGFydERhdGU7XG5cbiAgICB0aGlzLnVwZGF0ZVNjcmVlbkJ5TW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICAgIHRoaXMudXBkYXRlTW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnREYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRXZlbnRvIGRpc3BhcmFkbyBhbyBhbHRlcmFyIHZhbG9yIGRvIGNhbXBvLlxuICAgKi9cbiAgQE91dHB1dCgndC1jaGFuZ2UnKSBvbkNoYW5nZT86IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHRoZkRhdGVTZXJ2aWNlOiBUaGZEYXRlU2VydmljZSkgeyB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlc2V0RGF0ZVJhbmdlSW5wdXRWYWxpZGF0aW9uKCk6IHZvaWQ7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHVwZGF0ZVNjcmVlbkJ5TW9kZWwoZGF0ZVJhbmdlOiBUaGZEYXRlcGlja2VyUmFuZ2UpO1xuXG4gIC8vIEZ1bsOnw6NvIGltcGxlbWVudGFkYSBkbyBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAvLyBVc2FkYSBwYXJhIGludGVyY2VwdGFyIGFzIG11ZGFuw6dhcyBlIG7Do28gYXR1YWxpemFyIGF1dG9tYXRpY2FtZW50ZSBvIE1vZGVsXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZnVuYzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZU1vZGVsID0gZnVuYztcbiAgfVxuXG4gIC8vIEZ1bsOnw6NvIGltcGxlbWVudGFkYSBkbyBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAvLyBVc2FkYSBwYXJhIGludGVyY2VwdGFyIGFzIG11ZGFuw6dhcyBlIG7Do28gYXR1YWxpemFyIGF1dG9tYXRpY2FtZW50ZSBvIE1vZGVsXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZ1bmM6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkTW9kZWwgPSBmdW5jO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZT8oZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLnZhbGlkYXRvckNoYW5nZSA9IGZuO1xuICB9XG5cbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG5cbiAgICBjb25zdCB2YWx1ZTogVGhmRGF0ZXBpY2tlclJhbmdlID0gY29udHJvbC52YWx1ZSB8fCB7fTtcbiAgICBjb25zdCBzdGFydERhdGUgPSB2YWx1ZS5zdGFydCA/IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KHZhbHVlLnN0YXJ0KSA6ICcnO1xuICAgIGNvbnN0IGVuZERhdGUgPSB2YWx1ZS5lbmQgPyB0aGlzLmNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdCh2YWx1ZS5lbmQpIDogJyc7XG5cbiAgICBpZiAodGhpcy5yZXF1aXJlZERhdGVSYW5nZUZhaWxlZChzdGFydERhdGUsIGVuZERhdGUpKSB7XG4gICAgICB0aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuXG4gICAgICByZXR1cm4geyByZXF1aXJlZDoge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICB9fTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRlUmFuZ2VPYmplY3RGYWlsZWQoY29udHJvbC52YWx1ZSkgfHwgdGhpcy5kYXRlUmFuZ2VGb3JtYXRGYWlsZWQoc3RhcnREYXRlLCBlbmREYXRlKSkge1xuICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSB0aGlzLmxpdGVyYWxzLmludmFsaWRGb3JtYXQ7XG5cbiAgICAgIHJldHVybiB7IGRhdGU6IHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgfX07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0ZVJhbmdlRmFpbGVkKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkpIHtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gdGhpcy5saXRlcmFscy5zdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU7XG5cbiAgICAgIHJldHVybiB7IGRhdGU6IHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgfX07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB3cml0ZVZhbHVlKGRhdGVSYW5nZTogVGhmRGF0ZXBpY2tlclJhbmdlKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldERhdGVSYW5nZUlucHV0VmFsaWRhdGlvbigpO1xuXG4gICAgaWYgKCFkYXRlUmFuZ2UgfHwgdGhpcy5kYXRlUmFuZ2VPYmplY3RGYWlsZWQoZGF0ZVJhbmdlKSkge1xuICAgICAgdGhpcy5kYXRlUmFuZ2UgPSB7IHN0YXJ0OiAnJywgZW5kOiAnJyB9O1xuICAgIH1cblxuICAgIGlmICghZGF0ZVJhbmdlKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlTW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGVSYW5nZU9iamVjdEZhaWxlZChkYXRlUmFuZ2UpKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1vZGVsKGRhdGVSYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEYXRlUmFuZ2VPYmplY3QoZGF0ZVJhbmdlKSkge1xuICAgICAgdGhpcy5kYXRlUmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLmNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdChkYXRlUmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KGRhdGVSYW5nZS5lbmQpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNjcmVlbkJ5TW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRhdGVGb3JtYXRGYWlsZWQodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhdGhpcy50aGZEYXRlU2VydmljZS5pc1ZhbGlkSXNvKHZhbHVlKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGEgYSBmdW7Dp8OjbyBvbkNoYW5nZVxuICBwcm90ZWN0ZWQgdXBkYXRlTW9kZWwodmFsdWU6IGFueSkge1xuICAgIGNvbnN0IG1vZGVsID0gdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAvLyBRdWFuZG8gbyBpbnB1dCBuw6NvIHBvc3N1aSB1bSBmb3JtdWzDoXJpbywgZW50w6NvIGVzdGEgZnVuw6fDo28gbsOjbyDDqSByZWdpc3RyYWRhXG4gICAgaWYgKHRoaXMub25DaGFuZ2VNb2RlbCkge1xuICAgICAgdGhpcy5vbkNoYW5nZU1vZGVsKG1vZGVsKTtcbiAgICB9XG5cbiAgfVxuXG4gIHByb3RlY3RlZCB2YWxpZGF0ZU1vZGVsKHZhbHVlOiBhbnkpIHtcbiAgICBjb25zdCBtb2RlbCA9IHsgLi4udmFsdWUgfTtcbiAgICBpZiAodGhpcy52YWxpZGF0b3JDaGFuZ2UpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yQ2hhbmdlKG1vZGVsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdCh2YWx1ZTogYW55KSB7XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGZEYXRlU2VydmljZS5jb252ZXJ0RGF0ZVRvSVNPKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIGRhdGVSYW5nZUZhaWxlZChzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLnRoZkRhdGVTZXJ2aWNlLmlzRGF0ZVJhbmdlVmFsaWQoZW5kRGF0ZSwgc3RhcnREYXRlKSB8fCAhdGhpcy5pc1N0YXJ0RGF0ZVJhbmdlSW5wdXRWYWxpZDtcbiAgfVxuXG4gIHByaXZhdGUgZGF0ZVJhbmdlRm9ybWF0RmFpbGVkKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRm9ybWF0RmFpbGVkKGVuZERhdGUpIHx8IHRoaXMuZGF0ZUZvcm1hdEZhaWxlZChzdGFydERhdGUpIHx8ICF0aGlzLmlzRGF0ZVJhbmdlSW5wdXRGb3JtYXRWYWxpZDtcbiAgfVxuXG4gIHByaXZhdGUgZGF0ZVJhbmdlT2JqZWN0RmFpbGVkKHZhbHVlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHZhbHVlICYmICF0aGlzLmlzRGF0ZVJhbmdlT2JqZWN0KHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNEYXRlUmFuZ2VPYmplY3QodmFsdWUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ3N0YXJ0JykgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ2VuZCcpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXF1aXJlZERhdGVSYW5nZUZhaWxlZChzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNEYXRlUmFuZ2VJbnB1dFZhbGlkICYmXG4gICAgICByZXF1aXJlZEZhaWxlZCh0aGlzLnJlcXVpcmVkLCB0aGlzLmRpc2FibGVkLCBzdGFydERhdGUpICYmXG4gICAgICByZXF1aXJlZEZhaWxlZCh0aGlzLnJlcXVpcmVkLCB0aGlzLmRpc2FibGVkLCBlbmREYXRlKTtcbiAgfVxuXG59XG4iXX0=