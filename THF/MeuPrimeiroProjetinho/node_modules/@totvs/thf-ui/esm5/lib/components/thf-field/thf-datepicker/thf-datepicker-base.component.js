/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter, Input, Output } from '@angular/core';
import { convertDateToISODate, convertDateToISOExtended, convertIsoToDate, convertToBoolean, formatYear, getShortBrowserLanguage, isTypeof, setYearFrom0To100, validateDateRange } from '../../../utils/util';
import { dateFailed, requiredFailed } from './../validators';
import { ThfMask } from '../thf-input/thf-mask';
/** @type {?} */
var thfDatepickerFormatDefault = 'dd/mm/yyyy';
/**
 * \@description
 *
 * O `thf-datepicker` é um componente específico para manipulação de datas permitindo a digitação e / ou seleção.
 *
 * O formato de exibição da data, ou seja, o formato que é apresentado ao usuário é o dd/mm/yyyy,
 * mas podem ser definidos outros padrões (veja mais na propriedade `t-format`).
 *
 * O idioma padrão do calendário será exibido de acordo com o navegador, caso tenha necessidade de alterar
 * use a propriedade `t-locale`.
 *
 * O datepicker aceita três formatos de data: o E8601DZw (yyyy-mm-ddThh:mm:ss+|-hh:mm), o E8601DAw (yyyy-mm-dd) e o
 * Date padrão do Javascript.
 *
 * > O formato de saída do *model* se ajusta conforme o formato de entrada, veja abaixo:
 *
 * - Formato de entrada e saída (E8601DZw) - `'2017-11-28T00:00:00-02:00'`;
 *
 * - Formato de entrada e saída (E8601DAw) - `'2017-11-28'`;
 *
 * - Formato de entrada (Date) - `new Date(2017, 10, 28)` e saída (E8601DAw) - `'2017-11-28'`;
 *
 * **Importante:**
 *
 * - Para utilizar datas com ano inferior a 100, verificar o comportamento do [`new Date`](https://www.w3schools.com/js/js_dates.asp)
 * e utilizar o método [`setFullYear`](https://www.w3schools.com/jsref/jsref_setfullyear.asp).
 * - Caso a data esteja inválida, o `model` receberá **'Data inválida'**.
 * - Caso o `input` esteja passando um `[(ngModel)]`, mas não tenha um `name`, então irá ocorrer um erro
 * do próprio Angular (`[ngModelOptions]="{standalone: true}"`).
 *
 * Exemplo:
 *
 * ```
 * <thf-datepicker
 *   [(ngModel)]="pessoa.nome"
 *   [ngModelOptions]="{standalone: true}"
 * </thf-datepicker>
 * ```
 *
 * > Não esqueça de importar o `FormsModule` em seu módulo, tal como para utilizar o `input default`.
 * @abstract
 */
var ThfDatepickerBaseComponent = /** @class */ (function () {
    function ThfDatepickerBaseComponent() {
        this._format = thfDatepickerFormatDefault;
        this._placeholder = '';
        this.firstStart = true;
        this.hour = 'T00:00:01-00:00';
        this.isExtendedISO = false;
        this.onChangeModel = null;
        this.onTouchedModel = null;
        /**
         * Desabilita o campo.
         */
        this.disabled = false;
        /**
         * Torna o elemento somente leitura.
         */
        this.readonly = false;
        /**
         * Faz com que o campo seja obrigatório.
         */
        this.required = false;
        /**
         * Aplica foco ao elemento ao ser iniciado.
         */
        this.focus = false;
        /**
         * Habilita ação para limpar o campo.
         */
        this.clean = false;
        /**
         * Mensagem apresentada quando a data for inválida ou fora do período.
         *
         * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja obrigatório.
         */
        this.errorPattern = '';
        /**
         * Evento disparado ao sair do campo.
         */
        this.onblur = new EventEmitter();
        /**
         * Evento disparado ao alterar valor do campo.
         */
        this.onchange = new EventEmitter();
    }
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this._placeholder;
        },
        /**
         * @optional
         *
         * @description
         *
         * Mensagem que aparecerá enquanto o campo não estiver preenchido.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Mensagem que aparecerá enquanto o campo não estiver preenchido.
         * @param {?} placeholder
         * @return {?}
         */
        function (placeholder) {
            this._placeholder = isTypeof(placeholder, 'string') ? placeholder : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setDisabled", {
        set: /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.disabled = disabled === '' ? true : convertToBoolean(disabled);
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setReadonly", {
        set: /**
         * @param {?} readonly
         * @return {?}
         */
        function (readonly) {
            this.readonly = readonly === '' ? true : convertToBoolean(readonly);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setRequired", {
        set: /**
         * @param {?} required
         * @return {?}
         */
        function (required) {
            this.required = required === '' ? true : convertToBoolean(required);
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setFocus", {
        set: /**
         * @param {?} focus
         * @return {?}
         */
        function (focus) {
            this.focus = focus === '' ? true : convertToBoolean(focus);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setClean", {
        set: /**
         * @param {?} clean
         * @return {?}
         */
        function (clean) {
            this.clean = clean === '' ? true : convertToBoolean(clean);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "minDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minDate;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define uma data mínima para o `thf-datepicker`.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define uma data mínima para o `thf-datepicker`.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Date) {
                /** @type {?} */
                var year = value.getFullYear();
                /** @type {?} */
                var date = new Date(year, value.getMonth(), value.getDate(), 0, 0, 0);
                setYearFrom0To100(date, year);
                this._minDate = date;
            }
            else {
                this._minDate = convertIsoToDate(value, true, false);
            }
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "maxDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxDate;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define uma data máxima para o `thf-datepicker`.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define uma data máxima para o `thf-datepicker`.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Date) {
                /** @type {?} */
                var year = value.getFullYear();
                /** @type {?} */
                var date = new Date(year, value.getMonth(), value.getDate(), 23, 59, 59);
                setYearFrom0To100(date, year);
                this._maxDate = date;
            }
            else {
                this._maxDate = convertIsoToDate(value, false, true);
            }
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "format", {
        get: /**
         * @return {?}
         */
        function () {
            return this._format;
        },
        /**
         * @optional
         *
         * @description
         *
         * Formato de exibição da data.
         *
         * Valores válidos:
         *  - `dd/mm/yyyy`
         *  - `mm/dd/yyyy`
         *  - `yyyy/mm/dd`
         *
         * @default `dd/mm/yyyy`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Formato de exibição da data.
         *
         * Valores válidos:
         *  - `dd/mm/yyyy`
         *  - `mm/dd/yyyy`
         *  - `yyyy/mm/dd`
         *
         * \@default `dd/mm/yyyy`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                value = value.toLowerCase();
                if (value.match(/dd/) && value.match(/mm/) && value.match(/yyyy/)) {
                    this._format = value;
                    this.objMask = this.buildMask();
                    this.refreshValue(this.date);
                    return;
                }
            }
            this._format = thfDatepickerFormatDefault;
            this.objMask = this.buildMask();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "locale", {
        get: /**
         * @return {?}
         */
        function () {
            return this._locale || getShortBrowserLanguage();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._locale = value.length >= 2 ? value : 'pt';
            }
            else {
                this._locale = getShortBrowserLanguage();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // Classe de máscara
        this.objMask = this.buildMask();
    };
    // Converte um objeto string em Date
    // Converte um objeto string em Date
    /**
     * @param {?} dateString
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.getDateFromString = 
    // Converte um objeto string em Date
    /**
     * @param {?} dateString
     * @return {?}
     */
    function (dateString) {
        /** @type {?} */
        var day = parseInt(dateString.substring(this.format.indexOf('d'), this.format.indexOf('d') + 2), 10);
        /** @type {?} */
        var month = parseInt(dateString.substring(this.format.indexOf('m'), this.format.indexOf('m') + 2), 10) - 1;
        /** @type {?} */
        var year = parseInt(dateString.substring(this.format.indexOf('y'), this.format.indexOf('y') + 4), 10);
        /** @type {?} */
        var date = new Date(year, month, day);
        setYearFrom0To100(date, year);
        return (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) ? date : null;
    };
    // Formata a data.
    // Formata a data.
    /**
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.formatToDate = 
    // Formata a data.
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var dateFormatted = this.format;
        dateFormatted = dateFormatted.replace('dd', ('0' + value.getDate()).slice(-2));
        dateFormatted = dateFormatted.replace('mm', ('0' + (value.getMonth() + 1)).slice(-2));
        dateFormatted = dateFormatted.replace('yyyy', formatYear(value.getFullYear()));
        return dateFormatted;
    };
    // Método responsável por controlar o modelo.
    // Método responsável por controlar o modelo.
    /**
     * @param {?} date
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.controlModel = 
    // Método responsável por controlar o modelo.
    /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        this.date = date;
        if (date && this.isExtendedISO) {
            this.callOnChange(convertDateToISOExtended(this.date, this.hour));
        }
        else if (date && !this.isExtendedISO) {
            this.callOnChange(convertDateToISODate(this.date));
        }
        else {
            date === undefined ? this.callOnChange('') : this.callOnChange('Data inválida');
        }
    };
    // Executa a função onChange
    // Executa a função onChange
    /**
     * @param {?} value
     * @param {?=} retry
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.callOnChange = 
    // Executa a função onChange
    /**
     * @param {?} value
     * @param {?=} retry
     * @return {?}
     */
    function (value, retry) {
        var _this = this;
        if (retry === void 0) { retry = true; }
        if (this.onChangeModel) {
            this.onChangeModel(value);
        }
        else if (retry) {
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.callOnChange(value, false); }));
        }
    };
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnChange = 
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    function (func) {
        this.onChangeModel = func;
    };
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnTouched = 
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    function (func) {
        this.onTouchedModel = func;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.validatorChange = fn;
    };
    /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.validateModel = /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    function (model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    };
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    /**
     * @protected
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.buildMask = 
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var mask = this.format.toUpperCase();
        mask = mask.replace(/DD/g, '99');
        mask = mask.replace(/MM/g, '99');
        mask = mask.replace(/YYYY/g, '9999');
        return new ThfMask(mask, true);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        // Verifica se já possui algum error pattern padrão.
        this.errorPattern = this.errorPattern !== 'Data inválida' && this.errorPattern !== 'Data fora do período' ? this.errorPattern : '';
        if (dateFailed(c.value)) {
            this.errorPattern = this.errorPattern || 'Data inválida';
            return { date: {
                    valid: false,
                } };
        }
        if (requiredFailed(this.required, this.disabled, c.value)) {
            return { required: {
                    valid: false,
                } };
        }
        if ((this.date && !validateDateRange(this.date, this._minDate, this._maxDate))) {
            this.errorPattern = this.errorPattern || 'Data fora do período';
            return { date: {
                    valid: false,
                } };
        }
        return null;
    };
    ThfDatepickerBaseComponent.propDecorators = {
        name: [{ type: Input, args: ['name',] }],
        placeholder: [{ type: Input, args: ['t-placeholder',] }],
        optional: [{ type: Input, args: ['t-optional',] }],
        setDisabled: [{ type: Input, args: ['t-disabled',] }],
        setReadonly: [{ type: Input, args: ['t-readonly',] }],
        setRequired: [{ type: Input, args: ['t-required',] }],
        setFocus: [{ type: Input, args: ['t-focus',] }],
        setClean: [{ type: Input, args: ['t-clean',] }],
        errorPattern: [{ type: Input, args: ['t-error-pattern',] }],
        minDate: [{ type: Input, args: ['t-min-date',] }],
        maxDate: [{ type: Input, args: ['t-max-date',] }],
        format: [{ type: Input, args: ['t-format',] }],
        locale: [{ type: Input, args: ['t-locale',] }],
        onblur: [{ type: Output, args: ['t-blur',] }],
        onchange: [{ type: Output, args: ['t-change',] }]
    };
    return ThfDatepickerBaseComponent;
}());
export { ThfDatepickerBaseComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerBaseComponent.prototype._format;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerBaseComponent.prototype._maxDate;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerBaseComponent.prototype._minDate;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerBaseComponent.prototype._placeholder;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.date;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.firstStart;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.hour;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.isExtendedISO;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.objMask;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.onChangeModel;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.onTouchedModel;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.validatorChange;
    /** @type {?} */
    ThfDatepickerBaseComponent.prototype.name;
    /**
     * \@optional
     *
     * \@description
     *
     * Define se a indicação de campo opcional será exibida.
     *
     * > Não será exibida a indicação se:
     * - O campo conter `t-required`;
     * - Não possuir `t-help` e/ou `t-label`.
     *
     * \@default `false`
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.optional;
    /**
     * Desabilita o campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.disabled;
    /**
     * Torna o elemento somente leitura.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.readonly;
    /**
     * Faz com que o campo seja obrigatório.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.required;
    /**
     * Aplica foco ao elemento ao ser iniciado.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.focus;
    /**
     * Habilita ação para limpar o campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.clean;
    /**
     * Mensagem apresentada quando a data for inválida ou fora do período.
     *
     * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja obrigatório.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.errorPattern;
    /**
     * \@optional
     *
     * \@description
     *
     * Idioma do Datepicker.
     *
     * Valores válidos:
     *  - `pt`
     *  - `en`
     *  - `es`
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype._locale;
    /**
     * Evento disparado ao sair do campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.onblur;
    /**
     * Evento disparado ao alterar valor do campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.onchange;
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.writeValue = function (value) { };
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.refreshValue = function (value) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhmLWRhdGVwaWNrZXItYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdG90dnMvdGhmLXVpLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvdGhmLWZpZWxkL3RoZi1kYXRlcGlja2VyL3RoZi1kYXRlcGlja2VyLWJhc2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHcEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLHdCQUF3QixFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFDckcsdUJBQXVCLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkcsT0FBTyxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7O0lBRTFDLDBCQUEwQixHQUFXLFlBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQ3ZEO0lBNE1FO1FBMU1RLFlBQU8sR0FBWSwwQkFBMEIsQ0FBQztRQUc5QyxpQkFBWSxHQUFZLEVBQUUsQ0FBQztRQUd6QixlQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLFNBQUksR0FBVyxpQkFBaUIsQ0FBQztRQUNqQyxrQkFBYSxHQUFZLEtBQUssQ0FBQztRQUUvQixrQkFBYSxHQUFRLElBQUksQ0FBQztRQUMxQixtQkFBYyxHQUFRLElBQUksQ0FBQzs7OztRQXFDckMsYUFBUSxHQUFhLEtBQUssQ0FBQzs7OztRQVEzQixhQUFRLEdBQWEsS0FBSyxDQUFDOzs7O1FBTTNCLGFBQVEsR0FBYSxLQUFLLENBQUM7Ozs7UUFRM0IsVUFBSyxHQUFhLEtBQUssQ0FBQzs7OztRQU14QixVQUFLLEdB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OzhCQVFsQixLQUFLLFNBQUMsWUFBWTs4QkFNbEIsS0FBSyxTQUFDLFlBQVk7MkJBUWxCLEtBQUssU0FBQyxTQUFTOzJCQU1mLEtBQUssU0FBQyxTQUFTOytCQVNmLEtBQUssU0FBQyxpQkFBaUI7MEJBU3ZCLEtBQUssU0FBQyxZQUFZOzBCQTBCbEIsS0FBSyxTQUFDLFlBQVk7eUJBaUNsQixLQUFLLFNBQUMsVUFBVTt5QkErQmhCLEtBQUssU0FBQyxVQUFVO3lCQVloQixNQUFNLFNBQUMsUUFBUTsyQkFHZixNQUFNLFNBQUMsVUFBVTs7SUF3SHBCLGlDQUFDO0NBQUEsQUFsVUQsSUFrVUM7U0FsVXFCLDBCQUEwQjs7Ozs7O0lBRTlDLDZDQUFzRDs7Ozs7SUFDdEQsOENBQXVCOzs7OztJQUN2Qiw4Q0FBdUI7Ozs7O0lBQ3ZCLGtEQUFtQzs7Ozs7SUFFbkMsMENBQXFCOzs7OztJQUNyQixnREFBNEI7Ozs7O0lBQzVCLDBDQUEyQzs7Ozs7SUFDM0MsbURBQXlDOzs7OztJQUN6Qyw2Q0FBdUI7Ozs7O0lBQ3ZCLG1EQUFvQzs7Ozs7SUFDcEMsb0RBQXFDOzs7OztJQUNyQyxxREFBK0I7O0lBRy9CLDBDQUE0Qjs7Ozs7Ozs7Ozs7Ozs7O0lBOEI1Qiw4Q0FBdUM7Ozs7O0lBR3ZDLDhDQUEyQjs7Ozs7SUFRM0IsOENBQTJCOzs7OztJQU0zQiw4Q0FBMkI7Ozs7O0lBUTNCLDJDQUF3Qjs7Ozs7SUFNeEIsMkNBQXdCOzs7Ozs7O0lBVXhCLGtEQUFxRDs7Ozs7Ozs7Ozs7Ozs7SUFrR3JELDZDQUFpQjs7Ozs7SUFhakIsNENBQXVFOzs7OztJQUd2RSw4Q0FBMkU7Ozs7OztJQUkzRSx1RUFBc0M7Ozs7OztJQUV0Qyx5RUFBeUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBjb252ZXJ0RGF0ZVRvSVNPRGF0ZSwgY29udmVydERhdGVUb0lTT0V4dGVuZGVkLCBjb252ZXJ0SXNvVG9EYXRlLCBjb252ZXJ0VG9Cb29sZWFuLCBmb3JtYXRZZWFyLFxuICBnZXRTaG9ydEJyb3dzZXJMYW5ndWFnZSwgaXNUeXBlb2YsIHNldFllYXJGcm9tMFRvMTAwLCB2YWxpZGF0ZURhdGVSYW5nZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgZGF0ZUZhaWxlZCwgcmVxdWlyZWRGYWlsZWQgfSBmcm9tICcuLy4uL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgVGhmTWFzayB9IGZyb20gJy4uL3RoZi1pbnB1dC90aGYtbWFzayc7XG5cbmNvbnN0IHRoZkRhdGVwaWNrZXJGb3JtYXREZWZhdWx0OiBzdHJpbmcgPSAnZGQvbW0veXl5eSc7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogTyBgdGhmLWRhdGVwaWNrZXJgIMOpIHVtIGNvbXBvbmVudGUgZXNwZWPDrWZpY28gcGFyYSBtYW5pcHVsYcOnw6NvIGRlIGRhdGFzIHBlcm1pdGluZG8gYSBkaWdpdGHDp8OjbyBlIC8gb3Ugc2VsZcOnw6NvLlxuICpcbiAqIE8gZm9ybWF0byBkZSBleGliacOnw6NvIGRhIGRhdGEsIG91IHNlamEsIG8gZm9ybWF0byBxdWUgw6kgYXByZXNlbnRhZG8gYW8gdXN1w6FyaW8gw6kgbyBkZC9tbS95eXl5LFxuICogbWFzIHBvZGVtIHNlciBkZWZpbmlkb3Mgb3V0cm9zIHBhZHLDtWVzICh2ZWphIG1haXMgbmEgcHJvcHJpZWRhZGUgYHQtZm9ybWF0YCkuXG4gKlxuICogTyBpZGlvbWEgcGFkcsOjbyBkbyBjYWxlbmTDoXJpbyBzZXLDoSBleGliaWRvIGRlIGFjb3JkbyBjb20gbyBuYXZlZ2Fkb3IsIGNhc28gdGVuaGEgbmVjZXNzaWRhZGUgZGUgYWx0ZXJhclxuICogdXNlIGEgcHJvcHJpZWRhZGUgYHQtbG9jYWxlYC5cbiAqXG4gKiBPIGRhdGVwaWNrZXIgYWNlaXRhIHRyw6pzIGZvcm1hdG9zIGRlIGRhdGE6IG8gRTg2MDFEWncgKHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbSksIG8gRTg2MDFEQXcgKHl5eXktbW0tZGQpIGUgb1xuICogRGF0ZSBwYWRyw6NvIGRvIEphdmFzY3JpcHQuXG4gKlxuICogPiBPIGZvcm1hdG8gZGUgc2HDrWRhIGRvICptb2RlbCogc2UgYWp1c3RhIGNvbmZvcm1lIG8gZm9ybWF0byBkZSBlbnRyYWRhLCB2ZWphIGFiYWl4bzpcbiAqXG4gKiAtIEZvcm1hdG8gZGUgZW50cmFkYSBlIHNhw61kYSAoRTg2MDFEWncpIC0gYCcyMDE3LTExLTI4VDAwOjAwOjAwLTAyOjAwJ2A7XG4gKlxuICogLSBGb3JtYXRvIGRlIGVudHJhZGEgZSBzYcOtZGEgKEU4NjAxREF3KSAtIGAnMjAxNy0xMS0yOCdgO1xuICpcbiAqIC0gRm9ybWF0byBkZSBlbnRyYWRhIChEYXRlKSAtIGBuZXcgRGF0ZSgyMDE3LCAxMCwgMjgpYCBlIHNhw61kYSAoRTg2MDFEQXcpIC0gYCcyMDE3LTExLTI4J2A7XG4gKlxuICogKipJbXBvcnRhbnRlOioqXG4gKlxuICogLSBQYXJhIHV0aWxpemFyIGRhdGFzIGNvbSBhbm8gaW5mZXJpb3IgYSAxMDAsIHZlcmlmaWNhciBvIGNvbXBvcnRhbWVudG8gZG8gW2BuZXcgRGF0ZWBdKGh0dHBzOi8vd3d3Lnczc2Nob29scy5jb20vanMvanNfZGF0ZXMuYXNwKVxuICogZSB1dGlsaXphciBvIG3DqXRvZG8gW2BzZXRGdWxsWWVhcmBdKGh0dHBzOi8vd3d3Lnczc2Nob29scy5jb20vanNyZWYvanNyZWZfc2V0ZnVsbHllYXIuYXNwKS5cbiAqIC0gQ2FzbyBhIGRhdGEgZXN0ZWphIGludsOhbGlkYSwgbyBgbW9kZWxgIHJlY2ViZXLDoSAqKidEYXRhIGludsOhbGlkYScqKi5cbiAqIC0gQ2FzbyBvIGBpbnB1dGAgZXN0ZWphIHBhc3NhbmRvIHVtIGBbKG5nTW9kZWwpXWAsIG1hcyBuw6NvIHRlbmhhIHVtIGBuYW1lYCwgZW50w6NvIGlyw6Egb2NvcnJlciB1bSBlcnJvXG4gKiBkbyBwcsOzcHJpbyBBbmd1bGFyIChgW25nTW9kZWxPcHRpb25zXT1cIntzdGFuZGFsb25lOiB0cnVlfVwiYCkuXG4gKlxuICogRXhlbXBsbzpcbiAqXG4gKiBgYGBcbiAqIDx0aGYtZGF0ZXBpY2tlclxuICogICBbKG5nTW9kZWwpXT1cInBlc3NvYS5ub21lXCJcbiAqICAgW25nTW9kZWxPcHRpb25zXT1cIntzdGFuZGFsb25lOiB0cnVlfVwiXG4gKiA8L3RoZi1kYXRlcGlja2VyPlxuICogYGBgXG4gKlxuICogPiBOw6NvIGVzcXVlw6dhIGRlIGltcG9ydGFyIG8gYEZvcm1zTW9kdWxlYCBlbSBzZXUgbcOzZHVsbywgdGFsIGNvbW8gcGFyYSB1dGlsaXphciBvIGBpbnB1dCBkZWZhdWx0YC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRoZkRhdGVwaWNrZXJCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uSW5pdCwgVmFsaWRhdG9yIHtcblxuICBwcml2YXRlIF9mb3JtYXQ/OiBzdHJpbmcgPSB0aGZEYXRlcGlja2VyRm9ybWF0RGVmYXVsdDtcbiAgcHJpdmF0ZSBfbWF4RGF0ZTogRGF0ZTtcbiAgcHJpdmF0ZSBfbWluRGF0ZTogRGF0ZTtcbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI/OiBzdHJpbmcgPSAnJztcblxuICBwcm90ZWN0ZWQgZGF0ZTogRGF0ZTtcbiAgcHJvdGVjdGVkIGZpcnN0U3RhcnQgPSB0cnVlO1xuICBwcm90ZWN0ZWQgaG91cjogc3RyaW5nID0gJ1QwMDowMDowMS0wMDowMCc7XG4gIHByb3RlY3RlZCBpc0V4dGVuZGVkSVNPOiBib29sZWFuID0gZmFsc2U7XG4gIHByb3RlY3RlZCBvYmpNYXNrOiBhbnk7XG4gIHByb3RlY3RlZCBvbkNoYW5nZU1vZGVsOiBhbnkgPSBudWxsO1xuICBwcm90ZWN0ZWQgb25Ub3VjaGVkTW9kZWw6IGFueSA9IG51bGw7XG4gIHByb3RlY3RlZCB2YWxpZGF0b3JDaGFuZ2U6IGFueTtcblxuICAvKiBOb21lIGRvIGNvbXBvbmVudGUgZGF0ZXBpY2tlci4gKi9cbiAgQElucHV0KCduYW1lJykgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIE1lbnNhZ2VtIHF1ZSBhcGFyZWNlcsOhIGVucXVhbnRvIG8gY2FtcG8gbsOjbyBlc3RpdmVyIHByZWVuY2hpZG8uXG4gICAqL1xuICBASW5wdXQoJ3QtcGxhY2Vob2xkZXInKSBzZXQgcGxhY2Vob2xkZXIocGxhY2Vob2xkZXI6IHN0cmluZykge1xuICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gaXNUeXBlb2YocGxhY2Vob2xkZXIsICdzdHJpbmcnKSA/IHBsYWNlaG9sZGVyIDogJyc7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVmaW5lIHNlIGEgaW5kaWNhw6fDo28gZGUgY2FtcG8gb3BjaW9uYWwgc2Vyw6EgZXhpYmlkYS5cbiAgICpcbiAgICogPiBOw6NvIHNlcsOhIGV4aWJpZGEgYSBpbmRpY2HDp8OjbyBzZTpcbiAgICogLSBPIGNhbXBvIGNvbnRlciBgdC1yZXF1aXJlZGA7XG4gICAqIC0gTsOjbyBwb3NzdWlyIGB0LWhlbHBgIGUvb3UgYHQtbGFiZWxgLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3Qtb3B0aW9uYWwnKSBvcHRpb25hbDogYm9vbGVhbjtcblxuICAvKiogRGVzYWJpbGl0YSBvIGNhbXBvLiAqL1xuICBkaXNhYmxlZD86IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCd0LWRpc2FibGVkJykgc2V0IHNldERpc2FibGVkKGRpc2FibGVkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQgPT09ICcnID8gdHJ1ZSA6IGNvbnZlcnRUb0Jvb2xlYW4oZGlzYWJsZWQpO1xuXG4gICAgdGhpcy52YWxpZGF0ZU1vZGVsKGNvbnZlcnREYXRlVG9JU09FeHRlbmRlZCh0aGlzLmRhdGUsIHRoaXMuaG91cikpO1xuICB9XG5cbiAgLyoqIFRvcm5hIG8gZWxlbWVudG8gc29tZW50ZSBsZWl0dXJhLiAqL1xuICByZWFkb25seT86IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCd0LXJlYWRvbmx5Jykgc2V0IHNldFJlYWRvbmx5KHJlYWRvbmx5OiBzdHJpbmcpIHtcbiAgICB0aGlzLnJlYWRvbmx5ID0gcmVhZG9ubHkgPT09ICcnID8gdHJ1ZSA6IGNvbnZlcnRUb0Jvb2xlYW4ocmVhZG9ubHkpO1xuICB9XG5cbiAgLyoqIEZheiBjb20gcXVlIG8gY2FtcG8gc2VqYSBvYnJpZ2F0w7NyaW8uICovXG4gIHJlcXVpcmVkPzogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoJ3QtcmVxdWlyZWQnKSBzZXQgc2V0UmVxdWlyZWQocmVxdWlyZWQ6IHN0cmluZykge1xuICAgIHRoaXMucmVxdWlyZWQgPSByZXF1aXJlZCA9PT0gJycgPyB0cnVlIDogY29udmVydFRvQm9vbGVhbihyZXF1aXJlZCk7XG5cbiAgICB0aGlzLnZhbGlkYXRlTW9kZWwoY29udmVydERhdGVUb0lTT0V4dGVuZGVkKHRoaXMuZGF0ZSwgdGhpcy5ob3VyKSk7XG4gIH1cblxuICAvKiogQXBsaWNhIGZvY28gYW8gZWxlbWVudG8gYW8gc2VyIGluaWNpYWRvLiAqL1xuICBmb2N1cz86IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCd0LWZvY3VzJykgc2V0IHNldEZvY3VzKGZvY3VzOiBzdHJpbmcpIHtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXMgPT09ICcnID8gdHJ1ZSA6IGNvbnZlcnRUb0Jvb2xlYW4oZm9jdXMpO1xuICB9XG5cbiAgLyoqIEhhYmlsaXRhIGHDp8OjbyBwYXJhIGxpbXBhciBvIGNhbXBvLiAqL1xuICBjbGVhbj86IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCd0LWNsZWFuJykgc2V0IHNldENsZWFuKGNsZWFuOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNsZWFuID0gY2xlYW4gPT09ICcnID8gdHJ1ZSA6IGNvbnZlcnRUb0Jvb2xlYW4oY2xlYW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lbnNhZ2VtIGFwcmVzZW50YWRhIHF1YW5kbyBhIGRhdGEgZm9yIGludsOhbGlkYSBvdSBmb3JhIGRvIHBlcsOtb2RvLlxuICAgKlxuICAgKiA+IEVzdGEgbWVuc2FnZW0gbsOjbyDDqSBhcHJlc2VudGFkYSBxdWFuZG8gbyBjYW1wbyBlc3RpdmVyIHZhemlvLCBtZXNtbyBxdWUgZWxlIHNlamEgb2JyaWdhdMOzcmlvLlxuICAgKi9cbiAgQElucHV0KCd0LWVycm9yLXBhdHRlcm4nKSBlcnJvclBhdHRlcm4/OiBzdHJpbmcgPSAnJztcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmUgdW1hIGRhdGEgbcOtbmltYSBwYXJhIG8gYHRoZi1kYXRlcGlja2VyYC5cbiAgICovXG4gIEBJbnB1dCgndC1taW4tZGF0ZScpIHNldCBtaW5EYXRlKHZhbHVlOiBzdHJpbmcgfCBEYXRlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY29uc3QgeWVhciA9IHZhbHVlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCB2YWx1ZS5nZXRNb250aCgpLCB2YWx1ZS5nZXREYXRlKCksIDAsIDAsIDApO1xuICAgICAgc2V0WWVhckZyb20wVG8xMDAoZGF0ZSwgeWVhcik7XG5cbiAgICAgIHRoaXMuX21pbkRhdGUgPSBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9taW5EYXRlID0gY29udmVydElzb1RvRGF0ZSh2YWx1ZSwgdHJ1ZSAsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbGlkYXRlTW9kZWwoY29udmVydERhdGVUb0lTT0V4dGVuZGVkKHRoaXMuZGF0ZSwgdGhpcy5ob3VyKSk7XG4gIH1cblxuICBnZXQgbWluRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluRGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSB1bWEgZGF0YSBtw6F4aW1hIHBhcmEgbyBgdGhmLWRhdGVwaWNrZXJgLlxuICAgKi9cbiAgQElucHV0KCd0LW1heC1kYXRlJykgc2V0IG1heERhdGUodmFsdWU6IHN0cmluZyB8IERhdGUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBjb25zdCB5ZWFyID0gdmFsdWUuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIHZhbHVlLmdldE1vbnRoKCksIHZhbHVlLmdldERhdGUoKSwgMjMsIDU5LCA1OSk7XG4gICAgICBzZXRZZWFyRnJvbTBUbzEwMChkYXRlLCB5ZWFyKTtcblxuICAgICAgdGhpcy5fbWF4RGF0ZSA9IGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21heERhdGUgPSBjb252ZXJ0SXNvVG9EYXRlKHZhbHVlLCBmYWxzZSAsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMudmFsaWRhdGVNb2RlbChjb252ZXJ0RGF0ZVRvSVNPRXh0ZW5kZWQodGhpcy5kYXRlLCB0aGlzLmhvdXIpKTtcbiAgfVxuXG4gIGdldCBtYXhEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhEYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRm9ybWF0byBkZSBleGliacOnw6NvIGRhIGRhdGEuXG4gICAqXG4gICAqIFZhbG9yZXMgdsOhbGlkb3M6XG4gICAqICAtIGBkZC9tbS95eXl5YFxuICAgKiAgLSBgbW0vZGQveXl5eWBcbiAgICogIC0gYHl5eXkvbW0vZGRgXG4gICAqXG4gICAqIEBkZWZhdWx0IGBkZC9tbS95eXl5YFxuICAgKi9cbiAgQElucHV0KCd0LWZvcm1hdCcpIHNldCBmb3JtYXQodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHZhbHVlLm1hdGNoKC9kZC8pICYmIHZhbHVlLm1hdGNoKC9tbS8pICYmIHZhbHVlLm1hdGNoKC95eXl5LykpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub2JqTWFzayA9IHRoaXMuYnVpbGRNYXNrKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaFZhbHVlKHRoaXMuZGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZm9ybWF0ID0gdGhmRGF0ZXBpY2tlckZvcm1hdERlZmF1bHQ7XG4gICAgdGhpcy5vYmpNYXNrID0gdGhpcy5idWlsZE1hc2soKTtcbiAgfVxuXG4gIGdldCBmb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIElkaW9tYSBkbyBEYXRlcGlja2VyLlxuICAgKlxuICAgKiBWYWxvcmVzIHbDoWxpZG9zOlxuICAgKiAgLSBgcHRgXG4gICAqICAtIGBlbmBcbiAgICogIC0gYGVzYFxuICAgKi9cbiAgX2xvY2FsZT86IHN0cmluZztcbiAgQElucHV0KCd0LWxvY2FsZScpIHNldCBsb2NhbGUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5fbG9jYWxlID0gdmFsdWUubGVuZ3RoID49IDIgPyB2YWx1ZSA6ICdwdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvY2FsZSA9IGdldFNob3J0QnJvd3Nlckxhbmd1YWdlKCk7XG4gICAgfVxuICB9XG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZSB8fCBnZXRTaG9ydEJyb3dzZXJMYW5ndWFnZSgpO1xuICB9XG5cbiAgLyoqIEV2ZW50byBkaXNwYXJhZG8gYW8gc2FpciBkbyBjYW1wby4gKi9cbiAgQE91dHB1dCgndC1ibHVyJykgb25ibHVyPzogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKiogRXZlbnRvIGRpc3BhcmFkbyBhbyBhbHRlcmFyIHZhbG9yIGRvIGNhbXBvLiAqL1xuICBAT3V0cHV0KCd0LWNoYW5nZScpIG9uY2hhbmdlPzogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gIGFic3RyYWN0IHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG5cbiAgYWJzdHJhY3QgcmVmcmVzaFZhbHVlKHZhbHVlOiBEYXRlKTogdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBDbGFzc2UgZGUgbcOhc2NhcmFcbiAgICB0aGlzLm9iak1hc2sgPSB0aGlzLmJ1aWxkTWFzaygpO1xuICB9XG5cbiAgLy8gQ29udmVydGUgdW0gb2JqZXRvIHN0cmluZyBlbSBEYXRlXG4gIGdldERhdGVGcm9tU3RyaW5nKGRhdGVTdHJpbmc6IHN0cmluZykge1xuICAgIGNvbnN0IGRheSA9IHBhcnNlSW50KGRhdGVTdHJpbmcuc3Vic3RyaW5nKHRoaXMuZm9ybWF0LmluZGV4T2YoJ2QnKSwgdGhpcy5mb3JtYXQuaW5kZXhPZignZCcpICsgMiksIDEwKTtcbiAgICBjb25zdCBtb250aCA9IHBhcnNlSW50KGRhdGVTdHJpbmcuc3Vic3RyaW5nKHRoaXMuZm9ybWF0LmluZGV4T2YoJ20nKSwgdGhpcy5mb3JtYXQuaW5kZXhPZignbScpICsgMiksIDEwKSAtIDE7XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KGRhdGVTdHJpbmcuc3Vic3RyaW5nKHRoaXMuZm9ybWF0LmluZGV4T2YoJ3knKSwgdGhpcy5mb3JtYXQuaW5kZXhPZigneScpICsgNCksIDEwKTtcblxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblxuICAgIHNldFllYXJGcm9tMFRvMTAwKGRhdGUsIHllYXIpO1xuXG4gICAgcmV0dXJuIChkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiYgZGF0ZS5nZXRNb250aCgpID09PSBtb250aCAmJiBkYXRlLmdldERhdGUoKSA9PT0gZGF5KSA/IGRhdGUgOiBudWxsO1xuICB9XG5cbiAgLy8gRm9ybWF0YSBhIGRhdGEuXG4gIGZvcm1hdFRvRGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGxldCBkYXRlRm9ybWF0dGVkID0gdGhpcy5mb3JtYXQ7XG5cbiAgICBkYXRlRm9ybWF0dGVkID0gZGF0ZUZvcm1hdHRlZC5yZXBsYWNlKCdkZCcsICgnMCcgKyB2YWx1ZS5nZXREYXRlKCkpLnNsaWNlKC0yKSk7XG4gICAgZGF0ZUZvcm1hdHRlZCA9IGRhdGVGb3JtYXR0ZWQucmVwbGFjZSgnbW0nLCAoJzAnICsgKHZhbHVlLmdldE1vbnRoKCkgKyAxKSkuc2xpY2UoLTIpKTtcbiAgICBkYXRlRm9ybWF0dGVkID0gZGF0ZUZvcm1hdHRlZC5yZXBsYWNlKCd5eXl5JywgZm9ybWF0WWVhcih2YWx1ZS5nZXRGdWxsWWVhcigpKSk7XG5cbiAgICByZXR1cm4gZGF0ZUZvcm1hdHRlZDtcbiAgfVxuXG4gIC8vIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb250cm9sYXIgbyBtb2RlbG8uXG4gIGNvbnRyb2xNb2RlbChkYXRlOiBEYXRlKSB7XG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgICBpZiAoZGF0ZSAmJiB0aGlzLmlzRXh0ZW5kZWRJU08pIHtcbiAgICAgIHRoaXMuY2FsbE9uQ2hhbmdlKGNvbnZlcnREYXRlVG9JU09FeHRlbmRlZCh0aGlzLmRhdGUsIHRoaXMuaG91cikpO1xuICAgIH0gZWxzZSBpZiAoZGF0ZSAmJiAhdGhpcy5pc0V4dGVuZGVkSVNPKSB7XG4gICAgICB0aGlzLmNhbGxPbkNoYW5nZShjb252ZXJ0RGF0ZVRvSVNPRGF0ZSh0aGlzLmRhdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5jYWxsT25DaGFuZ2UoJycpIDogdGhpcy5jYWxsT25DaGFuZ2UoJ0RhdGEgaW52w6FsaWRhJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gRXhlY3V0YSBhIGZ1bsOnw6NvIG9uQ2hhbmdlXG4gIGNhbGxPbkNoYW5nZSh2YWx1ZTogYW55LCByZXRyeTogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5vbkNoYW5nZU1vZGVsKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlTW9kZWwodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocmV0cnkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jYWxsT25DaGFuZ2UodmFsdWUsIGZhbHNlKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRnVuw6fDo28gaW1wbGVtZW50YWRhIGRvIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gIC8vIFVzYWRhIHBhcmEgaW50ZXJjZXB0YXIgYXMgbXVkYW7Dp2FzIGUgbsOjbyBhdHVhbGl6YXIgYXV0b21hdGljYW1lbnRlIG8gTW9kZWxcbiAgcmVnaXN0ZXJPbkNoYW5nZShmdW5jOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlTW9kZWwgPSBmdW5jO1xuICB9XG5cbiAgLy8gRnVuw6fDo28gaW1wbGVtZW50YWRhIGRvIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gIC8vIFVzYWRhIHBhcmEgaW50ZXJjZXB0YXIgYXMgbXVkYW7Dp2FzIGUgbsOjbyBhdHVhbGl6YXIgYXV0b21hdGljYW1lbnRlIG8gTW9kZWxcbiAgcmVnaXN0ZXJPblRvdWNoZWQoZnVuYzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWRNb2RlbCA9IGZ1bmM7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy52YWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHByb3RlY3RlZCB2YWxpZGF0ZU1vZGVsKG1vZGVsOiBhbnkpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0b3JDaGFuZ2UpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yQ2hhbmdlKG1vZGVsKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXRvcm5hIHVtIG9iamV0byBkbyB0aXBvIFRoZk1hc2sgY29tIGEgbWFzY2FyYSBjb25maWd1cmFkYS5cbiAgcHJvdGVjdGVkIGJ1aWxkTWFzaygpIHtcbiAgICBsZXQgbWFzayA9IHRoaXMuZm9ybWF0LnRvVXBwZXJDYXNlKCk7XG5cbiAgICBtYXNrID0gbWFzay5yZXBsYWNlKC9ERC9nLCAnOTknKTtcbiAgICBtYXNrID0gbWFzay5yZXBsYWNlKC9NTS9nLCAnOTknKTtcbiAgICBtYXNrID0gbWFzay5yZXBsYWNlKC9ZWVlZL2csICc5OTk5Jyk7XG5cbiAgICByZXR1cm4gbmV3IFRoZk1hc2sobWFzaywgdHJ1ZSk7XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7IFtrZXk6IHN0cmluZ106IGFueTsgfSB7XG4gICAgLy8gVmVyaWZpY2Egc2UgasOhIHBvc3N1aSBhbGd1bSBlcnJvciBwYXR0ZXJuIHBhZHLDo28uXG4gICAgdGhpcy5lcnJvclBhdHRlcm4gPSB0aGlzLmVycm9yUGF0dGVybiAhPT0gJ0RhdGEgaW52w6FsaWRhJyAmJiB0aGlzLmVycm9yUGF0dGVybiAhPT0gJ0RhdGEgZm9yYSBkbyBwZXLDrW9kbycgPyB0aGlzLmVycm9yUGF0dGVybiA6ICcnO1xuXG4gICAgaWYgKGRhdGVGYWlsZWQoYy52YWx1ZSkpIHtcbiAgICAgIHRoaXMuZXJyb3JQYXR0ZXJuID0gdGhpcy5lcnJvclBhdHRlcm4gfHwgJ0RhdGEgaW52w6FsaWRhJztcblxuICAgICAgcmV0dXJuIHsgZGF0ZToge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICB9fTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZWRGYWlsZWQodGhpcy5yZXF1aXJlZCwgdGhpcy5kaXNhYmxlZCwgYy52YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IHJlcXVpcmVkOiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgIH19O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5kYXRlICYmICF2YWxpZGF0ZURhdGVSYW5nZSh0aGlzLmRhdGUsIHRoaXMuX21pbkRhdGUsIHRoaXMuX21heERhdGUpKSkge1xuICAgICAgdGhpcy5lcnJvclBhdHRlcm4gPSB0aGlzLmVycm9yUGF0dGVybiB8fCAnRGF0YSBmb3JhIGRvIHBlcsOtb2RvJztcblxuICAgICAgcmV0dXJuIHsgZGF0ZToge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICB9fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG4iXX0=